\documentclass[report.tex]{subfiles}
\graphicspath{ \subfix{./images/} \subfix{./graphs/} }
\begin{document}
\chapter{Development}

\section{Milestone 1: Create the UI}

\subsection{Objective}

During this milestone, a basic prototype with user interface will be created. The prototype needs to compile and run and the user should be able to navigate around the app to see different UI elements.

\subsection{Create a minimal running prototype}

\subsubsection{Implementation}

I will create a prototype with a minimal user interface to test run the development environment and building tools.\cite{microsoft:docs:create-your-first-winui3-app}

I create the \code{App.xaml} file, which will include all application resources. Right now, the only resources imported is the \code{XamlControlsResource}, which provides the resources for the all controls. Later on, I will create and import new resources in this file.

\begin{minted}{xml}
<Application
    x:Class="Algorithm_Dynamics.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Algorithm_Dynamics">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <XamlControlsResources xmlns="using:Microsoft.UI.Xaml.Controls" />
                <!-- Other merged dictionaries here -->
            </ResourceDictionary.MergedDictionaries>
            <!-- Other app resources here -->
        </ResourceDictionary>
    </Application.Resources>
</Application>
\end{minted}

I then create the \code{App.xaml.cs} file, which will include the main entry point of the application. It inheriates from the \code{Application} class, and create a \code{Window} object to show the main window. The \code{App} class will activate the main window when it is launched.

\begin{minted}{csharp}
using Microsoft.UI.Xaml;

namespace Algorithm_Dynamics
{
    /// <summary>
    /// Provides application-specific behavior to supplement the default Application class.
    /// </summary>
    public partial class App : Application
    {
        /// <summary>
        /// Initializes the singleton application object.  This is the first line of authored code
        /// executed, and as such is the logical equivalent of main() or WinMain().
        /// </summary>
        public App()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Invoked when the application is launched normally by the end user.  Other entry points
        /// will be used such as when the application is launched to open a specific file.
        /// </summary>
        /// <param name="args">Details about the launch request and process.</param>
        protected override void OnLaunched(LaunchActivatedEventArgs args)
        {
            m_window = new MainWindow();
            m_window.Activate();
        }

        private Window m_window;
    }
}
\end{minted}

Next, I create the \code{MainWindow.xaml} file, which includes the layout of the main window. Right now, it only has a stack panel and a button inside to test everything is working.

\begin{minted}{xml}
<Window
    x:Class="Algorithm_Dynamics.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Algorithm_Dynamics"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d">

    <StackPanel 
        Orientation="Horizontal" 
        HorizontalAlignment="Center" 
        VerticalAlignment="Center">
        <Button 
            x:Name="myButton"
            Click="myButton_Click"
            Content="Click Me"/>
    </StackPanel>
</Window>
\end{minted}

Finally, I create the \code{MainWindow.xaml.cs} file. It contains all the UI logic. In this prototype, when the button in the UI is clicked, its text will be changed to ``Clicked''.

\begin{minted}{csharp}
using Microsoft.UI.Xaml;

namespace Algorithm_Dynamics
{
    /// <summary>
    /// The main window object that is used to display all other elements
    /// </summary>
    public sealed partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private void myButton_Click(object sender, RoutedEventArgs e)
        {
            myButton.Content = "Clicked";
        }
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{Prototype-Button-Click-Me.png}

As expected, a window with a button shows up correctly. After clicking the button, the content in the button is changed to ``Clicked'' correctly.

\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{Prototype-Button-Clicked.png}

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Test & Result & Remark \\
    \hline
    Does it compile & Pass & \\
    \hline
    Does it deploy & Pass & \\
    \hline
    Does it run & Pass & \\
    \hline
    Does the button work & Pass & \\
    \hline
\end{tabulary}

This is the simplest prototype, and its successful running means the development environment and the building tools are set up correctm, and I can start developing a more complex user interface.

\subsubsection{CI/CD pipeline}

I then set up the continuous integration pipeline based on the prototype. There are three jobs in the pipeline: test the app, build and sign the app, and deploy the app if a new version is released.

I am using the GitHub Actions\cite{github:actions} for this pipeline. I need to set up a YAML file to configure the pipeline.

\begin{minted}{yaml}
# The name of the pipeline
name: Build

# Triggered when a new commit is pushed to main
# Or a new tag is pushed to main
# Or a pull request is opened on main
on:
  push:
    branches: [main]
    tags:
      - '*'
  pull_request:
    branches: [main]

  workflow_dispatch:
  # Test the app using dotnet test
  test-app:
    name: Test App
    runs-on: windows-2022
    steps:
    - name: Checkout
      uses: actions/checkout@v2
      with:
        fetch-depth: 0
    
    # Cache nuget
    - uses: actions/cache@v2
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('src\Algorithm Dynamics.Core\Algorithm Dynamics.Core.csproj') }}-${{ hashFiles('src\Algorithm Dynamics.Test\Algorithm Dynamics.Test.csproj') }}

    # Execute all unit tests in the solution
    - name: Execute unit tests
      working-directory: src\Algorithm Dynamics.Test
      run: dotnet test --filter TestCategory!=TestRunCode

  # Build the app using msbuild
  build-app:
    name: Build App
    runs-on: windows-2022
    env:
      Solution_Name: Algorithm Dynamics.sln
      Project_Directory: src\Algorithm Dynamics
    outputs:
      version: ${{ steps.getappmanifest.outputs.version }}
    strategy:
      matrix:
        targetPlatform: [x86, x64, arm64]
    steps:
    - name: Checkout
      uses: actions/checkout@v2
      with:
        fetch-depth: 0

    # Cache nuget
    - uses: actions/cache@v2
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ matrix.targetplatform }}-${{ hashFiles('src\Algorithm Dynamics\Algorithm Dynamics.csproj') }}-${{ hashFiles('src\Algorithm Dynamics.Core\Algorithm Dynamics.Core.csproj') }}

    # Add MSBuild to the PATH: https://github.com/microsoft/setup-msbuild
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v1.1

    # Build app package
    - name: Create the ${{ matrix.targetplatform }} app package
      working-directory: src
      env:
        Solution_Name: Algorithm Dynamics.sln
        Appx_Bundle_Platforms: x86|x64|arm64
        Platform: ${{ matrix.targetplatform }}
        Configuration: Release
        Appx_Package_Build_Mode: StoreUpload
        Appx_Bundle: Never
        Appx_Package_Dir: AppPackages\
      run: |
        msbuild "$env:Solution_Name" /restore /p:AppxBundlePlatforms="$env:Appx_Bundle_Platforms" /p:Platform="$env:Platform" /p:Configuration=$env:Configuration /p:UapAppxPackageBuildMode=$env:Appx_Package_Build_Mode /p:AppxBundle=$env:Appx_Bundle /p:AppxPackageSigningEnabled=false /p:AppxPackageDir="$env:Appx_Package_Dir" /p:GenerateAppxPackageOnBuild=true -m

    # Upload build artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v2
      with:
        name: ${{ matrix.targetplatform }} Package
        path: src\Algorithm Dynamics\AppPackages\**\Algorithm Dynamics*.msix

    # Read the version of the app
    - name: Get app manifest
      id: getappmanifest
      working-directory: src
      run: |
        [xml]$manifest = get-content "Algorithm Dynamics\Package.appxmanifest"
        $version = $manifest.Package.Identity.Version
        echo $version
        echo "::set-output name=version::$version"

  # Sign the app
  sign-app:
    name: Sign App
    runs-on: windows-2022
    needs: [test-app, build-app]
    env:
      Solution_Name: Algorithm Dynamics.sln
      Project_Directory: src\Algorithm Dynamics
    steps:

    # Set up working directory
    - name: Create directory
      run: |
        mkdir src\Bundle
        mkdir "src\Algorithm Dynamics"

    # Decode the base 64 encoded pfx and save the Signing_Certificate
    - name: Decode the pfx
      id: decodepfx
      run: |
        $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.AlgorithmDynamics_TemporaryKey }}")
        $certificatePath = Join-Path -Path $env:Project_Directory -ChildPath AlgorithmDynamics_TemporaryKey.pfx
        [IO.File]::WriteAllBytes("$certificatePath", $pfx_cert_byte)
        echo "::set-output name=cert_path::$certificatePath"

    # Download build artifacts
    - name: Prepare x86 MSIX
      uses: actions/download-artifact@v2
      with:
        name: x86 Package
        path: src\Bundle

    - name: Prepare x64 MSIX
      uses: actions/download-artifact@v2
      with:
        name: x64 Package
        path: src\Bundle

    - name: Prepare arm64 MSIX
      uses: actions/download-artifact@v2
      with:
        name: arm64 Package
        path: src\Bundle

    # Bundle and sign the app
    - name: Create MSIX Bundle
      uses: LanceMcCarthy/Action-MsixBundler@v1.0.1
      with:
        msix-folder: src\Bundle
        msixbundle-filepath: src\Bundle\Algorithm Dynamics_x86_x64_arm64.msixbundle
        msixbundle-version: ${{ needs.build-app.outputs.version }}
        enable-bundle-signing: true
        certificate-path: ${{ steps.decodepfx.outputs.cert_path }}
        certificate-private-key: ${{ secrets.Pfx_Key }}

    # Remove the pfx
    - name: Remove the pfx
      run: |
        $certificatePath = Join-Path -Path $env:Project_Directory -ChildPath AlgorithmDynamics_TemporaryKey.pfx
        Remove-Item -path $certificatePath

    # Upload the MSIX package: https://github.com/marketplace/actions/upload-a-build-artifact
    - name: Upload build artifacts
      uses: actions/upload-artifact@v2
      with:
        name: MSIX Package Release
        path: src\Bundle\*.msixbundle

    - name: Delete Artifact
      uses: GeekyEggo/delete-artifact@v1.0.0
      with:
        name: |
          x86 Package
          x64 Package
          arm64 Package
        failOnError: false

  # Distribute to Microsoft Store
  distribute:
    if: startsWith(github.event.ref, 'refs/tags/v')
    name: Distribute App
    runs-on: [self-hosted]
    needs: [test-app, sign-app]
    steps:
      # Prepare the app
      - name: Prepare app
        uses: actions/download-artifact@v2
        with:
          name: MSIX Package Release
          path: Release
      
      # Publish to Microsoft Store
      - uses: isaacrlevin/windows-store-action@1.0
        name: Publish to Store
        with:
          tenant-id: ${{ secrets.AZURE_AD_TENANT_ID }}
          client-id: ${{ secrets.AZURE_AD_APPLICATION_CLIENT_ID }}
          client-secret: ${{ secrets.AZURE_AD_APPLICATION_SECRET }}
          app-id: ${{ secrets.STORE_APP_ID }}
          package-path: "Release"
          skip-polling: ""

\end{minted}

Now, everytime when I push a commit to the remote repo, the app will be automatically build and tested, which ensures the code quality throughout the developement stage.

Here is an example of a success run of the build job.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CICD-Example}

\subsection{Create the NavigationView}

\subsubsection{Implementation}

First, I will implement the NavigationView as \hyperref[sec:NavigationViewDesign]{designed}. In the MainWindow.xaml file, I add the NavigationView control.

\begin{minted}{xml}
<NavigationView 
    x:Name="MainNavView"
    x:FieldModifier="public"
    IsBackButtonVisible="Collapsed"
    SelectionChanged="MainNavView_SelectionChanged">
</NavigationView>
\end{minted}

I assign a name \code{MainNavView} to the control so I can call it later in the code behind. I decide to hide the back button, which prevent the user to navigate the page in an unintended way. I also assign a \code{SelectionChanged} event handler to the control, which will be used to handle the navigation.

I then need to add different options to the navigation menu.

\begin{minted}{xml}
<NavigationView.MenuItems>
    <NavigationViewItem 
        x:Name="HomePageNavViewItem"
        Icon="Home"
        Content="Home"
        Tag="HomePage" />
    <NavigationViewItem
        x:Name="ProblemsPageNavViewItem"
        Icon="List"
        Content="Problems"
        Tag="ProblemsPage" />
    <NavigationViewItem
        x:Name="AssignmentsPageNavViewItem"
        Icon="Library"
        Content="Assignments"
        Tag="AssignmentsPage"/>
    <NavigationViewItem
        x:Name="PlaygroundPageNavViewItem"
        Icon="Edit"
        Content="Playground"
        Tag="PlaygroundPage"/>
</NavigationView.MenuItems>
\end{minted}

There are four options in the menu as designed. Each of which is assigned a name, icon, content and tag. The content and icon will be displayed to the user. The tag is used to identify the page that will be displayed when the option is clicked.

I add the account option to the footer.

\begin{minted}{xml}
<NavigationView.FooterMenuItems>
    <NavigationViewItem
        x:Name="AccountNavItem"
        Icon="Contact"
        Content="Account"
        Tag="AccountPage"/>
</NavigationView.FooterMenuItems>
\end{minted}

I add the content frame used to contain different pages.

\begin{minted}{xml}
<Frame
    x:Name="ContentFrame"
    Padding="0"
    Visibility="Visible"/>
\end{minted}

Now the layout of the NavigationView is finished. I need to add the code to initialize the control and handle the navigation.

When the main window is first initialized, the HomePage should be selected, and the title of the window should be set correctly. So I update the constructor of the main window to set the values.

\begin{minted}{csharp}
public MainWindow()
{
    InitializeComponent();
    Title = "Algorithm Dynamics";
    // Select HomePage when first loaded
    MainNavView.SelectedItem = MainNavView.MenuItems[0];
}
\end{minted}

Next, I need to handle the \code{SelectionChanged} event, this event gets triggered when the user clicks on a navigation item, and it will update the content frame to display the corresponding page.

\begin{minted}{csharp}
/// <summary>
/// Handle the SelectionChanged event of the MainNavView
/// Navigate to the corresponding page when the selection is changed
/// </summary>
/// <param name="sender"></param>
/// <param name="args"></param>
private void MainNavView_SelectionChanged(NavigationView sender, NavigationViewSelectionChangedEventArgs args)
{
    if (args.IsSettingsSelected)
    {
        // If the settings is selected, navigate to the settings page
        ContentFrame.Navigate(typeof(Pages.SettingsPage));
    }
    else
    {
        // Otherwise, get the selected item. If it is not null, get its Tag
        // Navigate to Algorithm_Dynamics.Pages.<Tag>
        NavigationViewItem selectedItem = args.SelectedItem as NavigationViewItem;
        if (selectedItem != null)
        {
            string tag = selectedItem.Tag as string;
            string pageName = "Algorithm_Dynamics.Pages." + tag;
            Type pageType = Type.GetType(pageName);
            ContentFrame.Navigate(pageType);
        }
    }
}
\end{minted}


Now, if I build and run the application, I should see the \code{NavigationView} works correctly. However, I get a runtime exception.

\begin{minted}{text}
System.NullReferenceException
  HResult=0x80004003
  Message=Object reference not set to an instance of an object.
  Source=WinRT.Runtime
  StackTrace:
   at ABI.System.Type.ToAbi(Type value)
   at ABI.System.Type.CreateMarshaler(Type value)
   at ABI.Microsoft.UI.Xaml.Controls.INavigate.global::Microsoft.UI.Xaml.Controls.INavigate.Navigate(Type sourcePageType)
   at Microsoft.UI.Xaml.Controls.Frame.Navigate(Type sourcePageType)
   at Algorithm_Dynamics.MainWindow.MainNavView_SelectionChanged(NavigationView sender, NavigationViewSelectionChangedEventArgs args) in C:\Algorithm-Dynamics\src\Algorithm Dynamics\MainWindow.xaml.cs:line 43
\end{minted}


It says object reference not set to an instance of an object when executing \code{ContentFrame.Navigate(pageType);}. This means the \code{pageType} does not exist. This is because I forget to create an actual HomePage, so it attempts to load a null object, failed, and throws the exception.  

I create all pages under the \code{Algorithm_Dynamics.Pages} namespace. For now, all of them will only contain a text block showing their name. Here is an example of the HomePage.

\begin{minted}{xml}
<Page
    x:Class="Algorithm_Dynamics.Pages.HomePage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Algorithm_Dynamics.Pages"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Grid>
        <TextBlock Text="HomePage"/>
    </Grid>
</Page>
\end{minted}


\begin{minted}{csharp}
using Microsoft.UI.Xaml.Controls;

namespace Algorithm_Dynamics.Pages
{
    public sealed partial class HomePage : Page
    {
        public HomePage()
        {
            this.InitializeComponent();
        }
    }
}
\end{minted}

Now, the software build and run successfully. The HomePage is correctly selected when it is launched and the TextBlock HomePage shows up correctly means that the right page is loaded.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-Draft-TextBlock}

When I click on other tabs on the NavigationView, the corresponding page is loaded correctly as well.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-Draft-TextBlock}

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Test & Result & Remark \\
    \hline
    Does it load & Pass & \\
    \hline
    Does the button work & Pass & \\
    \hline
    Does it response to different screen size & Pass & \\
    \hline
\end{tabulary}

Now the NavigationView is built and tested. I will continue to build other components in the next section.

\subsection{Create the HomePage}

\subsubsection{Implementation}

The HomePage is made of three components, the background image, the quick access tools and the recommendations. They are wrapped by a scroller so they can be accessed on any size screen. I place a grid with two rows inside the \code{ScrollViewer}, the first row contains the background image, the second row contains the remaining tools. 

\begin{minted}{xml}
<Page
    x:Class="Algorithm_Dynamics.Pages.HomePage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Algorithm_Dynamics.Pages"
    xmlns:models="using:Algorithm_Dynamics.Models"
    xmlns:controls="using:CommunityToolkit.WinUI.UI.Controls"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
    <ScrollViewer>
        <Grid>
            <Grid.RowDefinitions>
                <RowDefinition Height="auto"/>
                <RowDefinition Height="auto"/>
            </Grid.RowDefinitions>
            <Grid Grid.Row="0">
                <!-- Background Image -->
            </Grid>
            <Grid 
                Margin="24"
                Grid.Row="1">
                <!-- Quick Access tools and Recommendations -->
            </Grid>
        </Grid>
    </ScrollViewer>
</Page>
\end{minted}

Inside the background image grid, I place a \code{Image} control with the source of the background image. It is stretched to fill the entire grid so \code{Strecth} is set to \code{UniformToFill}.

\begin{minted}{xml}
<Image 
    Source="/Assets/HomePageBackgroundImage.jpg" 
    Height="256"
    Stretch="UniformToFill"/>
<TextBlock 
    Text="{x:Bind WelcomeMessage, Mode=OneTime, FallbackValue='Welcome User'}"
    HorizontalAlignment="Right"
    VerticalAlignment="Bottom"
    Margin="8"
    Foreground="White"
    Style="{ThemeResource TitleTextBlockStyle}"/>
\end{minted}

The \code{TextBlock} is used to display a greeting message. It is placed on the bottom right. Because its content needs to be adjusted by the current time and the current user, it is binded to the a variable \code{WelcomeMessage} so I can change its value programmatically.

\begin{minted}{csharp}
namespace Algorithm_Dynamics.Pages
{
    public sealed partial class HomePage : Page
    {
        /// <summary>
        /// The WelcomeMessage is displayed to the user on the HomePage
        /// </summary>
        public string WelcomeMessage { get; set; }
        public HomePage()
        {
            InitializeComponent();
        }
    }
}
\end{minted}

The welcome message is adjusted by different time in the day. It should also display the user name, but since the settings module is not implemented yet, I use a placeholder for the user name.

\begin{minted}{csharp}
/// <summary>
/// Set the WelcomeMessage based on the current time.
/// Morning: 00:00-12:00
/// Afternoon: 12:00-17:00
/// Evening 17:00-0:00
/// TODO Add the username after it is implemented
/// </summary>
private void SetWelcomeMessage()
{
    TimeSpan now = DateTime.Now.TimeOfDay;
    if (now >= new TimeSpan(00, 00, 00) && now < new TimeSpan(12, 00, 00))
    {
        WelcomeMessage = "Good morning, user!";
    }
    else if (now >= new TimeSpan(12, 00, 00) && now < new TimeSpan(17, 00, 00))
    {
        WelcomeMessage = "Good afternoon, user!";
    }
    else if (now >= new TimeSpan(17, 00, 00) && now <= new TimeSpan(23, 59, 59))
    {
        WelcomeMessage = "Good evening, user!";
    }
}
\end{minted}

Now I just need to set the welcome message in the constructor. Notice that it needs to be called before all components are initialized, so the text block can bind to the updated value.

\begin{minted}{csharp}
public HomePage()
{
    SetWelcomeMessage();
    InitializeComponent();
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-Image}

The image and the greeting message show up correctly, and because I am writing this in the morning, the correct greeting message is displayed.

For the quick access toolbar, I choose to use the \code{AdaptiveGridView} control for its \code{OneRowMode} function, which allows the toolbar to scroll horizontally on small screens. The controls in the quick access toolbar should be loaded dynamically, so they can be changed easily in the future. So I create a \code{QuickAccessItem} helper class. Each object will contain a name, an icon and an action. The name and the icon will be displayed to the user, and the action will be invoked when the user clicks on the control.

\begin{minted}{csharp}
using Microsoft.UI.Xaml.Controls;
using System;

namespace Algorithm_Dynamics.Models
{
    public class QuickAccessItem
    {
        public string Name { get; set; }
        public Symbol Icon { get; set; }
        public Action<MainWindow> Action { get; set; }
        public QuickAccessItem(string name, Symbol icon, Action<MainWindow> action)
        {
            Name = name;
            Icon = icon;
            Action = action;
        }
    }
}
\end{minted}

Then I create a \code{ObserableCollection} of \code{QAItems} that binds to the grid.

\begin{minted}{csharp}
public ObservableCollection<QuickAccessItem> QAItems { get; } = new ObservableCollection<QuickAccessItem>();
\end{minted}

\begin{minted}{xml}
<TextBlock 
    Text="Quick Access"
    Grid.Row="0"
    Style="{ThemeResource SubtitleTextBlockStyle}"/>
<controls:AdaptiveGridView 
    Grid.Row="1"
    Margin="4"
    ItemsSource="{x:Bind QAItems}"
    StretchContentForSingleRow="True"
    OneRowModeEnabled="True"
    ItemHeight="160"
    DesiredWidth="160"
    SelectionMode="None"
    IsItemClickEnabled="True">
    <GridView.ItemTemplate>
        <DataTemplate x:DataType="models:QuickAccessItem">
            <StackPanel 
                VerticalAlignment="Center"
                HorizontalAlignment="Center"
                Orientation="Vertical">
                <SymbolIcon 
                    x:Name="ItemIcon"
                    Symbol="{x:Bind Icon}"/>
                <TextBlock Text="{x:Bind Name}" />
            </StackPanel>
        </DataTemplate>
    </GridView.ItemTemplate>
</controls:AdaptiveGridView>
\end{minted}

I need to add the items to the collection when the HomePage is loaded. I create a procedure \code{InitializeQAItems}. Because I have passed the MainWindow object to the function, the MainNavView can be called inside. Because the CodingPage and the import/export logic is not completed yet, the Random Problem and Import function will be implemented later.

\begin{minted}{csharp}
public HomePage()
{
    SetWelcomeMessage();
    InitializeQAItems();
    InitializeComponent();
}
private void InitializeQAItems()
{
    QAItems.Clear();
    QAItems.Add(new QuickAccessItem("Random Problem", Symbol.Shuffle, (m_window) =>
    {
        m_window.MainNavView.SelectedItem = null;
        // TODO Navigate the ContentFrame to the Coding page manually
        throw new NotImplementedException("[Blocking]: The CodingPage has not been implemented yet.");
    }));
    QAItems.Add(new QuickAccessItem("Playground", Symbol.Edit, (m_window) =>
        m_window.MainNavView.SelectedItem = m_window.MainNavView.MenuItems[1]));
    QAItems.Add(new QuickAccessItem("Assignments", Symbol.Library, (m_window) =>
        m_window.MainNavView.SelectedItem = m_window.MainNavView.MenuItems[2]));
    QAItems.Add(new QuickAccessItem("Problems", Symbol.List, (m_window) =>
        m_window.MainNavView.SelectedItem = m_window.MainNavView.MenuItems[3]));
    QAItems.Add(new QuickAccessItem("Settings", Symbol.Setting, (m_window) =>
        m_window.MainNavView.SelectedItem = m_window.MainNavView.SettingsItem));
    QAItems.Add(new QuickAccessItem("Account", Symbol.Contact, (m_window) =>
        m_window.MainNavView.SelectedItem = m_window.MainNavView.FooterMenuItems[0]));
    QAItems.Add(new QuickAccessItem("Import", Symbol.Import, (m_window) =>
    {
        m_window.MainNavView.SelectedItem = null;
        // TODO Handle the import logic
        throw new NotImplementedException("[Blocking]: The import logic has not been implemented yet.");
    }));
}
\end{minted}

I need to handle the click event of the quick access toolbar. I create a procedure \code{QAGridView_ItemClick}, which will invoke the action of the item.

\begin{minted}{csharp}
/// <summary>
/// Handle the QAGridView click event. The Action will be invoked.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void QAGridView_ItemClick(object sender, ItemClickEventArgs e)
{
    MainWindow m_window = (MainWindow)((App)Application.Current).m_window;
    if (e.ClickedItem is QuickAccessItem item)
    {
        item.Action(m_window);
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-QuickAccessToolbar.png}

Now, when I build and run the application, the quick access toolbar shows up correctly and scroll horizontally as expected. When I click the different buttons, it navigates to the corresponding page correctly. When I click the Random Problem button, the software panic and a NotImplementedException is thrown with the correct error message.

\begin{minted}{text}
System.NotImplementedException
  HResult=0x80004001
  Message=[Blocking]: The CodingPage has not been implemented yet.
  Source=Algorithm Dynamics
  StackTrace:
   at Algorithm_Dynamics.Pages.HomePage.<>c.<InitializeQAItems>b__13_0(MainWindow m_window) in C:\Algorithm-Dynamics\src\Algorithm Dynamics\Pages\HomePage.xaml.cs:line 70
   at Algorithm_Dynamics.Pages.HomePage.QAGridView_ItemClick(Object sender, ItemClickEventArgs e) in C:\Algorithm-Dynamics\src\Algorithm Dynamics\Pages\HomePage.xaml.cs:line 59
   at WinRT._EventSource_global__Microsoft_UI_Xaml_Controls_ItemClickEventHandler.EventState.<GetEventInvoke>b__1_0(Object sender, ItemClickEventArgs e)
   at ABI.Microsoft.UI.Xaml.Controls.ItemClickEventHandler.<>c__DisplayClass10_0.<Do_Abi_Invoke>b__0(ItemClickEventHandler invoke)
   at ABI.Microsoft.UI.Xaml.Controls.ItemClickEventHandler.Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr e)
\end{minted}

The recommendation control is similar. I create the \code{RecommendItem} class and add the items to the collection.

\begin{minted}{csharp}
namespace Algorithm_Dynamics.Models
{
    public class RecommendItem
    {
        public string Title { get; set; }
        public string Description { get; set; }
        public RecommendItem(string title, string description)
        {
            Title = title;
            Description = description;
        }
    }
}
\end{minted}

\begin{minted}{csharp}
public ObservableCollection<RecommendItem> RecItems { get; } = new ObservableCollection<RecommendItem>();
\end{minted}

Then bind the AdaptiveGridView to the collection.

\begin{minted}{csharp}
<TextBlock 
    Text="Recommended"
    Grid.Row="2"
    Style="{ThemeResource SubtitleTextBlockStyle}"/>
<controls:AdaptiveGridView
    x:Name="RecGridView"
    Grid.Row="3"
    Margin="4"
    ItemsSource="{x:Bind RecItems}"
    StretchContentForSingleRow="False"
    OneRowModeEnabled="False"
    ItemHeight="80"
    DesiredWidth="320"
    SelectionMode="None"
    IsItemClickEnabled="True"
    ItemClick="RecGridView_ItemClick">
    <GridView.ItemTemplate>
        <DataTemplate x:DataType="models:RecommendItem">
            <Grid HorizontalAlignment="Stretch">
                <StackPanel 
                    VerticalAlignment="Center"
                    HorizontalAlignment="Left"
                    Orientation="Vertical"
                    Margin="8">
                    <TextBlock Text="{x:Bind Title}"
                                Style="{ThemeResource BodyStrongTextBlockStyle}"/>
                    <TextBlock Text="{x:Bind Description}"/>
                </StackPanel>
            </Grid>
        </DataTemplate>
    </GridView.ItemTemplate>
</controls:AdaptiveGridView>
\end{minted}

For now, because the database and the data structure are not ready, I just add some dummy data to the collection. The recommendation logic will be added later.

\begin{minted}{csharp}
public HomePage()
{
    SetWelcomeMessage();
    InitializeQAItems();
    InitializeRecItems();
    InitializeComponent();
}
/// <summary>
/// TODO Generate Recommendation from database.
/// </summary>
private void InitializeRecItems()
{
    RecItems.Clear();
    RecItems.Add(new RecommendItem("Problem 1", "Easy | Data structure"));
    RecItems.Add(new RecommendItem("Problem 2", "Medium | Sorting"));
    RecItems.Add(new RecommendItem("Problem 3", "Hard | Graph"));
    RecItems.Add(new RecommendItem("Problem 4", "Easy | Data structure"));
    RecItems.Add(new RecommendItem("Assignment 1", "Due in 2 days"));
    RecItems.Add(new RecommendItem("Assignment 2", "Due in 3 days"));
    RecItems.Add(new RecommendItem("Assignment 3", "Due in 4 days"));
    RecItems.Add(new RecommendItem("Assignment 4", "Due in 5 days"));
}
\end{minted}

I need to handle the click event as well. And because neither the AssignmentsPage nor the CodingPage is ready, it will throw an NotImplementedException too.

\begin{minted}{csharp}
/// <summary>
/// Handle the RecGridView click event.
/// Navigate to the corresponding Problem or Assignment
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void RecGridView_ItemClick(object sender, ItemClickEventArgs e)
{
    // TODO Handle the navigation.
    throw new NotImplementedException("[Blocking]: The CodingPage or the AssignmentsPage has not been implemented yet.");
}
\end{minted}

Now, the HomePage is implemented. I run the application and test it.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-Finished}

All components show up correctly. The image is loaded and the greeting message is correct. The Quick Access Toolbar navigates correctly. When I click the recommended item, the correct exception is thrown.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-Finished-Scroll}

The scroller is working as well, so I can scroll down on a small window to see the recommendation items.

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Test & Result & Remark \\
    \hline
    Does it load & Pass & \\
    \hline
    Does the background image show up correctly & Pass & \\
    \hline
    Does the greeting message show up correctly & Pass & \\
    \hline
    Does the Quick Access Toolbar show up correctly & Pass & \\
    \hline
    Does the Quick Access Toolbar work correctly & Failed & The Random Problems and data import function is not implemented and will be implemented in the future. This test case will be reviewed then. \\
    \hline
    Does the Recommendation show up correctly & Pass &  \\
    \hline
    Does the Recommendation work correctly & Failed & The database and the data structure will be implemented in the future. This test case will be reviewed then. \\
    \hline
    Is the page responsive & Pass & \\
    \hline
\end{tabulary}

\subsection{Create the ProblemsPage}

\subsubsection{Implementation}

I move on to design the ProblemsPage. It contains two parts, the toolbar at the top and the problem list below. I will use a grid containing two rows to hold these two components.

\begin{minted}{xml}
<Page
    x:Class="Algorithm_Dynamics.Pages.ProblemsPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Algorithm_Dynamics.Pages"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        <Grid
            Grid.Row="0"
            HorizontalAlignment="Stretch">
            <!-- Toolbar -->
        </Grid>
        <Grid
            Grid.Row="1"
            HorizontalAlignment="Stretch">
            <!-- Problem List -->
        </Grid>
    </Grid>
</Page>
\end{minted}

For the toolbar, I use a grid with 6 columns to hold the search box and the ComboBoxes.

\begin{minted}{xml}
<Grid.ColumnDefinitions>
    <ColumnDefinition Width="2*"/>
    <ColumnDefinition Width="*"/>
    <ColumnDefinition Width="*"/>
    <ColumnDefinition Width="*"/>
    <ColumnDefinition Width="*"/>
    <ColumnDefinition Width="*"/>
</Grid.ColumnDefinitions>
<AutoSuggestBox 
    Grid.Column="0"
    Margin="4"
    PlaceholderText="Search..."
    x:Name="ProblemsSearchBox"
    HorizontalAlignment="Stretch"/>
<ComboBox 
    PlaceholderText="Difficulty"
    Grid.Column="1"
    Margin="4"
    ItemsSource="{x:Bind Difficulties}"
    HorizontalAlignment="Stretch"/>
<ComboBox 
    PlaceholderText="Status"
    Grid.Column="2"
    Margin="4"
    ItemsSource="{x:Bind Statuses}"
    HorizontalAlignment="Stretch"/>
<ComboBox 
    PlaceholderText="Tag"
    Grid.Column="3"
    Margin="4"
    ItemsSource="{x:Bind Tags}"
    HorizontalAlignment="Stretch"/>
<ComboBox 
    PlaceholderText="List"
    x:Name="ListComboBox"
    Grid.Column="4"
    Margin="4"
    ItemsSource="{x:Bind Lists}"
    HorizontalAlignment="Stretch"/>
<DropDownButton 
    Content="Add"
    Grid.Column="6"
    Margin="4"
    HorizontalAlignment="Stretch">
    <DropDownButton.Flyout>
        <MenuFlyout Placement="Bottom">
            <MenuFlyoutItem Text="New Problem"/>
            <MenuFlyoutItem Text="New Problem List"/>
            <MenuFlyoutItem Text="Import"/>
        </MenuFlyout>
    </DropDownButton.Flyout>
</DropDownButton>
\end{minted}

The ItemsSource of the ComboBox is binded to the corresponding variable, which allows me to set their value programmatically. Because the database is not implemented yet, I will use some dummy data to test the UI.

\begin{minted}{csharp}
using Microsoft.UI.Xaml.Controls;
using System.Collections.ObjectModel;

namespace Algorithm_Dynamics.Pages
{
    public sealed partial class ProblemsPage : Page
    {
        public ProblemsPage()
        {
            this.InitializeComponent();
        }
        private readonly ObservableCollection<string> Difficulties = new() { "Easy", "Medium", "Hard" };
        private readonly ObservableCollection<string> Statuses = new() { "Todo", "Attempted", "Done" };
        public ObservableCollection<string> Lists = new() { "List 1", "List 2", "List 3" };
        public ObservableCollection<string> Tags = new() { "Tag 1", "Tag 2", "Tag 3"};
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-Toolbar}

The toolbar shows up with all data loaded correctly. I can select an item correctly, but I cannot clear the selection. I need to empty the ComboBox when the user right clicks it. For the list ComboBox, I also need to allow the user to edit and delete an existing list, so when the user right click the list ComboBox, a menu flyout needs to show up with all options. I create a \code{ClearComboBox} procedure to handle the right click event.

\begin{minted}{csharp}
/// <summary>
/// Clear the <see cref="ComboBox"/>
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ClearComboBox(object sender, RightTappedRoutedEventArgs e)
{
    ComboBox comboBox = (ComboBox)sender;
    comboBox.SelectedIndex = -1;
}
\end{minted}

And then bind the right clicked event to the procedure.

\begin{minted}{xml}
<ComboBox
    x:Name="DifficultyComboBox"
    RightTapped="ClearComboBox"/>
<ComboBox
    x:Name="StatusComboBox"
    RightTapped="ClearComboBox"/>
<ComboBox
    x:Name="TagComboBox"
    RightTapped="ClearComboBox"/>
\end{minted}

For the list ComboBox, I need to create the layout for the menu flyout first.

\begin{minted}{xml}
<ComboBox.Resources>
    <MenuFlyout x:Name="ListMenuFlyout">
        <MenuFlyout.Items>
            <MenuFlyoutItem 
                Text="Edit"
                Icon="Edit"/>
            <MenuFlyoutItem
                Text="Delete"
                Icon="Delete"/>
            <MenuFlyoutSeparator/>
            <MenuFlyoutItem
                Text="Clear"
                Icon="Clear"
                Click="ClearComboBox"/>
        </MenuFlyout.Items>
    </MenuFlyout>
</ComboBox.Resources>
\end{minted}

There are three items in the menu, edit, delete, and clear. The edit and delete function has not been implemented yet, so they will not be handled for now. Because the clear event is sent by the menu button instead of the ComboBox, I overload the \code{ClearComboBox} procedure to handle the clear event.

\begin{minted}{csharp}
/// <summary>
/// Clear the <see cref="ListComboBox"/>
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ClearComboBox(object sender, RoutedEventArgs e)
{
    ListComboBox.SelectedIndex = -1;
}
\end{minted}

The menu flyout needs to be displayed when the list ComboBox is right clicked.

\begin{minted}{xml}
<ComboBox 
    x:Name="ListComboBox"
    RightTapped="ListComboBox_RightTapped">
\end{minted}

\begin{minted}{csharp}
/// <summary>
/// Display the <see cref="ListMenuFlyout"/> when the <see cref="ListComboBox"/> is right tapped
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ListComboBox_RightTapped(object sender, RightTappedRoutedEventArgs e)
{
    ComboBox comboBox = (ComboBox)sender;
    ListMenuFlyout.ShowAt(comboBox, e.GetPosition(comboBox));
}
\end{minted}

Now, I build and run the code again. When I right-click the difficulty, status and tag ComboBox, their content is cleared correctly. When I click the list ComboBox, the menu flyout shows up. When I click the clear option, the selected list is cleared correctly. When I right-click other ComboBoxes, the content is cleared correctly as well.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-ListComboBox-FlyoutMenu}

But there is a potential issue with the current implementation. When I right-click the list ComboBox, the menu flyout will show up even when no list is selected. Clear the box does not result in any problem because it is empty anyway, but in the future, when the edit and delete function is implemented, attempting to edit or delete an empty list will cause a problem. So I need to change the logic of the menu flyout so that it only shows up when there is something selected. I only need to modify the original function, and only show the flyout when the selected index is -1.

\begin{minted}{csharp}
private void ListComboBox_RightTapped(object sender, RightTappedRoutedEventArgs e)
{
    ComboBox comboBox = (ComboBox)sender;
    if (comboBox.SelectedIndex != -1)
    {
        ListMenuFlyout.ShowAt(comboBox, e.GetPosition(comboBox));
    }
}
\end{minted}

Now, the menu flyout does not show up when no list is selected, which fixes a potential issue in the future.

Next, I need to handle the delete and edit event for the list ComboBox. Because the actual database and data structures have not been implemented yet, I will only create the UI for these events and implement their functions later. For the edit event, the content frame should navigate to the edit page. For the delete event, a content dialog will show up to confirm the deletion. I create two procedures to handle these events.

\begin{minted}{csharp}
/// <summary>
/// Navigate to the edit ProblemList page
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
/// <exception cref="NotImplementedException"></exception>
private void EditProblemList(object sender, RoutedEventArgs e)
{
    // TODO Navigate to edit page
    throw new NotImplementedException();
}

/// <summary>
/// Show a content dialog to confirm the deletion of a ProblemList
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
/// <exception cref="NotImplementedException"></exception>
private async void DeleteProblemList(object sender, RoutedEventArgs e)
{
    ContentDialog dialog = new ContentDialog();
    dialog.Title = "Delete Problem List";
    dialog.PrimaryButtonText = "Delete";
    dialog.CloseButtonText = "Cancel";
    dialog.Content = $"Are you sure that you want to permanently delete {ListComboBox.SelectedItem}?";
    dialog.DefaultButton = ContentDialogButton.Close;
    dialog.XamlRoot = this.Content.XamlRoot;
    var result = await dialog.ShowAsync();
    if (result == ContentDialogResult.Primary)
    {
        // TODO Delete the selected problem list
        throw new NotImplementedException();
    }
}
\end{minted}

Now, when I click the delete button, a popup shows up correctly to confirm deletion.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-ContentDialog}

I then implement the problem list below the toolbar. I use a \code{ListView} to display the problem list. Similarly, I bind the data source to a variable Problems which contains a list of Problem. For each problem, its name, difficulty, status and tags are displayed.

\begin{minted}{xml}
<ListView x:Name="ProblemsListView"
    Grid.Row="1"
    SelectionMode="Extended"
    Width="auto"
    ItemsSource="{x:Bind Problems, Mode=OneWay}">
    <ListView.ItemContainerStyle>
        <Style TargetType="ListViewItem">
            <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
        </Style>
    </ListView.ItemContainerStyle>
    <ListView.ItemTemplate>
        <DataTemplate x:DataType="local:Problem">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="2*"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="2*"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <TextBlock
                    Text="{x:Bind Name}"
                    Grid.Column="0"
                    HorizontalAlignment="Left"
                    VerticalAlignment="Center"
                    Margin="4 0 0 0"/>
                <TextBlock
                    Text="{x:Bind Difficulty}"
                    Grid.Column="1"
                    HorizontalAlignment="Left"
                    VerticalAlignment="Center"
                    Margin="10 0 0 0"/>
                <TextBlock
                    Text="{x:Bind Status}"
                    Grid.Column="2"
                    HorizontalAlignment="Left"
                    VerticalAlignment="Center"
                    Margin="14 0 0 0"/>
                <TextBlock
                    Text="{x:Bind Tags}"
                    Grid.Column="3"
                    HorizontalAlignment="Left"
                    VerticalAlignment="Center"
                    TextTrimming="CharacterEllipsis"
                    Margin="17 0 0 0"/>
                <Button
                    Content="Start"
                    Grid.Column="4"
                    HorizontalAlignment="Stretch"
                    Margin="12 0 0 0"/>
            </Grid>
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>
\end{minted}

Because the data structure for Problem has not been implemented yet, I create a sample class for the Problem. It only contains the four attributes that matters and a constructor to initialize the values.

\begin{minted}{csharp}
public class Problem
{
    public Problem(string name, string difficulty, string status, string tags)
    {
        Name = name;
        Difficulty = difficulty;
        Status = status;
        Tags = tags;
    }

    public string Name { get; set; }
    public string Difficulty { get; set; }
    public string Status { get; set; }
    public string Tags { get; set; }
}
\end{minted}

I create a ObserableCollection for the list of Problem and add some sample data to it.

\begin{minted}{csharp}
public ObservableCollection<Problem> Problems = new();
public ProblemsPage()
{
    InitializeComponent();
    Problems.Add(new Problem("Problem 1", "Easy", "Todo", "Tag"));
    Problems.Add(new Problem("Problem 2", "Easy", "Attempted", "Tag"));
    Problems.Add(new Problem("Problem 3", "Easy", "Done", "Tag"));
    Problems.Add(new Problem("Problem 4", "Medium", "Todo", "Tag"));
    Problems.Add(new Problem("Problem 5", "Medium", "Attempted", "Tag"));
    Problems.Add(new Problem("Problem 6", "Medium", "Done", "Tag"));
    Problems.Add(new Problem("Problem 7", "Hard", "Todo", "Tag"));
    Problems.Add(new Problem("Problem 8", "Hard", "Attempted", "Tag"));
    Problems.Add(new Problem("Problem 9", "Hard", "Done", "Tag"));
    Problems.Add(new Problem("Problem 10", "Hard", "Todo", "Tag"));
}
\end{minted}

The problem list shows up with the correct data.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-ProblemList}

I need to add a flyout menu for the problem list to allow the user to edit and delete problems when right clicking the list. When only one problem is selected, the user can edit it or delete it. When multiple problems are selected, the user can delete all of them or create a problem list from them.

\begin{minted}{xml}
<ListView.Resources>
    <MenuFlyout x:Name="SingleSelectedMenuFlyout">
        <MenuFlyout.Items>
            <MenuFlyoutItem 
                Text="Edit"
                Icon="Edit"/>
            <MenuFlyoutItem 
                Text="Delete"
                Icon="Delete"/>
        </MenuFlyout.Items>
    </MenuFlyout>
    <MenuFlyout x:Name="MultipleSelectedMenuFlyout">
        <MenuFlyout.Items>
            <MenuFlyoutItem 
                Text="Create Problem List..."
                Icon="Add"/>
            <MenuFlyoutItem 
                Text="Delete"
                Icon="Delete"/>
        </MenuFlyout.Items>
    </MenuFlyout>
</ListView.Resources>
\end{minted}


\begin{minted}{csharp}
/// <summary>
/// Show flyout when the user right tapped the ProblemListView
/// When one problem is selected, show the SingleSelectedMenuFlyout
/// When mutiple problems are selected, show the MultipleSelectedMenuFlyout
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ProblemsListView_RightTapped(object sender, RightTappedRoutedEventArgs e)
{
    ListView listView = (ListView)sender;
    if (listView.SelectedItems.Count == 1)
    {
        SingleSelectedMenuFlyout.ShowAt(listView, e.GetPosition(listView));
    }
    else if (listView.SelectedItems.Count > 1)
    {
        MultipleSelectedMenuFlyout.ShowAt(listView, e.GetPosition(listView));
    }
}
\end{minted}

The corresponding menu flyout can show up correctly based on the selection.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-SingleSelected-Flyout}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-MultipleSelected-Flyout}

Similarly, I can add the delete content dialog for these flyouts and leave the edit and create new problem list feature in the future.

\begin{minted}{csharp}
/// <summary>
/// Edit the selected Problem
/// Navigate to the EditProblemPage
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void EditProblem(object sender, RoutedEventArgs e)
{
    // TODO Navigate to the EditProblemPage
    throw new NotImplementedException();
}

/// <summary>
/// Show a content dialog to confirm the deletion of a Problem
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
/// <exception cref="NotImplementedException"></exception>
private async void DeleteProblem(object sender, RoutedEventArgs e)
{
    ContentDialog dialog = new ContentDialog();
    dialog.Title = "Delete Problem";
    dialog.PrimaryButtonText = "Delete";
    dialog.CloseButtonText = "Cancel";
    dialog.Content = $"Are you sure that you want to permanently delete {(ProblemsListView.SelectedItem as Problem).Name}?";
    dialog.DefaultButton = ContentDialogButton.Close;
    dialog.XamlRoot = this.Content.XamlRoot;
    var result = await dialog.ShowAsync();
    if (result == ContentDialogResult.Primary)
    {
        // TODO Delete the selected problem
        throw new NotImplementedException();
    }
}

/// <summary>
/// Create a new ProblemList from multiple selected items
/// Navigate to the CreateProblemListPage
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
/// <exception cref="NotImplementedException"></exception>
private void CreateProblemList(object sender, RoutedEventArgs e)
{
    // TODO Navigate to the CreateProblemList
    throw new NotImplementedException();
}

/// <summary>
/// Show a content dialog to confirm the deletion of Problems
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
/// <exception cref="NotImplementedException"></exception>
private async void DeleteProblems(object sender, RoutedEventArgs e)
{
    ContentDialog dialog = new ContentDialog();
    dialog.Title = "Delete Problem";
    dialog.PrimaryButtonText = "Delete";
    dialog.CloseButtonText = "Cancel";
    dialog.Content = $"Are you sure that you want to permanently delete these {ProblemsListView.SelectedItems.Count} Problems?";
    dialog.DefaultButton = ContentDialogButton.Close;
    dialog.XamlRoot = this.Content.XamlRoot;
    var result = await dialog.ShowAsync();
    if (result == ContentDialogResult.Primary)
    {
        // TODO Delete the selected problems
        throw new NotImplementedException();
    }
}
\end{minted}

Finally, for the ProblemsPage, I need to handle the searh query. The ProblemListView needs to be updated when different search queries are entered in the toolbar. I create a \code{Search} procedure to handle the searc event. When the user select an option in the ComboBoxes, or enter the search box, the \code{Search} procedure will be called. All data will be passed to a \code{Query} function that returns searching result. For now, because the database is not implemented, I will just return the query. The \code{Query} function will be implemented in the future.

\begin{minted}{csharp}
/// <summary>
/// Search the problem lists that under conditions
/// </summary>
/// <param name="sender"></param>
/// <param name="args"></param>
private void Search(object sender, object args)
{
    var keywords = ProblemsSearchBox.Text;
    var difficulty = DifficultyComboBox.SelectedValue?.ToString();
    var status = StatusComboBox.SelectedValue?.ToString();
    var tag = TagComboBox.SelectedValue?.ToString();
    var list = ListComboBox.SelectedValue?.ToString();
    // TODO Query(keywords, difficulty, status, tag, list);
    Problems.Clear();
    Problems.Add(new Problem(keywords, difficulty, status, tag));
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-Search}

The correct search result is returned and the search result is updated correctly when different search conditions are selected.

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Test & Result & Remark \\
    \hline
    Does it load & Pass & \\
    \hline
    Does the toolbar display correctly & Pass & \\
    \hline
    Does the toolbar interact correctly & Pass & \\
    \hline
    Does the toolbar return the correct search result & Failed & The search algorithm will be implemented after the database and data structure is ready in the future milestones. \\
    \hline
    Does the add button work & Failed & The data import and create new problem function will be implemented after the CreateNewProblemPage and the data import function is implemented. \\
    \hline
    Does the problem list show up correct & Pass & \\
    \hline
    Does the start button work & Failed & The start button will be implemented after the coding page is implemented. \\
    \hline
    Does the selection and menu flyout work & Failed & The delete and edit button will be implemented after the database is ready. \\
    \hline
\end{tabulary}

The ProblemsPage is partially implemented with many todos left for the future. But in this iteration, it is good to go as all UI elements are ready. I will move on to the PlaygroundPage and CodingPage next.

\subsection{Create the PlaygroundPage}

\subsubsection{Implementation}

The main component in the PlaygroundPage is the Code Editor. Because the CodingPage will need to use the Code Editor as well, so I will set the Code Editor as a custom control so it can be reused later.

The Code Editor needs to support line number, syntax highlighting, and other editing features. It is too complex for this project to implement all of these by hand. So I will use a third-party library to achieve that. I am using the \href{https://microsoft.github.io/monaco-editor/}{Monaco Editor} for this purpose.

I create a custom control for the editor so I can reuse it later in different pages easily.

\begin{minted}{xml}
<UserControl
    x:Class="Algorithm_Dynamics.Controls.CodeEditor"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Algorithm_Dynamics.Controls"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d">

    <TextBlock Text="CodeEditor"/>
</UserControl>
\end{minted}

\begin{minted}{csharp}
using Microsoft.UI.Xaml.Controls;

namespace Algorithm_Dynamics.Controls
{
    public sealed partial class CodeEditor : UserControl
    {
        public CodeEditor()
        {
            InitializeComponent();
        }
    }
}
\end{minted}

I import the control in the PlaygroundPage to verify its working.

\begin{minted}{xml}
<Page
    x:Class="Algorithm_Dynamics.Pages.PlaygroundPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Algorithm_Dynamics.Pages"
    xmlns:controls="using:Algorithm_Dynamics.Controls"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Grid>
        <controls:CodeEditor/>
    </Grid>
</Page>
\end{minted}

Now, when I run the application and navigate to the PlaygroundPage I can see the Code Editor is displayed correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodeEditorControl}

The Monaco Editor is a web application, which means it needs to run in a browser. To use it, I need to use WebView2 component to load a HTML file, and initialize the Monaco Editor inside that webpage. The WebView2 control launches a Chromium instance and allows me to integrate webpages inside my app. I use the WebView2 control to load the HTML file. Before I create the webpage for the Monaco Editor, I place the WebView2 control and test it out.

\begin{minted}{xml}
<WebView2 
    x:Name="WebView"
    HorizontalAlignment="Stretch"
    VerticalAlignment="Stretch"
    Source="https://ocr.org.uk"/>
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-WebView2-Webpage}

I set the source of the WebView2 control to the offcial website of OCR, and it loads up correctly. Now I can start working on the webpage for the editor. To load a local HTML file, I need to set a mapping relationship between a URL space and a local folder.

\begin{minted}{csharp}
/// <summary>
/// Initialize the WebView control and load Editor.html
/// </summary>
async void InitializeWebViewAsync()
{
    // Ensure the CoreWebView2 is loaded
    await WebView.EnsureCoreWebView2Async();

    // Set the mapping
    StorageFolder AssetsDirectory = await Package.Current.InstalledLocation.GetFolderAsync(@"Assets");
    WebView.CoreWebView2.SetVirtualHostNameToFolderMapping(
        "localeditor.algorithmdynamics.com",
        AssetsDirectory.Path,
        CoreWebView2HostResourceAccessKind.Allow
    );

    // Load Editor.html
    WebView.Source = new Uri("http://localeditor.algorithmdynamics.com/Editor.html");
}
\end{minted}

Now I can load Editor.html under the Assets folder. I use a sample HTML file to test it out.

\begin{minted}{html}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Hello Editor!</h1>
</body>
</html>
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-WebView2-HelloEditor}

The h1 title ``Hello Editor!'' is displayed correctly, which means the local file is loaded as expected. Now I can import the Monaco Editor to the WebView2 control.

\begin{minted}{html}
<body>
    <div id="container" style="width:800px;height:600px;border:1px solid grey"></div>

    <script src="monaco-editor/min/vs/loader.js"></script>
    <script>
        require.config({ paths: { vs: 'monaco-editor/min/vs' } });
        require(['vs/editor/editor.main'], () => {
            window.editor = monaco.editor.create(document.getElementById('container'), {
                value: ['function x() {', '\tconsole.log("Hello Editor!");', '}'].join('\n'),
                language: 'javascript'
            });
        });
    </script>
</body>
\end{minted}

I add a container in the body to host the instance of the editor. Then I write some JavaScript code to import the editor and initialize it with a sample code.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-WebView2-EditorLoaded}

The editor is now loaded correctly with the sample code. I can type in the editor and utlize all powerful functions of the Monaco Editor.

But I find that the editor has a fixed height and width. On a small screen like the screen shot, you can see the scroll bars. And on a larger display, the editor will not occupy the entire screen. I need to adjust its style to make it responsive.

I add some CSS code to set the height and width of the editor to 100\%.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-WebView2-ResizeFailed}

Now, the scroll bars are gone. But when I resize the window, the editor still does not follow the window size. After reading the documentation of the Monaco Editor, I find out that I need to manually call the \code{editor.layout()} function to recalculate the editor size.

\begin{minted}{html}
<script>
    window.addEventListener("resize", () => editor.layout());
</script>
\end{minted}

By adding the event handler for the window resize event and call the layout function, the editor can now resize correctly according to the window size.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-WebView2-ResizeSuccess}

Before I go any further, I need to first implement the PlaygroundPage, so I have a working environment to test the editor out.

\begin{minted}{xml}
<Page
    x:Class="Algorithm_Dynamics.Pages.PlaygroundPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Algorithm_Dynamics.Controls"
    xmlns:controls="using:CommunityToolkit.WinUI.UI.Controls"

    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="auto"/>
        </Grid.RowDefinitions>

        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <!-- ... -->
    </Grid> 
</Page>
\end{minted}

I will use a grid with 3 rows and 2 columns to hold all controls.

\begin{minted}{xml}
<local:CodeEditor
    x:Name="CodeEditor"
    Grid.Row="0"
    Grid.Column="0"
    Grid.RowSpan="2"
    Margin="0 0 8 0"/>

<TextBox
    x:Name="OutputBox"
    Grid.Row="0"
    Grid.Column="1"
    Margin="8 0 0 8"
    PlaceholderText="Output"
    IsSpellCheckEnabled="False"
    AcceptsReturn="True"/>

<TextBox
    x:Name="InputBox"
    Grid.Row="1"
    Grid.Column="1"
    Margin="8 8 0 0"
    PlaceholderText="Input"
    IsSpellCheckEnabled="False"
    AcceptsReturn="True"/>

<Grid
    Grid.Row="2"
    Grid.Column="0">
    <ComboBox
        x:Name="LanguageComboBox"
        SelectedIndex="0"
        VerticalAlignment="Stretch">
        <x:String>Python</x:String>
        <x:String>C</x:String>
        <x:String>C++</x:String>
    </ComboBox>
</Grid>

<Grid
    Grid.Row="2"
    Grid.Column="1"
    Margin="8 0 0 0">
    <Grid.RowDefinitions>
        <RowDefinition Height="auto"/>
        <RowDefinition Height="*"/>
    </Grid.RowDefinitions>
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*"/>
        <ColumnDefinition Width="*"/>
    </Grid.ColumnDefinitions>
    <ProgressBar
        Grid.Row="0"
        Grid.Column="0"
        Grid.ColumnSpan="2"
        HorizontalAlignment="Stretch"
        VerticalAlignment="Stretch"
        IsIndeterminate="True"
        ShowPaused="False"
        ShowError="False" />
    <TextBlock
        x:Name="StatusTextBlock"
        Grid.Row="1"
        Grid.Column="0"
        HorizontalAlignment="Left"
        VerticalAlignment="Center"
        Text="Pending"/>
    <Button
        x:Name="RunCodeButton"
        Grid.Row="1"
        Grid.Column="1"
        HorizontalAlignment="Right"
        VerticalAlignment="Stretch"
        Content="Run Code"
        Click="RunCodeButton_Click"/>
</Grid>
\end{minted}

To allow different sections to be resizeable, I add two grid splitters to the grid.

\begin{minted}{xml}
<controls:GridSplitter
    HorizontalAlignment="Left"
    Grid.Column="1"
    Grid.RowSpan="2"
    Width="16">
    <controls:GridSplitter.RenderTransform>
        <TranslateTransform X="-8" />
    </controls:GridSplitter.RenderTransform>
</controls:GridSplitter>

<controls:GridSplitter
    VerticalAlignment="Top"
    Grid.Row="1"
    Grid.Column="1"
    Grid.ColumnSpan="1"
    Margin="8 0 0 0"
    Height="16">
    <controls:GridSplitter.RenderTransform>
        <TranslateTransform Y="-8"/>
    </controls:GridSplitter.RenderTransform>
</controls:GridSplitter>
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-Layout}

All controls work correctly and they can be resized by the grid splitter. Now I need to interact with the code editer. I need to be able to get the code inside, set its programming language and color theme. To pass the config data to the editor, I will need to serialize the data into a JSON string and send it through web message. To avoid hand crafting the JSON string, I create a new class \code{EditorConfig} and use the \code{System.Text.Json} library to serialize the data.

\begin{minted}{csharp}
public class EditorConfig
{
    public EditorConfig(string theme, string language, string code)
    {
        Theme = theme;
        Language = language;
        Code = code;
    }
    public string? Theme { get; set; } = null;
    public string? Language { get; set; } = null;
    public string? Code { get; set; } = null;
}
\end{minted}

I then create a helper function to send the config data to the editor. It takes in an instance of the EditorConfig and serializes it into a JSON string, then send it through a web message. And for the testing purpose, I send the message when initializing the editor.

\begin{minted}{csharp}
/// <summary>
/// Update the editor config of the Monaco Editor
/// </summary>
/// <param name="editorConfig"></param>
private void UpdateEditorConfig(EditorConfig editorConfig)
{
    WebView.CoreWebView2.PostWebMessageAsJson(JsonSerializer.Serialize(editorConfig));
}


async void InitializeWebViewAsync()
{
    // ...
    UpdateEditorConfig(new EditorConfig("vs-dark", "python", "print(1)"));
}
\end{minted}

On the web end, I need to listen to the web message and process the data received.

\begin{minted}{javascript}
// Receive and set theme/language/code
window.chrome.webview.addEventListener('message', (e) => {
    console.log(e)
    let data = e.data
    if (data.Theme) monaco.editor.setTheme(data.Theme)
    if (data.Language) monaco.editor.setModelLanguage(window.editor.getModel(), data.Language)
    if (data.Code) window.editor.getModel().setValue(data.Code)
})
\end{minted}

Now, when I open the PlaygroundPage, a code editor with dark theme and syntax highlighting for Python should be loaded.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-EditorConfig-NotLoading}

However, it is clearly not loading. Neither the theme, the syntax highlighting nor the code is set. It is clear that the config has not been passed correctly. When I open the devtool, nothing is in the output, which means that \code{console.log(e)} has not been called.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-EditorConfig-NotLoading-Devtool}

I suspect this is caused by the fact that at the time the web message is sent, the Monaco Editor is not fully loaded, therefore it has not started listening for the message. To test my hypothesis, instead of sending a message, I will inject a JavaScript script to pass the value through the global window object.

\begin{minted}{csharp}
async void InitializeWebViewAsync()
{
    // ...
    var editorConfig = new EditorConfig("vs-dark", "python", "print(1)");
    await WebView.ExecuteScriptAsync($"window.config={JsonSerializer.Serialize(editorConfig)}");
}
\end{minted}

And on the web end, I initialize the editor with the config data.

\begin{minted}{javascript}
window.editor = monaco.editor.create(document.getElementById('container'), {
    value: window.config?.Code,
    language: window.config?.Language,
    theme: window.config?.Theme
})
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-EditorConfig-Loading}

Now the theme, code, and language config is passed correctly, which also proves my hypothesis is correct. This problem should only occur at the initializing stage. Once the editor is loaded, passing config through web message should work fine.

In order to allow other pages to set the config, I need to expose these three fields by registering them as properties.

\begin{minted}{csharp}
/// <summary>
/// Return the editor theme based on current requested theme
/// </summary>
/// <param name="theme"></param>
/// <returns></returns>
private static string GetTheme(ElementTheme theme)
{
    if (theme == ElementTheme.Dark) return "vs-dark";
    else if (theme == ElementTheme.Light) return "vs";
    return "vs";
}
public string Code
{
    get { return (string)GetValue(CodeProperty); }
    set { SetValue(CodeProperty, value); }
}

public static readonly DependencyProperty CodeProperty =
    DependencyProperty.Register(
        "Code",
        typeof(string),
        typeof(CodeEditor),
        new PropertyMetadata("")
    );

public string Lang
{
    get { return (string)GetValue(LangProperty); }
    set 
    {
        UpdateEditorConfig(new EditorConfig(null, value, null));
        SetValue(LangProperty, value);
    }
}

public static readonly DependencyProperty LangProperty =
    DependencyProperty.Register(
        "Lang",
        typeof(string),
        typeof(CodeEditor),
        new PropertyMetadata("")
    );

public new ElementTheme RequestedTheme
{
    get { return base.RequestedTheme; }
    set
    {
        UpdateEditorConfig(new EditorConfig(GetTheme(value), null, null));
        base.RequestedTheme = value;
    }
}
\end{minted}

Note that \code{UpdateEditorConfig} is called when the language or the requested theme is changed to update the settings. To convert the theme code used in my app into the format of the Monaco Editor, I create a custom helper \code{GetTheme} to do the conversion. And I update the initializing process to use the value from these variables.

\begin{minted}{csharp}
async void InitializeWebViewAsync()
{
    // ...
    var editorConfig = new EditorConfig(GetTheme(RequestedTheme), Lang, Code);
    await WebView.ExecuteScriptAsync($"window.config={JsonSerializer.Serialize(editorConfig)}");
}
\end{minted}

Now, in the PlaygroundPage, I can use the CodeEditor in this way.

\begin{minted}{xml}
<local:CodeEditor
    x:Name="CodeEditor"
    Grid.Row="0"
    Grid.Column="0"
    Grid.RowSpan="2"
    Margin="0 0 8 0"
    Code="hello world!"
    Lang="cpp"
    RequestedTheme="Dark"/>
\end{minted}

Now when I run the app, it should work just like before, but this time with its config exposed and set by the PlaygroundPage. However, I encounter the following exception.

\begin{minted}{text}
System.NullReferenceException
  HResult=0x80004003
  Message=Object reference not set to an instance of an object.
  Source=Algorithm Dynamics
  StackTrace:
   at Algorithm_Dynamics.Controls.CodeEditor.UpdateEditorConfig(EditorConfig editorConfig) in C:\Algorithm-Dynamics\src\Algorithm Dynamics\Controls\CodeEditor.xaml.cs:line 74
\end{minted}

The exception is caused by the \code{UpdateEditorConfig}. And after searching the documentation of the WebView2, the \code{WebView.CoreWebView2} object will be null before it is fully initialized. I can not use the \code{EnsureCoreWebView2Async} method before to ensure it is loaded because it is an async function while \code{UpdateEditorConfig} needs to be called in the setter. So I decide to ignore the null object because it only exists in the initializing stage, and I have passed the config through the global window object anyway.

\begin{minted}{csharp}
private void UpdateEditorConfig(EditorConfig editorConfig)
{
    WebView.CoreWebView2?.PostWebMessageAsJson(JsonSerializer.Serialize(editorConfig));
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-EditorConfig-Exposed}

Now when I run the app, it works correctly again.

I can pass config to the Monaco Editor now, but I also need to be able to retrieve the code input from the editor. To do this, I add an event listener to the editor, and post a web message when the code is changed.

\begin{minted}{javascript}
// Send code when the code is changed
window.editor.getModel().onDidChangeContent((e) => window.chrome.webview.postMessage(window.editor.getValue()))
\end{minted}

And on the app end, when I receive a new web message, I update the internal Code variable.

\begin{minted}{csharp}
/// <summary>
/// Update the Code when receive the value send by the Monaco Editor
/// </summary>
/// <param name="sender"></param>
/// <param name="args"></param>
private void CoreWebView2_WebMessageReceived(CoreWebView2 sender, CoreWebView2WebMessageReceivedEventArgs args)
{
    string data = args.TryGetWebMessageAsString();
    Code = data;
}

async void InitializeWebViewAsync()
{
    // ...
    WebView.CoreWebView2.WebMessageReceived += CoreWebView2_WebMessageReceived;
    // ...
}
\end{minted}

To test it is working, I bind the output box on the PlaygroundPage to CodeEditor.Code variable. When I type in the code editor, I should see the code in the output box updated with my typing.

\begin{minted}{xml}
<TextBox
    x:Name="OutputBox"
    Grid.Row="0"
    Grid.Column="1"
    Margin="8 0 0 8"
    PlaceholderText="Output"
    IsSpellCheckEnabled="False"
    AcceptsReturn="True"
    Text="{x:Bind CodeEditor.Code, Mode=OneWay}"/>
\end{minted}

When I run the app and start typing in the code editor, the output panel updates as expected, which means I have retrieved the code from the Monaco Editor successfully.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-Editor-CodeSync}

I am not able to implement the full function of the PlaygroundPage right now since the Judger has not been implemented yet. But there is one last thing, I need to make the language ComboBox working. When the user selects a different programming, the syntax highlighting should adjust accordingly. This should be very easy to do since I have already implemented the config updaing function.

I add a new event handler to process the selection change event.

\begin{minted}{xml}
<ComboBox
    x:Name="LanguageComboBox"
    SelectedIndex="0"
    VerticalAlignment="Stretch"
    SelectionChanged="LanguageComboBox_SelectionChanged">
    <x:String>python</x:String>
    <x:String>c</x:String>
    <x:String>cpp</x:String>
    <x:String>javascript</x:String>
</ComboBox>
\end{minted}

And when I update the Lang variable, everything should just work.

\begin{minted}{csharp}
private void LanguageComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
{
    CodeEditor.Lang = LanguageComboBox.SelectedItem.ToString();
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-Editor-SyntaxHighlighting-Python}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-Editor-SyntaxHighlighting-Cpp}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-Editor-SyntaxHighlighting-JavaScript}

And it turns out to work perfectly as I expected. I can change the syntax highlighting in runtime smoothly.

I have finished the PlaygroundPage in this iteration. I will move on to the CodingPage next, which should be relatively simple because I have encapsulated the code editor into a user control and it can be easily reused.

Just before I plan to start the CodingPage, I find another bug with the Editor control. When the user navigate from the PlaygroundPage to another page, and then navigate back, the editor config cannot be loaded correctly. After some more research, it turns out that the WebView2 component is not destroyed after the page is unloaded, so when the next time it is loaded, it initialize much faster and load before \code{window.config} is set. I decide to design a three-way handshake protocol to solve this problem once and for all.

\includegraphics[width=\linewidth]{webviewHandshake}

At first, the WebView starts loading, and sends a message to request the initial configuration for the Monaco Editor when it is ready. The CodeEditor will keep listening until it receives the request. Then it will send the request and starts listening again. When the Monaco Editor is fully loaded, another message is sent to tell the CodeEditor it is ready. Then the initialization procedure is completed.

\begin{minted}{javascript}
require.config({ paths: { vs: 'monaco-editor/min/vs' } })
require(['vs/editor/editor.main'], () => {
    window.chrome.webview.postMessage('[Status] Request Configuration')
    window.chrome.webview.addEventListener('message', init)
})
function init() {
    // Remove the event listener
    window.chrome.webview.removeEventListener('message', init)
    // Initialize the code editor
    window.editor = monaco.editor.create(document.getElementById('container'), {
        value: window.config.Code,
        language: window.config.Language,
        theme: window.config.Theme
    })
    // Process resize event
    window.addEventListener("resize", () => window.editor.layout())
    // Send code when the code is changed
    window.editor.getModel().onDidChangeContent((e) => 
        window.chrome.webview.postMessage('[Data] ' + window.editor.getValue()))
    // Receive and set theme/language/code
    window.chrome.webview.addEventListener('message', (e) => {
        let data = e.data
        if (data.Theme) monaco.editor.setTheme(data.Theme)
        if (data.Language) monaco.editor.setModelLanguage(window.editor.getModel(), data.Language)
        if (data.Code) window.editor.getModel().setValue(data.Code)
    })
    // Ready
    window.chrome.webview.postMessage('[Status] Ready')
}
\end{minted}

For the CodeEditor control, I add a progress ring to display when it is going through the initilazation process.

\begin{minted}{xml}
<Grid>
    <WebView2 
        x:Name="WebView"
        HorizontalAlignment="Stretch"
        VerticalAlignment="Stretch"
        Visibility="Collapsed"/>
    <ProgressRing
        x:Name="ProgressRing"
        IsActive="True"
        HorizontalAlignment="Center"
        VerticalAlignment="Center"
        Visibility="Visible"/>
</Grid>
\end{minted}

\begin{minted}{csharp}
/// <summary>
/// Process the initialization process
/// Update the Code when receive the value send by the Monaco Editor
/// </summary>
/// <param name="sender"></param>
/// <param name="args"></param>
private async void CoreWebView2_WebMessageReceived(CoreWebView2 sender, CoreWebView2WebMessageReceivedEventArgs args)
{
    string data = args.TryGetWebMessageAsString();
    if (data == "[Status] Request Configuration")
    {
        EditorConfig editorConfig = new (GetTheme(RequestedTheme), Lang, Code);
        await WebView.ExecuteScriptAsync($"window.config={JsonSerializer.Serialize(editorConfig)}");
        WebView.CoreWebView2.PostWebMessageAsString("Configuration Sent");
    }
    else if (data == "[Status] Ready")
    {
        ProgressRing.Visibility = Visibility.Collapsed;
        WebView.Visibility = Visibility.Visible;
    } 
    else
    {
        // [Data] actual code
        Code = data.Substring("[Data] ".Length, data.Length - "[Data] ".Length);
        return;
    }
}
\end{minted}

Now, it is ok to navigate around different pages, and the editor will always be initialized correctly.

After testing the PlaygroundPage for a longer time, I find another issue. The memory usage of the app keep increasing each time when I navigate to and away from the PlaygroundPage. The memory garbage collection does not seem to work as expected. I suspect that is caused by the WebView2 control not being destroyed correctly. To verify my hypothesis, I use the Porcess Explorer \cite{microsoft:docs:process-explorer} to examine the process tree of the app.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{Process-Explorer-WebView2}

As I expected, the WebView2 process is created not destroyed when I navigate away from the PlaygroundPage. And each time a new instance is create, which is causing the memory leak. After some researching on the lifecycle of the WebView2 component \cite{github:microsoft-ui-xaml:4752}, I found that I can call \code{WebView2.Close()} to manually dispose it. So I add a new procedure to handle the control unload event.

\begin{minted}{csharp}
private void CodeEditor_Unloaded(object sender, RoutedEventArgs e)
{
    // Close the WebView when unloaded
    // https://github.com/microsoft/microsoft-ui-xaml/issues/4752
    WebView.Close();
}
\end{minted}

Now, when I navigate away from the PlaygroundPage, I can see from the Process Explorer that all WebView2 processes are killed. And the memory usage fall back to the initial state correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{Process-Explorer-WebView2-Destroyed}

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Test & Result & Remark \\
    \hline
    Does it load & Pass & \\
    \hline
    Can each section be resized correctly & Pass & \\
    \hline
    Does the CodeEditor work correctly & Pass & \\
    \hline
    Does the language ComboBox work correctly & Pass & \\
    \hline
    Does the input output box work correctly & Pass & \\
    \hline
    Does the Run Code button work & Failed & The Run Code function will be implemented after the Judger is ready. \\
    \hline
    Is the CodeEditor unloaded correctly on close & Pass & \\
    \hline
\end{tabulary}

\subsection{Create the CodingPage}

\subsubsection{Implementation}

I use a grid with 4 rows and 2 columns to organize all elements in the CodingPage.

\begin{minted}{xml}
<Page
    x:Class="Algorithm_Dynamics.Pages.CodingPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Algorithm_Dynamics.Controls"
    xmlns:controls="using:CommunityToolkit.WinUI.UI.Controls"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="auto"/>
            <RowDefinition Height="2*"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="auto"/>
        </Grid.RowDefinitions>

        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <!-- ...  -->
</Page>
\end{minted}

I put a pivot on the top left, which holds two components, the MarkdownTextBlock for the description of the problem and the submission grid. The user can switch between them by clicking the pivot header.

\begin{minted}{xml}
<Pivot
    Grid.Row="0"
    Grid.RowSpan="3"
    Grid.Column="0"
    Margin="0 0 8 0">
    <PivotItem Header="Problem">
        <ScrollViewer
            HorizontalScrollBarVisibility="Disabled"
            VerticalScrollBarVisibility="Auto">
            <controls:MarkdownTextBlock
                x:Name="ProblemMarkdownTextBlock"
                Margin="8"
                Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"
                Text="{x:Bind CodeEditor.Code, Mode=OneWay}"/>
        </ScrollViewer>
    </PivotItem>
    <PivotItem Header="Submissions">
        <controls:DataGrid
            x:Name="SubmissionsDataGrid"
            AutoGenerateColumns="True"
            ItemsSource="{x:Bind Submissions, Mode=OneWay}">
        </controls:DataGrid>
    </PivotItem>
</Pivot>
\end{minted}

I place the language selection box and the fullscreen button on the top right.

\begin{minted}{xml}
<Grid
    Grid.Row="0"
    Grid.Column="1"
    Margin="8">
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*"/>
        <ColumnDefinition Width="*"/>
    </Grid.ColumnDefinitions>
    <ComboBox
        Grid.Column="0"
        x:Name="LanguageComboBox"
        SelectedIndex="0"
        VerticalAlignment="Stretch"
        SelectionChanged="LanguageComboBox_SelectionChanged">
        <x:String>python</x:String>
        <x:String>c</x:String>
        <x:String>cpp</x:String>
        <x:String>javascript</x:String>
    </ComboBox>
    <Button
        x:Name="FullScreenButton"
        Grid.Column="1"
        HorizontalAlignment="Right"
        Click="FullScreenButton_Click"
        ToolTipService.ToolTip="Fullscreen (F11)">
        <FontIcon
            x:Name="FullScreenIcon"
            FontFamily="Segoe Fluent Icons"
            Glyph="&#xE740;"/>
        <Button.KeyboardAccelerators>
            <KeyboardAccelerator Key="F11"/>
        </Button.KeyboardAccelerators>
    </Button>
</Grid>
\end{minted}

On the button right, I place the code editor and  Input/Output/Error panel inside another pivot so the user can navigate between them. Because the code editor has been encapsulated as a user control before, I can easily import it here.

\begin{minted}{xml}
<local:CodeEditor
    x:Name="CodeEditor"
    Grid.Column="1"
    Grid.Row="1"
    Margin="8 0 0 8"/>
<Pivot
    Grid.Row="2"
    Grid.Column="1"
    Margin="8 8 0 0">
    <PivotItem Header="Input">
        <TextBox
            x:Name="InputTextBox"
            x:FieldModifier="public"
            PlaceholderText="Input Panel"
            AcceptsReturn="True"/>
    </PivotItem>
    <PivotItem Header="Output">
        <TextBox
            x:Name="OutputTextBox"
            x:FieldModifier="public"
            PlaceholderText="Output Panel"
            AcceptsReturn="True"/>
    </PivotItem>
    <PivotItem Header="Error">
        <TextBox
            x:Name="ErrorTextBox"
            x:FieldModifier="public"
            PlaceholderText="Error Panel"
            AcceptsReturn="True"/>
    </PivotItem>
</Pivot>
\end{minted}

At the bottom, I place the problem navigation buttons, the status text block, a progress bar and the run code and submission button.

\begin{minted}{xml}
<Grid
    Grid.Row="3"
    Grid.Column="1">
    <Grid.RowDefinitions>
        <RowDefinition Height="auto"/>
        <RowDefinition Height="*"/>
    </Grid.RowDefinitions>
    
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*"/>
        <ColumnDefinition Width="auto"/>
        <ColumnDefinition Width="auto"/>
    </Grid.ColumnDefinitions>

    <ProgressBar
        Grid.Row="0"
        Grid.Column="0"
        Grid.ColumnSpan="3"
        IsIndeterminate="True"
        ShowPaused="False"
        ShowError="False"/>
    <TextBlock
        Grid.Row="1"
        Grid.Column="0"
        Text="Status"
        VerticalAlignment="Center"/>
    <Button
        Grid.Row="1"
        Grid.Column="2"
        x:Name="SubmitCodeButton"
        Content="Submit"
        Style="{StaticResource AccentButtonStyle}"/>
    <Button
        Grid.Row="1"
        Grid.Column="1"
        Content="Run Code"/>
</Grid>

<Grid
    Grid.Row="3"
    Grid.Column="0">
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="auto"/>
        <ColumnDefinition Width="auto"/>
        <ColumnDefinition Width="auto"/>
    </Grid.ColumnDefinitions>
    <Button
        Grid.Column="0"
        VerticalAlignment="Stretch">
        <Button.Content>
            <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE76B;"/>
        </Button.Content>
    </Button>
    <DropDownButton
        Grid.Column="1"
        Content="Problem 0"
        VerticalAlignment="Stretch">
        <DropDownButton.Flyout>
            <MenuFlyout Placement="Top">
                <MenuFlyoutItem Text="Problem 1"/>
                <MenuFlyoutItem Text="Problem 2"/>
                <MenuFlyoutItem Text="Problem 3"/>
            </MenuFlyout>
        </DropDownButton.Flyout>

    </DropDownButton>
    <Button
        Grid.Column="2"
        VerticalAlignment="Stretch">
        <Button.Content>
            <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE76C;"/>
        </Button.Content>
    </Button>
</Grid>
\end{minted}

At the end, I add two grid splitters between the problem panel and the editor, the editor and the panel so users can resize each window to fit their needs.

When I build and run the app, I encounter a problem - I cannot navigate to the CodingPage. Unlike the previous pages, the CodingPage is not a top-level page, it is opened when the user select a problem or an assignment. So I need to link the start problem button to the CodingPage. So for the Start button on the ProblemsPage, I add a StartProblem function to handle the click event.

\begin{minted}{xml}
<Button
    Content="Start"
    Grid.Column="4"
    HorizontalAlignment="Stretch"
    Margin="12 0 0 0"
    Click="StartProblem"/>
\end{minted}

\begin{minted}{csharp}
/// <summary>
/// Navigate to the CodingPage, pass the current Problem and ProblemList
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void StartProblem(object sender, RoutedEventArgs e)
{
    App app = (App)Application.Current;
    // TODO pass the selected problem to the CodingPage
    app.ContentFrame.Navigate(typeof(CodingPage));
    app.MainNavView.SelectedItem = null;
}
\end{minted}

The function should also pass the selected problem and the problem list through the Navigate function. But since the data structure is not implemented, for now, it just navigates to the page without passing any data.

Now when I run the app, I can navigate to the CodingPage through the ProblemsPage and see all the layout I defined before.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-Layout}

When I provide the screenshot to my stakeholder PCloud, he says that the controls are quite ugly, especially the pivot and the grid splitter, the font and color theme does not seem to match the overall design. I agree with him, so I decide to add some style to the pivot and the grid splitter.

I create a new file Generic.xaml to store all the styles. In App.xaml, I import the Generic.xaml file.

\begin{minted}{xml}
<Application.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <XamlControlsResources xmlns="using:Microsoft.UI.Xaml.Controls" />
            <ResourceDictionary Source="/Themes/Generic.xaml"/>
            <!-- Other merged dictionaries here -->
        </ResourceDictionary.MergedDictionaries>
        <!-- Other app resources here -->
    </ResourceDictionary>
</Application.Resources>
\end{minted}

For the GridSplitter, I reference the design in DevToys\cite{github:DevToys:Generic.xaml} by setting the background color to transparent which makes the GridSplitter less significant.

For the Pivot, I reference the design from the Windows Calculator\cite{github:calculator:Calculator.xaml}, which modifies the Pivot to make it look like the modern NavigationView.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-Theme}

After applying the custom theme, the interface looks much more modern and consistent.

Next I will implement the full screen button. It will be a toggle, when clicking in the window mode, it set the window to full screen. When clicking in the full screen mode, it sets the window back to a window. I also assigned a keyboard accelerator F11 to the button, so the user can toggle it by keyboard.

\begin{minted}{xml}
<Button
    x:Name="FullScreenButton"
    Grid.Column="1"
    HorizontalAlignment="Right"
    Click="FullScreenButton_Click"
    ToolTipService.ToolTip="Fullscreen (F11)">
    <FontIcon
        x:Name="FullScreenIcon"
        FontFamily="Segoe Fluent Icons"
        Glyph="&#xE740;"/>
    <Button.KeyboardAccelerators>
        <KeyboardAccelerator Key="F11"/>
    </Button.KeyboardAccelerators>
</Button>
\end{minted}

In the \code{FullScreenButton_Click} function, I implement the logic of the toggle button. It sets the \code{AppWindowPresent} property\cite{microsoft:docs:windowing-overview} to the opposite value and assign the correct icon\cite{microsoft:docs:segoe-fluent-icons-font}.

\begin{minted}{csharp}
/// <summary>
/// Toggle the fullscreen mode for the app
/// Toggle the <see cref="AppWindowPresenterKind"/> and <see cref="FullScreenIcon.Glyph"/>
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void FullScreenButton_Click(object sender, RoutedEventArgs e)
{
    AppWindow window = MainWindow.AppWindow;
    if (window.Presenter.Kind == AppWindowPresenterKind.Overlapped)
    {
        window.SetPresenter(AppWindowPresenterKind.FullScreen);
        FullScreenIcon.Glyph = "\xE73F";
    }
    else
    {
        window.SetPresenter(AppWindowPresenterKind.Overlapped);
        FullScreenIcon.Glyph = "\xE740";
    }
}
\end{minted}

Now when I click the button, it does go into the fullscreen mode with the correct button icon set. But I notice that the system taskbar is blank instead of filled with the app window. After doing some research, it turns out that this is caused by an internal bug of the WindowsAppSDK\cite{github:WindowsAppSDK:1853} and I cannot fix it on my side. I will just leave it like this until a new version of the SDK is released.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-FullScreen-Bug.png}

For the other parts, the submission records depend on the database, and the run code and submit function depends on the Judger, so in this iteration, I will leave the page like this.

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Test & Result & Remark \\
    \hline
    Does it load & Failed & This feature is not fully implemented. When the CodingPage loads, it should take in two parameter, the current problem and a problem list for navigation. The main page can load correctly, but the support for these two parameters are not yet implemented because the data structure is not implemented yet. \\
    \hline
    Does the full screen button work & Pass & \\
    \hline
    Does the markdown text block work & Pass & \\
    \hline
    Does the code editor work & Pass & \\
    \hline
    Does the input panel work & Pass & \\
    \hline
    Does the output panel work & Pass & \\
    \hline
    Does the error panel work & Pass & \\
    \hline
    Does the language selection box work & Pass & \\
    \hline
    Does the Run Code button work & Failed & Not implemented because the Judger is not ready. \\
    \hline
    Does the Submit button work & Failed & Not implemented because the Judger is not ready. \\
    \hline
    Does the Submit problem navigation & Failed & Not implemented because the data structure is not ready. \\
    \hline
    Does the submission history table work & Failed & Not implemented because the database is not ready. \\
    \hline
\end{tabulary}

\subsection{Create the AccountPage}

\subsubsection{Implementation}

For the AccountPage, I use a grid of two row to divide the two sections for the account information and the statistics data. For the account information, I decide to use the RelativePanel to construct the layout to make it responsive to different sizes of the window. For the statistics data, I use the AdaptiveGridView which is used for the HomePage as well, so the data can be dynamically added in the code behind and make it a lot easier to add custom statistics later.

\begin{minted}{xml}
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="*"/>
        <RowDefinition Height="*"/>
    </Grid.RowDefinitions>

    <RelativePanel
        Grid.Row="0"
        HorizontalAlignment="Stretch"
        VerticalAlignment="Stretch">
        <PersonPicture
            x:Name="AvatarPicture"
            Margin="32"
            RelativePanel.AlignLeftWithPanel="True"
            RelativePanel.AlignVerticalCenterWithPanel="True"
            ProfilePicture="https://docs.microsoft.com/windows/uwp/contacts-and-calendar/images/shoulder-tap-static-payload.png" />
        <StackPanel
            RelativePanel.RightOf="AvatarPicture"
            RelativePanel.AlignVerticalCenterWithPanel="True">
            <TextBlock
                Margin="2"
                Text="Name"
                Style="{ThemeResource SubtitleTextBlockStyle}"/>
            <TextBlock
                Margin="2"
                Text="Email"
                Style="{ThemeResource BodyTextBlockStyle}"/>
            <TextBlock
                Margin="2"
                Text="Role"
                Style="{ThemeResource BodyTextBlockStyle}"/>
        </StackPanel>
        <StackPanel
            Margin="32"
            RelativePanel.AlignRightWithPanel="True"
            RelativePanel.AlignVerticalCenterWithPanel="True">
            <Button
                Margin="2"
                HorizontalAlignment="Stretch"
                Content="Edit"/>
            <Button
                Margin="2"
                HorizontalAlignment="Stretch"
                Content="Login"/>
        </StackPanel>
    </RelativePanel>

    <controls:AdaptiveGridView
        x:Name="StatsGridView"
        Grid.Row="1"
        Margin="0"
        ItemsSource="{x:Bind StatsItems}"
        StretchContentForSingleRow="False"
        OneRowModeEnabled="False"
        ItemHeight="120"
        DesiredWidth="240"
        SelectionMode="None"
        IsItemClickEnabled="False"
        Background="{ThemeResource AcrylicBackgroundFillColorDefaultBrush}">
        <GridView.ItemTemplate>
            <DataTemplate x:DataType="models:StatisticsItem">
                <Grid HorizontalAlignment="Stretch">
                    <StackPanel 
                        VerticalAlignment="Center"
                        HorizontalAlignment="Center"
                        Orientation="Vertical"
                        Margin="8">
                        <TextBlock
                            Text="{x:Bind Title}"
                            Margin="2"
                            Style="{ThemeResource BodyStrongTextBlockStyle}"
                            HorizontalAlignment="Center"/>
                        <TextBlock 
                            Text="{x:Bind Data}"
                            Margin="2"
                            HorizontalAlignment="Center"/>
                    </StackPanel>
                </Grid>
            </DataTemplate>
        </GridView.ItemTemplate>
    </controls:AdaptiveGridView>

</Grid>
\end{minted}

Similar to the HomePage, I create a model \code{StatisticsItem} for the statistics data and binds it to the grid. For now, I just add some sample data in for display purpose.

\begin{minted}{csharp}
public class StatisticsItem
{
    public StatisticsItem(string title, string data)
    {
        Title = title;
        Data = data;
    }

    public string Title { get; set; }
    public string Data { get; set; }
}
\end{minted}

\begin{minted}{csharp}
public AccountPage()
{
    InitializeComponent();
    StatsItems.Add(new StatisticsItem("Problem Solved", "10"));
    StatsItems.Add(new StatisticsItem("Problem Attempted", "3"));
    StatsItems.Add(new StatisticsItem("Problem Unsolved", "1100"));
    StatsItems.Add(new StatisticsItem("Correct Rate", "10%"));
    StatsItems.Add(new StatisticsItem("Favourite Topic", "Data structure"));
    StatsItems.Add(new StatisticsItem("Favourite Language", "Python"));
}
public ObservableCollection<StatisticsItem> StatsItems { get; } = new ObservableCollection<StatisticsItem>();
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AccountPage-Layout}

Next, I want to implement the edit function, which allows the user to change their user name, email address and role. To achieve this, I decide to replace the TextBlocks with TextBoxes for the user to edit the data when the Edit button is clicked. This can be achieved by setting the visibility of the controls. Instead of directly setting the visibility, I decide to bind the visibility property to a public variable named \code{IsEditMode} to determine whether it should display. In order to notify the binded control, I implement the \code{PropertyChanged} event\cite{microsoft:docs:data-binding-in-depth}.

\begin{minted}{csharp}
/// <summary>
/// Invoke when the property is changed.
/// </summary>
public event PropertyChangedEventHandler PropertyChanged = delegate { };

/// <summary>
/// Invoke a new <see cref="PropertyChanged"/> event.
/// </summary>
/// <param name="propertyName">Use <see cref="nameof"/> to get the name of the property.</param>
public void OnPropertyChanged([CallerMemberName] string propertyName = null)
{
    // Raise the PropertyChanged event, passing the name of the property whose value has changed.
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
}
\end{minted}

I create a private variable \code{_isEditMode} to record the current state. A public variable \code{IsEditMode} to encapsulated the private variable so I can call the \code{OnPropertyChanged} function I just implemented in the setter. I also create the \code{IsNotEditMode} attribute to handle the boolean inversion.

\begin{minted}{csharp}
private bool _isEditMode = false;
public bool IsEditMode
{
    get => _isEditMode;
    set
    {
        _isEditMode = value;
        OnPropertyChanged(nameof(IsEditMode));
        OnPropertyChanged(nameof(IsNotEditMode));
    }
}
public bool IsNotEditMode
{
    get => !_isEditMode;
}
\end{minted}

Finally, I edit the XAML markup to add the TextBoxes and add the bindings.


\begin{minted}{xml}
<StackPanel
    RelativePanel.RightOf="AvatarPicture"
    RelativePanel.AlignVerticalCenterWithPanel="True">
    <TextBlock
        x:Name="NameTextBlock"
        Margin="2"
        Text="{x:Bind EditNameTextBox.Text, Mode=OneWay}"
        Visibility="{x:Bind IsNotEditMode, Mode=OneWay"
        Style="{ThemeResource SubtitleTextBlockStyle}"/>
    <TextBox
        x:Name="EditNameTextBox"
        PlaceholderText="Name"
        Margin="2"
        Text="Name"
        HorizontalAlignment="Stretch"
        Visibility="{x:Bind IsEditMode, Mode=OneWay"/>
    <TextBlock
        x:Name="EmailTextBlock"
        Margin="2"
        Text="{x:Bind EditEmailTextBox.Text, Mode=OneWay}"
        Visibility="{x:Bind IsNotEditMode, Mode=OneWay"
        Style="{ThemeResource BodyTextBlockStyle}"/>
    <TextBox
        x:Name="EditEmailTextBox"
        PlaceholderText="Email"
        Text="Email"
        Margin="2"
        HorizontalAlignment="Stretch"
        Visibility="{x:Bind IsEditMode, Mode=OneWay"/>
    <TextBlock
        x:Name="RoleTextBlock"
        Margin="2"
        Text="{x:Bind EditRoleComboBox.SelectedValue, Mode=OneWay}"
        Visibility="{x:Bind IsNotEditMode, Mode=OneWay"
        Style="{ThemeResource BodyTextBlockStyle}"/>
    <ComboBox
        x:Name="EditRoleComboBox"
        Visibility="{x:Bind IsEditMode, Mode=OneWay"
        HorizontalAlignment="Stretch"
        Margin="2"
        SelectedIndex="0">
        <x:String>Student</x:String>
        <x:String>Teacher</x:String>
    </ComboBox>
</StackPanel>
\end{minted}

Now when I run the program, I can edit all fields successfully after clicking the Edit button. All the changes are preserved after clicking the Done button.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AccountPage-Edit}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AccountPage-Saved}

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Test & Result & Remark \\
    \hline
    Does it load & Pass & \\
    \hline
    Does the Edit button work & Pass & Note that the changes are not actually saved to the disk, since the settings module will not be implemented in this iteration. \\
    \hline
    Does the login button work & Failed & The login button depends on the API module, which will not be implemented in this iteration. \\
    \hline
    Does the statistics data show up correctly & Pass & Note that the actual data depends on the database module, which is not implemented yet. \\
    \hline
\end{tabulary}

\subsection{Create the CreatePage}

\subsubsection{Implementation}

For the CreateNewProblemPage, it contains a form for the user to input data to create new problems. I use a ScrollViewer to wrap everything up so the user can scroll in the page when the elements overflow. Inside the ScrollViewer, I place a StackPanel as the root panel to organize everything.

\begin{minted}{xml}
<ScrollViewer x:Name="scrollViewer">
    <StackPanel
        Margin="32"
        x:Name="FormStackPanel">
        <!-- Form controls -->
    </StackPanel>
</ScrollViewer>
\end{minted}

I use TextBoxes to allow the user to input problem name, a TokenizingTextBox for the tag, ComboBox for difficult, and NumberBox for time limit and memory limit.

\begin{minted}{xml}
<TextBlock
    Text="Create Problem"
    Style="{ThemeResource TitleTextBlockStyle}"/>
<TextBox
    Margin="0 22 0 0"
    Header="Problem Name"
    MaxLength="64"
    Width="400"
    HorizontalAlignment="Left"/>
<controls:TokenizingTextBox
    Header="Tags"
    Margin="0 22 0 0" 
    Width="400"
    MaximumTokens="3"
    PlaceholderText="Add Tags"
    SelectionMode="Extended"
    HorizontalAlignment="Left"/>
<ComboBox
    Header="Difficulty"
    SelectedIndex="0"
    Margin="0 22 0 0"
    Width="400"
    HorizontalAlignment="Left">
    <x:String>Easy</x:String>
    <x:String>Medium</x:String>
    <x:String>Hard</x:String>
</ComboBox>
<NumberBox
    Header="Time Limit (ms)"
    Value="1000"
    Width="400"
    Minimum="100"
    Margin="0 22 0 0"
    HorizontalAlignment="Left"
    SpinButtonPlacementMode="Inline"
    SmallChange="100"
    LargeChange="500"/>
<NumberBox
    Header="Memory Limit (MB)"
    Value="64"
    Width="400"
    Margin="0 22 0 0"
    Minimum="16"
    HorizontalAlignment="Left"
    SpinButtonPlacementMode="Inline"
    SmallChange="64"
    LargeChange="256"/>
\end{minted}

For the description, I use a Pivot to organize the input TextBox and the preview MarkdownRenderer.

\begin{minted}{xml}
<Pivot
    x:Name="DescriptionPivot">
    <PivotItem
        Header="Description">
        <TextBox
            x:Name="DescriptionTextBox"
            HorizontalAlignment="Stretch"
            VerticalAlignment="Stretch"
            TextWrapping="Wrap" 
            AcceptsReturn="True" 
            IsSpellCheckEnabled="True"
            MinHeight="200"
            MaxHeight="840"/>
    </PivotItem>
    <PivotItem
        Header="Preview">
        <controls:MarkdownTextBlock
            x:Name="ProblemMarkdownTextBlock"
            Margin="8"
            Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"
            Text="{x:Bind DescriptionTextBox.Text, Mode=OneWay}"/>
    </PivotItem>
</Pivot>
\end{minted}

Next, I implement the TestCase list. Similarly as the ProblemList before, I use a ListView and bind the TestCases collection to it.

\begin{minted}{xml}
<ListView
    x:Name="TestCasesListView"
    Margin="0 22 0 0"
    Header="Test Cases"
    SelectionMode="None"
    ItemsSource="{x:Bind TestCases, Mode=OneWay}">
    <ListView.ItemTemplate>
        <DataTemplate x:DataType="local:TestCase">
            <Grid
                Margin="0 10 0 0">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="auto"/>
                    <ColumnDefinition Width="auto"/>
                </Grid.ColumnDefinitions>
                <TextBox
                    Grid.Column="0"
                    Margin="4"
                    AcceptsReturn="True"
                    MaxHeight="100"
                    VerticalAlignment="Center"
                    PlaceholderText="Input Data"
                    Text="{x:Bind Input, Mode=TwoWay}"/>
                <TextBox
                    Grid.Column="1"
                    Margin="4"
                    AcceptsReturn="True"
                    MaxHeight="100"
                    VerticalAlignment="Center"
                    PlaceholderText="Output Data"
                    Text="{x:Bind Output, Mode=TwoWay}"/>
                <CheckBox
                    Grid.Column="2"
                    Margin="40 0 0 0"
                    Content="Example"
                    HorizontalAlignment="Center"
                    VerticalAlignment="Center"
                    IsChecked="{x:Bind IsExample, Mode=TwoWay}"/>
                <Button
                    x:Name="DeleteSingleTestCaseButton"
                    Grid.Column="3"
                    Margin="0"
                    VerticalAlignment="Center"
                    HorizontalAlignment="Center"
                    Click="DeleteSingleTestCase">
                    <Button.Content>
                        <SymbolIcon Symbol="Delete"/>
                    </Button.Content>
                </Button>
            </Grid>
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>
\end{minted}

\begin{minted}{csharp}
public ObservableCollection<TestCase> TestCases = new() { new TestCase("", "", true) };
\end{minted}


I implement a simple TestCase class for this iteration, so the UI can be tested. A more detailed one will be implemented in the later iteration.

\begin{minted}{csharp}
public class TestCase
{
    public string Input { get; set; }
    public string Output { get; set; }
    public bool IsExample { get; set; }
    public TestCase(string input, string output, bool isExample)
    {
        Input = input;
        Output = output;
        IsExample = isExample;
    }
}
\end{minted}

I add another StackPanel to organize the buttons to add new test cases and delete all test cases.

\begin{minted}{xml}
<StackPanel 
    Margin="0 12 0 0"
    HorizontalAlignment="Right"
    Orientation="Horizontal">
    <Button
        x:Name="AddTestCaseButton"
        Click="AddTestCase">
        <Button.Content>
            <SymbolIcon Symbol="Add"/>
        </Button.Content>
    </Button>
    <Button 
        Margin="4 0 12 0">
        <Button.Content>
            <SymbolIcon Symbol="Delete"/>
        </Button.Content>
        <Button.Flyout>
            <Flyout x:Name="DeleteConfirmFlyout">
                <StackPanel>
                    <TextBlock Style="{ThemeResource BaseTextBlockStyle}" Text="All test cases will be deleted. Do you want to continue?" Margin="0,0,0,12" />
                    <Button HorizontalAlignment="Right" Click="DeleteAllTestCases"  Content="Yes" />
                </StackPanel>
            </Flyout>
        </Button.Flyout>
    </Button>
</StackPanel>
\end{minted}

At the bottom of the page, a StackPanel is used to organize the save and cancel button. Flyouts are added to all delete and cancel buttons to confirm before actually performing the action.

\begin{minted}{xml}
<StackPanel 
    Margin="0 12 12 0"
    HorizontalAlignment="Left"
    Orientation="Horizontal">
    <Button 
        Margin="0 0 4 0"
        Content="Save"
        Width="100"
        Click="CreateProblem"
        Style="{ThemeResource AccentButtonStyle}"/>
    <Button 
        Width="100"
        Content="Cancel">
        <Button.Flyout>
            <Flyout x:Name="CancelConfirmFlyout">
                <StackPanel>
                    <TextBlock
                        Style="{ThemeResource BaseTextBlockStyle}"
                        Text="All changes will be lost. Do you want to continue?" Margin="0 0 0 12" />
                    <Button 
                        HorizontalAlignment="Right" 
                        Click="CancelCreation"  
                        Content="Yes" />
                </StackPanel>
            </Flyout>
        </Button.Flyout>
    </Button>
</StackPanel>
</StackPanel>
\end{minted}

The CreateNewProblemPage can be navigated to from the ProblemsPage. I connect the add problem in the ProblemsPage to the navigation function. Instead of manually navigate through the ContentFrame, I decide to encapsulate the management of the NavigationView through an App.NavigateTo function. Which enables me to reuse this part of code, and make it less likely for me to get the navigation wrong in the future. I expose the \code{m_window} and the \code{MainNavView} as global static variables, so the can be accessed easily in the App level.

\begin{minted}{csharp}
public static MainWindow m_window;
public static NavigationView MainNavView { get => m_window.MainNavView; }
public static Frame ContentFrame { get => m_window.ContentFrame; }

\end{minted}

\begin{minted}{csharp}
/// <summary>
/// Navigate to the <see cref="CreateNewProblemPage"/> to create a new <see cref="Problem"/>.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void CreateNewProblem(object sender, RoutedEventArgs e)
{
    App.NavigateTo(typeof(CreateNewProblemPage));
}
/// <summary>
/// Handle the navigation of the main <see cref="ContentFrame"/>
/// When the page is listed in the <see cref="MainNavView"/>, 
/// change the <see cref="MainNavView.SelectedItem"/> directly.
/// Otherwise, set the <see cref="MainNavView.SelectedItem"/> to null and 
/// apply the navigation on the Frame directly.
/// </summary>
/// <param name="type"></param>
/// <param name="parameter"></param>
public static void NavigateTo(Type type, object parameter = null)
{
    if (type == typeof(HomePage))
        MainNavView.SelectedItem = MainNavView.MenuItems[0];
    else if (type == typeof(ProblemsPage))
        MainNavView.SelectedItem = MainNavView.MenuItems[1];
    else if (type == typeof(AssignmentsPage))
        MainNavView.SelectedItem = MainNavView.MenuItems[2];
    else if (type == typeof(PlaygroundPage))
        MainNavView.SelectedItem = MainNavView.MenuItems[3];
    else if (type == typeof(AccountPage))
        MainNavView.SelectedItem = MainNavView.FooterMenuItems[0];
    else if (type == typeof(SettingsPage))
        MainNavView.SelectedItem = MainNavView.SettingsItem;
    else
    {
        ContentFrame.Navigate(type, parameter);
        MainNavView.SelectedItem = null;
    }
}
\end{minted}

Now I can easily navigate to the CreateNewProblemPage with the \code{NavigateTo} function.

\begin{minted}{csharp}
/// <summary>
/// Navigate to the <see cref="CreateNewProblemPage"/> to create a new <see cref="Problem"/>.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void CreateNewProblem(object sender, RoutedEventArgs e)
{
    App.NavigateTo(typeof(CreateNewProblemPage));
}
\end{minted}

When I click the Add Problem button in the ProblemsPage, the ContentFrame navigates to the CreateNew Page successfully. The MainNavView is deselected correctly as well.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CreateNewProblemPage-Layout}

I can input all data for a new problem. The length validation for the problem name and the tag box is working as intended. The time limit field and memory limit field also rejecte any non-numerical input as intended. However, when I try to delete a token in the TokenizingTextBox, an exception is thrown and the app crashes.

\begin{minted}{text}
Unhandled exception at 0x00007FFCDA3E6328 (Microsoft.ui.xaml.dll) in Algorithm Dynamics.exe: 0xC000027B: An application-internal exception has occurred (parameters: 0x000001DCA9C47860, 0x0000000000000006).
\end{minted}

It seems to be an internal issue with Microsoft.ui.xaml.dll. After some research, I found that this is caused by an internal bug with the TokenizingTextBox\cite{github:WindowsCommunityToolkit:4437}. I will keep an eye on the issue and update the dependency as soon as it gets fixed. For now, I will just leave it as this and mark this as a known issue.

Next, I implement a series of functions in the code behind to handle the add delete test case function, and the save cancel function.

\begin{minted}{csharp}
/// <summary>
/// Add a new <see cref="TestCase"/> to the list.
/// Scroll the <see cref="scrollViewer"/> to the new position.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void AddTestCase(object sender, RoutedEventArgs e)
{
    TestCases.Add(new TestCase("", "", false));
    GeneralTransform transform = AddTestCaseButton.TransformToVisual((UIElement)scrollViewer.Content);
    Point position = transform.TransformPoint(new Point(0, 0));
    scrollViewer.ChangeView(null, position.Y, null, false);
}

/// <summary>
/// Delete the selected <see cref="TestCase"/>. Update the <see cref="TestCase.Id"/>.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void DeleteSingleTestCase(object sender, RoutedEventArgs e)
{
    TestCase selectedItem = ((FrameworkElement)sender).DataContext as TestCase;
    TestCases.Remove(selectedItem);
}

/// <summary>
/// Delete all <see cref="TestCase"/>, hide the <see cref="DeleteConfirmFlyout"/>.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void DeleteAllTestCases(object sender, RoutedEventArgs e)
{
    TestCases.Clear();
    DeleteConfirmFlyout.Hide();
}

/// <summary>
/// Cancel the creation, navigate back to the <see cref="ProblemsPage"/>.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void CancelCreation(object sender, RoutedEventArgs e)
{
    CancelConfirmFlyout.Hide();
    App.NavigateTo(typeof(ProblemsPage));
}

/// <summary>
/// Create the problem and save it into the database.
/// Navigate back to the <see cref="ProblemsPage"/> afterwards.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void CreateProblem(object sender, RoutedEventArgs e)
{
    // TODO save the Problem to database
    App.NavigateTo(typeof(ProblemsPage));
}
\end{minted}

For the edit problem page, I find that there is not much difference from the create page. The edit problem page is just a create problem page with a different title, and some pre-loaded problem data. I think I can reuse most of the existing code to implement the edit page.

I add an enumeration of \code{Mode} to the page to specify whether it is a create page or an edit page.

\begin{minted}{csharp}
public enum Mode
{
    Create,
    Edit
}
private Mode PageMode = Mode.Create;
\end{minted}

I use a private readonly variable \code{_title} to store the string of the title of the page. It determines the correct title for the page based on the page mode.

\begin{minted}{csharp}
private string _title
{
    get
    {
        if (PageMode == Mode.Create)
            return "Create Problem";
        else
            return "Edit Problem";
    }
}
\end{minted}

I bind the title TextBox to the \code{_title} variable. Each time when the page is loaded, its value is recalculated and the correct one will be displayed.

\begin{minted}{xml}
<TextBlock
    Text="{x:Bind _title, Mode=OneTime}"
    Style="{ThemeResource TitleTextBlockStyle}"/>
\end{minted}

To allow the page mode to be set, I need to handle the OnNavigatedTo event and process the arguments correctly to retrieve the page mode.

\begin{minted}{csharp}
/// <summary>
/// Handle the Navigation Arguments
/// Set the <see cref="PageMode"/> if the Parameter is not <see cref="null"/>.
/// </summary>
/// <param name="e"></param>
protected override void OnNavigatedTo(NavigationEventArgs e)
{
    if (e.Parameter != null)
    {
        PageMode = ((Tuple<Mode, int>)e.Parameter).Item1;
    }
    base.OnNavigatedTo(e);
}
\end{minted}

Now, I can connect the edit button in the ProblemsPage to the edit page mode, so the correct title is displayed.

\begin{minted}{csharp}
private Problem _problem;
/// <summary>
/// Handle the Navigation Arguments
/// Set the <see cref="_pageMode"/> if the Parameter is not <see cref="null"/>.
/// </summary>
/// <param name="e"></param>
protected override void OnNavigatedTo(NavigationEventArgs e)
{
    if (e.Parameter != null)
    {
        var parameter = (Tuple<Mode, Problem>)e.Parameter;
        _pageMode = parameter.Item1;
        _problem = parameter.Item2;
    }
    base.OnNavigatedTo(e);
}
\end{minted}

Now when I right click a problem in the ProblemsPage and click the edit button in the flyout, the edit page mode is loaded correctly with the problem data being filled for me.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CreateNewProblemPage-Edit}

For the CreateNewProblemListPage, I create it in a very similar way - but with different fields and options.

\begin{minted}{xml}
<ScrollViewer x:Name="scrollViewer">
    <StackPanel
        Margin="32"
        x:Name="FormStackPanel">
        <TextBlock
            Text="{x:Bind _title, Mode=OneTime}"
            Style="{ThemeResource TitleTextBlockStyle}"/>
        <TextBox
            Margin="0 22 0 0"
            Header="Title"
            MaxLength="64"
            Width="400"
            HorizontalAlignment="Left"/>
        <CalendarDatePicker 
            Margin="0 22 0 0"
            Visibility="{x:Bind _isAssignmentMode, Mode=OneTime}"
            PlaceholderText="Set the due date" 
            Header="Due Date"/>
        <TextBox
            Margin="0 22 0 0"
            Header="Description"
            HorizontalAlignment="Left"
            TextWrapping="Wrap" 
            AcceptsReturn="True" 
            IsSpellCheckEnabled="True"
            MinWidth="400"
            MinHeight="200"
            MaxHeight="840"/>
        <AutoSuggestBox
            x:Name="AddProblemBox"
            Header="Add Problems"
            Margin="0 22 0 0"
            HorizontalAlignment="Left"
            QueryIcon="Find"
            Width="400"
            TextChanged="AddProblemBox_TextChanged"
            SuggestionChosen="AddProblemBox_SuggestionChosen"/>
        <ListView
            Margin="0 22 0 0"
            SelectionMode="None"
            ItemsSource="{x:Bind Problems, Mode=OneWay}">
            <ListView.ItemTemplate>
                <DataTemplate x:DataType="local:Problem">
                    <Grid
                        Margin="0 10 0 0">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>
                        <TextBlock
                            Grid.Column="0"
                            VerticalAlignment="Center"
                            Text="{x:Bind Name}"/>
                        <TextBlock
                            Grid.Column="1"
                            VerticalAlignment="Center"
                            Text="{x:Bind Difficulty}"/>
                        <TextBlock
                            Grid.Column="2"
                            VerticalAlignment="Center"
                            Text="{x:Bind Tags}"/>
                        <Button
                            x:Name="DeleteButton"
                            Grid.Column="3"
                            HorizontalAlignment="Right"
                            Click="DeleteSingleTestCase">
                            <Button.Content>
                                <SymbolIcon Symbol="Delete"/>
                            </Button.Content>
                        </Button>
                    </Grid>
                </DataTemplate>
            </ListView.ItemTemplate>
        </ListView>
        <StackPanel 
            Margin="0 22 12 0"
            HorizontalAlignment="Left"
            Orientation="Horizontal">
            <Button
                x:Name="SaveButton"
                Content="Save"
                Width="100"
                Margin="0 0 4 0"
                Click="SaveButton_Click"
                Style="{ThemeResource AccentButtonStyle}">
                <Button.Flyout>
                    <Flyout
                        x:Name="SaveFlyout">
                        <StackPanel>
                            <TextBlock 
                                x:Name="TestTextBlock"
                                Style="{ThemeResource BaseTextBlockStyle}"
                                Text="The Problem List is not saved." 
                                Margin="0 0 0 12" />
                            <StackPanel 
                                Orientation="Horizontal"
                                HorizontalAlignment="Right">
                                <Button
                                    x:Name="DoneButton"
                                    Margin="0 0 4 0"
                                    Content="Done"
                                    Click="Finish"/>
                                <Button 
                                    x:Name="ExportButton"
                                    Click="ExportAndFinish"
                                    Style="{ThemeResource AccentButtonStyle}"
                                    Content="Export"/>
                            </StackPanel>
                        </StackPanel>
                    </Flyout>
                </Button.Flyout>
            </Button>
            <Button
                Content="Cancel"
                Width="100">
                <Button.Flyout>
                    <Flyout>
                        <StackPanel>
                            <TextBlock
                                Style="{ThemeResource BaseTextBlockStyle}"
                                Text="All changes will be lost. Do you want to continue?" Margin="0 0 0 12" />
                            <Button 
                                HorizontalAlignment="Right" 
                                Click="Finish"
                                Content="Yes" />
                        </StackPanel>
                    </Flyout>
                </Button.Flyout>
            </Button>
        </StackPanel>
    </StackPanel>
</ScrollViewer>
\end{minted}

Similarly, I reuse the same page for create/edit ProblemList and Assignments by managing different page mode.

\begin{minted}{csharp}
public enum Mode
{
    CreateProblemList,
    EditProblemList,
    CreateAssignment,
    EditAssignment
}
private Mode _pageMode = Mode.CreateProblemList;
private bool _isAssignmentMode { get => _pageMode == Mode.CreateAssignment || _pageMode == Mode.EditAssignment; }
private string _title
{
    get
    {
        if (_pageMode == Mode.CreateProblemList)
            return "Create Problem List";
        else if (_pageMode == Mode.EditProblemList)
            return "Edit Problem List";
        else if (_pageMode == Mode.CreateAssignment)
            return "Create Assignment";
        else
            return "Edit Assignment";
    }
}

/// <summary>
/// Handle the Navigation Arguments
/// Set the <see cref="_pageMode"/> if the Parameter is not <see cref="null"/>.
/// </summary>
/// <param name="e"></param>
protected override void OnNavigatedTo(NavigationEventArgs e)
{
    if (e.Parameter != null)
    {
        _pageMode = ((Tuple<Mode>)e.Parameter).Item1;
    }
    base.OnNavigatedTo(e);
}
\end{minted}


Differently, instead of asking the user to create new test cases, the user is required to search and select problems from the existing database. I use a procedure to handle the event when the user is inputing in the search box.

\begin{minted}{csharp}
/// <summary>
/// When the text is changed in the search box, search in the database and create suggestion items. 
/// </summary>
/// <param name="sender"></param>
/// <param name="args"></param>
private void AddProblemBox_TextChanged(AutoSuggestBox sender, AutoSuggestBoxTextChangedEventArgs args)
{
    if (args.Reason == AutoSuggestionBoxTextChangeReason.UserInput)
    {
        var suitableItems = new List<string>();
        suitableItems.Add(sender.Text);
        // TODO search the actual problem from the database
        if (suitableItems.Count == 0)
        {
            suitableItems.Add("No results found");
        }
        sender.ItemsSource = suitableItems;
    }

}
/// <summary>
/// When a suggestion is chosen, add it in to the list.
/// </summary>
/// <param name="sender"></param>
/// <param name="args"></param>
private void AddProblemBox_SuggestionChosen(AutoSuggestBox sender, AutoSuggestBoxSuggestionChosenEventArgs args)
{
    Problems.Add(new Problem(sender.Text, "Easy", "ToDo", "Data structure"));
}
\end{minted}

When the user clicks the delete button on a problem, I use a procedure to delete the problem from the list.

\begin{minted}{csharp}
/// <summary>
/// Delete the selected problem from the list.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void DeleteSingleProblem(object sender, RoutedEventArgs e)
{
    Problem selectedItem = ((FrameworkElement)sender).DataContext as Problem;
    Problems.Remove(selectedItem);
}
\end{minted}

When the user click the save button, I use a procedure to save the problem to the database.

\begin{minted}{csharp}
/// <summary>
/// When the save button is clicked, save the problem list and change the description test.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void SaveButton_Click(object sender, RoutedEventArgs e)
{
    // TODO actually save the problem to the database.
    TestTextBlock.Text = "The Problem List is saved.";
}
\end{minted}

When the user has finished editing, a procedure will hide all the flyouts and navigate the user back to the ProblemsPage.

\begin{minted}{csharp}
/// <summary>
/// Finish create or edit the ProblemList or Assignment.
/// Go back to <see cref="ProblemsPage"/> or <see cref="AssignmentsPage"/> based on <see cref="_pageMode"/>.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void Finish(object sender, RoutedEventArgs e)
{
    SaveFlyout.Hide();
    if (_pageMode == Mode.CreateProblemList || _pageMode == Mode.EditProblemList)
        App.NavigateTo(typeof(ProblemsPage));
    else
        App.NavigateTo(typeof(AssignmentsPage));
}
\end{minted}

When the user clicks the export button, a dialog is shown allowing the user to save the file at a desired location\cite{microsoft:docs:quickstart-using-file-and-folder-pickers}. Then the file is saved to that path.

\begin{minted}{csharp}
/// <summary>
/// Display the <see cref="FileSavePicker"/> to get the file path.
/// Save the file and finish.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private async void ExportAndFinish(object sender, RoutedEventArgs e)
{
    var savePicker = new FileSavePicker();
    savePicker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
    savePicker.FileTypeChoices.Add("JSON file", new List<string>() { ".json" });
    savePicker.SuggestedFileName = "Assignment Name";
    StorageFile file = await savePicker.PickSaveFileAsync();

    if (file != null)
    {
        // Prevent updates to the remote version of the file until
        // we finish making changes and call CompleteUpdatesAsync.
        CachedFileManager.DeferUpdates(file);
        // write to file
        await FileIO.WriteTextAsync(file, "TODO export the Problem List/Assignment");
        // Let Windows know that we're finished changing the file so
        // the other app can update the remote version of the file.
        // Completing updates may require Windows to ask for user input.
        FileUpdateStatus status = await CachedFileManager.CompleteUpdatesAsync(file);
        if (status == FileUpdateStatus.Complete)
        {
            SaveFlyout.Hide();
            if (_pageMode == Mode.CreateProblemList || _pageMode == Mode.EditProblemList)
                App.NavigateTo(typeof(ProblemsPage));
            else
                App.NavigateTo(typeof(AssignmentsPage));
        }
        else
        {
            // TODO handle saved failed
        }
    }
    else
    {
        // TODO handle cancelled
    }
}
\end{minted}

Similarly, I go back to the ProblemsPage and link the buttons to the CreateNewProblemListPage.

\begin{minted}{csharp}
/// <summary>
/// Navigate to the edit ProblemList page
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
/// <exception cref="NotImplementedException"></exception>
private void EditProblemList(object sender, RoutedEventArgs e)
{
    App.NavigateTo(typeof(CreateNewProblemListPage), Tuple.Create(CreateNewProblemListPage.Mode.EditProblemList));
}
private void CreateNewProblemList(object sender, RoutedEventArgs e)
{
    App.NavigateTo(typeof(CreateNewProblemListPage));
}
\end{minted}

Now, when I run the app, I can visit the CreateNewProblemListPage from the CodingPage.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CreateNewProblemListPage-CreateList}

The title displays correctly, and all fields and the search box is working as intended. I can add and delete problems. When I click the cancel button, I can navigate back to the ProblemsPage correctly. However, when I click the export button, the app crashes.

\begin{minted}{text}
Unhandled exception at 0x00007FFB617D5B2C (CoreMessagingXP.dll) in Algorithm Dynamics.exe: 0xC000027B: An application-internal exception has occurred (parameters: 0x00000281960E3F70, 0x0000000000000001).
\end{minted}

The CoreMessagingXP.dll suggests that this might caused by another internal bug. After doing some research, there is a way around it. I need to obtain the current HWND and set the HWND on the picker\cite{github:WindowsAppSDK:1188}.

\begin{minted}{csharp}
// Get the current window's HWND by passing in the Window object
var hwnd = WinRT.Interop.WindowNative.GetWindowHandle(this);

// Associate the HWND with the file picker
WinRT.Interop.InitializeWithWindow.Initialize(filePicker, hwnd);
\end{minted}

After adding these two lines, the save file picker can work correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CreateNewProblemListPage-FilePicker}

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Test & Result & Remark \\
    \hline
    Does it load & Pass & \\
    \hline
    Does the title field work & Pass &  \\
    \hline
    Does the tags field work & Failed & Marked as a known issue, waiting to be fixed by upstream. \\
    \hline
    Does the difficulty field work & Pass & \\
    \hline
    Does the time limit field work and validate the data & Pass & \\
    \hline
    Does the memory limit field work and validate the data & Pass & \\
    \hline
    Does the description field work & Pass & \\
    \hline
    Does the preview block work & Pass & \\
    \hline
    Is it possible to add or remove test cases & Pass & \\
    \hline
    Does the cancel button work & Pass & \\
    \hline
    Does the save button work & Failed & The save button depends on the database and export function. Which will not be implemented in this iteration. \\
    \hline
\end{tabulary}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Does it load & Pass & \\
    \hline
    Does the title field work & Pass & \\
    \hline
    Does the description field work & Pass & \\
    \hline
    Does the search box work & Pass & \\
    \hline
    Does the cancel button work & Pass & \\
    \hline
    Does the save button work & Failed & The save button depends on the database and export function. Which will not be implemented in this iteration. \\
    \hline
    Does the export button work & Pass & The file picker shows up correctly. But similarly, the actual content is not saved to the disk. \\
    \hline
\end{tabulary}

\subsubsection{Stakeholder feedback}

Timofei reports that the spell check is sometimes very annoying and inappropriate in the problem description section.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CreateNewProblemPage-SpellCheck}

Some legal programming language keywords are marked wrong. I decide to disable it since it does not really help much anyway.

\begin{minted}{xml}
<TextBox
    <!-- ... -->
    IsSpellCheckEnabled="False"
    <!-- ... -->/>
\end{minted}

Timofei is happy with the result.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CreateNewProblemPage-SpellCheck-Disable}

\subsection{Create the AssignmentsPage}

\subsubsection{Implementation}

I first implement the AssignmentsPage, which allows the user to broswe existing assignments. I decide to use a grid of two rows to organize the navigation bar and the assignment list.

\begin{minted}{xml}
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="auto"/>
        <RowDefinition Height="*"/>
    </Grid.RowDefinitions>

    <NavigationView>
        <!-- Navigation Menu -->
    </NavigationView>

    <ListView>
        <!-- Assignment List -->
    </ListView>
</Grid>
\end{minted}

For the navigation panel, it has three tabs, assigned, completed and created. It also has a ComboBox, which allows the user to create or import assignments.

\begin{minted}{xml}
<NavigationView 
    x:Name="AssignmentsNavView"
    IsSettingsVisible="False"
    IsBackButtonVisible="Collapsed"
    IsBackEnabled="False"
    SelectionChanged="AssignmentsNavView_SelectionChanged"
    Header="Header"
    AlwaysShowHeader="False"
    PaneDisplayMode="Top"
    ExpandedModeThresholdWidth="500"
    SelectionFollowsFocus="Disabled"
    IsTabStop="False">
    <NavigationView.MenuItems>
        <NavigationViewItem Content="Assigned" x:Name="AssignedItem"/>
        <NavigationViewItem Content="Completed" x:Name="CompletedItem"/>
        <NavigationViewItem Content="Created" x:Name="CreatedItem"/>
    </NavigationView.MenuItems>

    <NavigationView.PaneFooter>
        <DropDownButton Content="Add">
            <DropDownButton.Flyout>
                <MenuFlyout Placement="Bottom">
                    <MenuFlyoutItem 
                        Text="Create"
                        Click="CreateAssignment"/>
                    <MenuFlyoutItem 
                        Text="Import"
                        Click="ImportAssignment"/>
                </MenuFlyout>
            </DropDownButton.Flyout>
        </DropDownButton>
    </NavigationView.PaneFooter>
</NavigationView>
\end{minted}

I bind the selection changed event to a procedure to switch between different assignment lists.

\begin{minted}{csharp}
/// <summary>
/// Set the <see cref="Assignments"/> based on different SelectedItem
/// </summary>
/// <param name="sender"></param>
/// <param name="args"></param>
private void AssignmentsNavView_SelectionChanged(NavigationView sender, NavigationViewSelectionChangedEventArgs args)
{
    if (AssignmentsNavView.SelectedItem == AssignmentsNavView.MenuItems[0])
    {
        // TODO Query the database and retrieve the assigned assignments
    }
    else if (AssignmentsNavView.SelectedItem == AssignmentsNavView.MenuItems[1])
    {
        // TODO Query the database and retrieve the completed assignments
    }
    else
    {
        // TODO Query the database and retrieve the created assignments
    }
}
\end{minted}

For the CreateAssignment button, when the user clicks it, the App will navigate to the CreateNewProblemListPage with the correct argument so the assignment mode is loaded.

\begin{minted}{csharp}
/// <summary>
/// Navigate to the <see cref="CreateNewProblemListPage"/> with <see cref="CreateNewProblemListPage.Mode.CreateAssignment"/>.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void CreateAssignment(object sender, RoutedEventArgs e)
{
    App.NavigateTo(typeof(CreateNewProblemListPage), Tuple.Create(CreateNewProblemListPage.Mode.CreateAssignment));
}
\end{minted}

For the ImportAssignment button, it shows a similar file picker for the user to pick a file to import.

\begin{minted}{csharp}
/// <summary>
/// Display a <see cref="FileOpenPicker"/> and load the assignment from the file
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private async void ImportAssignment(object sender, RoutedEventArgs e)
{
    FileOpenPicker filePicker = new FileOpenPicker();

    // Get the current window's HWND by passing in the Window object
    IntPtr hwnd = WindowNative.GetWindowHandle(App.m_window);

    // Associate the HWND with the file picker
    InitializeWithWindow.Initialize(filePicker, hwnd);

    // Use file picker
    filePicker.FileTypeFilter.Add("*");
    StorageFile file = await filePicker.PickSingleFileAsync();
    // TODO Import file into the Database.
}
\end{minted}

For the assignment list, I bind it to an ObserableCollection and display its name and DueDate.

\begin{minted}{xml}
<ListView
    Grid.Row="1"
    SelectionMode="None"
    IsItemClickEnabled="True"
    ItemClick="ListView_ItemClick"
    ItemsSource="{x:Bind Assignments, Mode=OneWay}">
    <ListView.ItemTemplate>
        <DataTemplate x:DataType="local:Assignment">
            <Grid
                Height="50">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <TextBlock 
                    Grid.Column="0"
                    VerticalAlignment="Center"
                    Text="{x:Bind Name}"/>
                <TextBlock
                    Grid.Column="1"
                    VerticalAlignment="Center"
                    Text="{x:Bind DueDate}"/>
            </Grid>
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>
\end{minted}

\begin{minted}{csharp}
public ObservableCollection<Assignment> Assignments = new();
\end{minted}

And when an item is clicked, it should navigate to the AssignmentDetailsPage.

\begin{minted}{csharp}
/// <summary>
/// Navigate the the <see cref="AssignmentDetailsPage"/> when an assignment is clicked in the list.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ListView_ItemClick(object sender, ItemClickEventArgs e)
{
    App.NavigateTo(typeof(AssignmentDetailsPage));
}
\end{minted}

Now, when I run the App, the assignment page is loaded correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AssignmentsPage-Layout}

The create button navigates to the CreateProblemListPage with the correct page mode.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AssignmentsPage-Create}

The file picker also shows up correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AssignmentsPage-FilePicker}

Now, I need to create the AssignmentDetailsPage to display the detailed information about each assignment. The AssignmentDetailsPage will be different for the student or the teacher, but I will use the same page mode idea here to reuse as much code as possible.

I wrap everything in a ScrollViewer so all components will be responsive on different screen sizes. In the ScrollViewer, I use a StackPanel to group all components together.

\begin{minted}{xml}
<ScrollViewer>
    <StackPanel
        Margin="32">
        <!-- Main components -->
    </StackPanel>
</ScrollViewer>
\end{minted}

I place a header at the top.

\begin{minted}{xml}
<TextBlock
        Text="Assignment 1"
        Style="{ThemeResource TitleTextBlockStyle}"/>
\end{minted}

Then, a RelativePanel to display all basic information of the assignment.

\begin{minted}{xml}
<RelativePanel>
    <TextBlock 
        Margin="4"
        RelativePanel.AlignLeftWithPanel="True"
        Text="Due 01/01/2022"/>
    <Button
        x:Name="StartButton"
        Margin="4"
        Visibility="{x:Bind _isStudentMode, Mode=OneTime}"
        RelativePanel.LeftOf="SubmitButton"
        Content="Start"/>
    <Button
        x:Name="SubmitButton"
        Content="Submit"
        Margin="4"
        Visibility="{x:Bind _isStudentMode, Mode=OneTime}"
        RelativePanel.AlignRightWithPanel="True"
        Style="{ThemeResource AccentButtonStyle}"/>
    <Button
        x:Name="EditButton"
        Content="Edit"
        Margin="4"
        Click="EditAssignment"
        Visibility="{x:Bind _isTeacherMode, Mode=OneTime}"
        RelativePanel.LeftOf="ImportSubmissionButton"/>
    <Button
        x:Name="ImportSubmissionButton"
        Content="Import Submission"
        Margin="4"
        Visibility="{x:Bind _isTeacherMode, Mode=OneTime}"
        RelativePanel.AlignRightWithPanel="True"
        Style="{ThemeResource AccentButtonStyle}"/>
</RelativePanel>
\end{minted}

A two by two grid to put the description of the assignment, the problem list and the submission list.

\begin{minted}{xml}
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="auto"/>
        <RowDefinition Height="*"/>
    </Grid.RowDefinitions>
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*"/>
        <ColumnDefinition Width="*"/>
    </Grid.ColumnDefinitions>
    <TextBlock 
        Grid.Row="0"
        Grid.Column="0"
        TextWrapping="Wrap"
        Margin="4"
        Text="Description."/>
    <ListView
        x:Name="ProblemListView"
        Grid.Row="1"
        Grid.Column="0"
        Header="Problems"
        IsItemClickEnabled="True"
        ItemClick="ProblemListView_ItemClick"
        ItemsSource="{x:Bind Problems, Mode=OneWay}"
        Margin="4">
        <ListView.ItemTemplate>
            <DataTemplate x:DataType="local:Problem">
                <TextBlock Text="{x:Bind Name, Mode=OneWay}"/>
            </DataTemplate>
        </ListView.ItemTemplate>
    </ListView>
    <ListView
        Grid.Row="0"
        Grid.RowSpan="2"
        Grid.Column="1"
        Margin="4"
        Visibility="{x:Bind _isTeacherMode, Mode=OneTime}"
        ItemsSource="{x:Bind Submissions, Mode=OneWay}"
        Header="Submissions">
        <ListView.ItemTemplate>
            <DataTemplate x:DataType="local:Submission">
                <TextBlock Text="{x:Bind Status, Mode=OneWay}"/>
            </DataTemplate>
        </ListView.ItemTemplate>
    </ListView>
</Grid>
\end{minted}

Similarly, I use the PageMode to manage visibility for different components, therefore display a different page for students and teachers.

\begin{minted}{csharp}
public enum Mode
{
    Student,
    Teacher
}
private Mode _pageMode = Mode.Student;
private bool _isStudentMode { get => _pageMode == Mode.Student; }
private bool _isTeacherMode { get => _pageMode == Mode.Teacher; }

/// <summary>
/// Handle the Navigation Arguments
/// Set the <see cref="_pageMode"/> if the Parameter is not <see cref="null"/>.
/// </summary>
/// <param name="e"></param>
protected override void OnNavigatedTo(NavigationEventArgs e)
{
    if (e.Parameter != null)
    {
        _pageMode = ((Tuple<Mode>)e.Parameter).Item1;
    }
    base.OnNavigatedTo(e);
}
\end{minted}

I can modify the navigate function in the AssignmentsPage to pass the correct argument for corresponding assignment.

\begin{minted}{csharp}
/// <summary>
/// Navigate the the <see cref="AssignmentDetailsPage"/> when an assignment is clicked in the list.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ListView_ItemClick(object sender, ItemClickEventArgs e)
{
    // TODO use logged in user information to determine which page to display 
    var assignment = e.ClickedItem as Assignment;
    if (assignment.Description == "Created Assignment")
    {
        App.NavigateTo(typeof(AssignmentDetailsPage), Tuple.Create(AssignmentDetailsPage.Mode.Teacher));
    }
    else
    {
        App.NavigateTo(typeof(AssignmentDetailsPage), Tuple.Create(AssignmentDetailsPage.Mode.Student));
    }
}
\end{minted}

When I click the assignments under the Assigned panel, the student view with the correct submit button shows up correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AssignmentDetailsPage-Student}

When I click the assignments under the Created panel, the teacher view with the correct buttons and submissions shows up correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AssignmentDetailsPage-Teacher}

All these buttons are not working right now, since the UI is the only thing that will be implemented in this iteration.

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Test & Result & Remark \\
    \hline
    Does it load & Pass & \\
    \hline
    Does the navigation panel work & Pass &  \\
    \hline
    Does the import button work & Failed & The import function will not be implemented in this iteration.  \\
    \hline
    Does the create button work & Pass & \\
    \hline
    Does the assignment details navigation work & Pass & \\
    \hline
    Does different page modes work & Pass & \\
    \hline
    Does the description show up correctly & Pass & \\
    \hline
    Does the problem list show up correctly & Pass & \\
    \hline
    Does the submission list show up correctly & Pass & \\
    \hline
    Does the due date show up correctly & Pass & \\
    \hline
    Does the start button work & Pass & \\
    \hline
    Does the submit button work & Failed & The export function will not be implemented in this iteration. \\
    \hline
    Does the edit button work & Pass & \\
    \hline
    Does the judge button work & Failed & The Judger will not be implemented in this iteration. \\
    \hline
    Does the export button work & Failed & The export function will not be implemented in this iteration. \\
    \hline
\end{tabulary}

\subsubsection{Stakeholder feedback}

When I show the assignment pages to Mr Grimwood, he asked me that how the student's submission is graded? Is it send to a server or is it graded locally. I explained that the code submission will be compiled and run locally against test cases. He then expressed concerns of the security of the grading system. Allowing any external code to be run on the teacher's computer may not be a good idea.

He showed this example to me:

\begin{minted}{python}
import os
os.system("calc")
\end{minted}

When executing this Python code, the system calculator will be launched. The \code{calc} command can be replaced with any other commands, such as deleting files or shutting down the computer.

After some research, there is no easy way on Windows to restrictive the priviliges for certain code. Since this security issue is very serious, we both agree that implementing the assignment feature in this way is not ideal.

For now, I will discontinue all the assignment related feature in the prototype. I will continue researching and discuss some potintial solutions in the Evaluation chapter.

\subsection{Create the SettingsPage}

\subsubsection{Implementation}

Similarly, I wrap a ScrollViewer around all the components so they can be responsive to different screen size.

\begin{minted}{xml}
<ScrollViewer>
    <StackPanel
        Margin="32">
        <!-- ... -->
    </StackPanel>
</ScrollViewer>
\end{minted}

For the theme selection, I use three radio buttons so the user can select between different themes easily.

\begin{minted}{xml}
<TextBlock
    Style="{ThemeResource SubtitleTextBlockStyle}"
    Margin="0 12 0 0"
    FontWeight="Normal"
    Text="Theme Mode" />
<StackPanel x:Name="ThemePanel" Margin="0 10 0 0">
    <RadioButton 
        Tag="Light" 
        Content="Light"
        Checked="ThemeRadioButton_Checked"/>
    <RadioButton 
        Tag="Dark" 
        Content="Dark"
        Checked="ThemeRadioButton_Checked"/>
    <RadioButton 
        Tag="Default" 
        Content="Use system settings"
        Checked="ThemeRadioButton_Checked"/>
</StackPanel>
\end{minted}

The radio buttons are bind to a procedure, so when they are checked, the subroutine gets executed.

\begin{minted}{csharp}
/// <summary>
/// Change the application request theme to the selected theme when the radio button is clicked
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ThemeRadioButton_Checked(object sender, RoutedEventArgs e)
{
    var selectedTheme = ((RadioButton)sender)?.Tag?.ToString();

    if (selectedTheme != null && App.m_window.Content is FrameworkElement rootElement)
    {
        rootElement.RequestedTheme = GetEnum<ElementTheme>(selectedTheme);
    }
}
\end{minted}

The run code time limit and memory limit are two simple number box, which automatically validate the input.

\begin{minted}{xml}
<TextBlock
    Style="{ThemeResource SubtitleTextBlockStyle}"
    Margin="0 20 0 0"
    FontWeight="Normal"
    Text="Run Code Time Limit" />
<StackPanel 
    Margin="0 10 0 0"
    Orientation="Horizontal">
    <NumberBox
        SpinButtonPlacementMode="Inline"
        Value="1000"
        Minimum="100"
        SmallChange="100"
        LargeChange="500" />
    <TextBlock 
        Margin="8"
        Text="ms"
        VerticalAlignment="Center"/>
</StackPanel>
<TextBlock
    Style="{ThemeResource SubtitleTextBlockStyle}"
    Margin="0 20 0 0"
    FontWeight="Normal"
    Text="Run Code Memory Limit" />
<StackPanel 
    Margin="0 10 0 0"
    Orientation="Horizontal">
    <NumberBox
        Value="64"
        Minimum="16"
        SpinButtonPlacementMode="Inline"
        SmallChange="64"
        LargeChange="256" />
    <TextBlock
        Margin="8"
        Text="MB"
        VerticalAlignment="Center"/>
</StackPanel>
\end{minted}

I use an expander to hold the programming language configuration editor. It expands when the user clicks it, which makes the interface looks simple when the user does not want to modify this part of settings.

\begin{minted}{xml}
<TextBlock
    Style="{ThemeResource SubtitleTextBlockStyle}"
    Margin="0 20 0 0"
    FontWeight="Normal"
    Text="Preferred Programming Language" />
<Expander
    Margin="0 20 0 0"
    IsExpanded="False">
    <Expander.Header>
        <StackPanel 
            Orientation="Horizontal">
            <ComboBox
                VerticalAlignment="Stretch"
                Margin="2"
                SelectedIndex="0">
                <x:String>C</x:String>
                <x:String>C++</x:String>
                <x:String>Python</x:String>
            </ComboBox>
            <Button 
                x:Name="AddLangButton"
                ToolTipService.ToolTip="Add a new Programming Language configuration"
                Margin="2"
                Click="AddLangButton_Click">
                <Button.Content>
                    <SymbolIcon Symbol="Add"/>
                </Button.Content>
            </Button>
            <Button 
                ToolTipService.ToolTip="Delete the selected configuration"
                Margin="2">
                <Button.Content>
                    <SymbolIcon Symbol="Delete"/>
                </Button.Content>
                <Button.Flyout>
                    <Flyout>
                        <StackPanel>
                            <TextBlock 
                                Style="{ThemeResource BaseTextBlockStyle}"
                                Text="The selected language configuration will be deleted. Do you want to continue?" Margin="0 0 0 12" />
                            <Button 
                                HorizontalAlignment="Right"
                                Content="Yes" />
                        </StackPanel>
                    </Flyout>
                </Button.Flyout>
            </Button>
        </StackPanel>
    </Expander.Header>
    <Expander.Content>
        <StackPanel
            HorizontalAlignment="Stretch"
            MinWidth="400">
            <TextBox
                x:Name="DisplayNameTextBox"
                Header="Display Name"/>
            <TextBox
                x:Name="LanguageCodeTextBox"
                Header="Language Code"
                Margin="0 4 0 0"/>
            <CheckBox
                x:Name="NeedCompileCheckBox"
                Content="Need Compile"
                Margin="0 4 0 0"/>
            <TextBox
                x:Name="CompileCommandTextBox"
                Visibility="{x:Bind NeedCompileCheckBox.IsChecked, Mode=OneWay}"
                Header="Compile Command"
                Margin="0 4 0 0"/>
            <TextBox
                x:Name="CompileArgumentTextBox"
                Visibility="{x:Bind NeedCompileCheckBox.IsChecked, Mode=OneWay}"
                Header="Compile Argument"
                Margin="0 4 0 0"/>
            <TextBox
                x:Name="RunCommandTextBox"
                Header="Run Command"
                Margin="0 4 0 0"/>
            <TextBox
                x:Name="RunArgumentsTextBox"
                Header="Run Arguments"
                Margin="0 4 0 0"/>
            <TextBox
                x:Name="FileExtensionTextBox"
                PlaceholderText=".*"
                Header="File Extension"
                Margin="0 4 0 0"/>
            <StackPanel 
                Margin="0 16 0 0"
                Orientation="Horizontal">
                <Button
                    Content="Save"
                    Style="{ThemeResource AccentButtonStyle}">
                </Button>
            </StackPanel>
        </StackPanel>
    </Expander.Content>
</Expander>
\end{minted}

At the bottom, I put up some links about the project and a disclaimer.

\begin{minted}{xml}
<TextBlock
    Style="{ThemeResource SubtitleTextBlockStyle}"
    Margin="0 20 0 0"
    FontWeight="Normal"
    Text="About" />
<HyperlinkButton 
    Margin="0 4 0 0"
    Content="GitHub"
    NavigateUri="https://github.com/HEIGE-PCloud/Algorithm-Dynamics"/>
<HyperlinkButton 
    Margin="0 4 0 0"
    Content="Website"
    NavigateUri="https://algorithmdynamics.com/"/>
<HyperlinkButton 
    Margin="0 4 0 0"
    Content="Report"
    NavigateUri="https://algorithmdynamics.com/report.pdf"/>
<TextBlock
    Style="{ThemeResource SubtitleTextBlockStyle}"
    Margin="0 20 0 0"
    FontWeight="Normal"
    Text="Disclaimer" />
<RichTextBlock>
    <Paragraph>THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.</Paragraph>
</RichTextBlock>
\end{minted}

All the data should be immediately saved to the disk after the user changes a value. For now, the data will not be saved to the disk as the settings module will not be implemented in this iteration.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{SettingsPage-Light}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{SettingsPage-Dark}

\subsubsection{Testing and validation}

\begin{tabulary}{\linewidth}{|L|l|L|}
    \hline
    Does it load & Pass & \\
    \hline
    Does theme switch work & Pass & \\
    \hline
    Does the run code time limit field work and validate the data & Pass & \\
    \hline
    Does the run code memory limit field work and validate the data & Pass & \\
    \hline
    Does the language configuration editor works & Pass & \\
    \hline
    Does the about buttons work & Pass & \\
    \hline
    Does the settings get loaded and saved correctly & Failed & The core of the settings module will be implemented in a later iteration. \\
    \hline
\end{tabulary}

\subsubsection{Stakeholder feedback}

PCloud says that it will be great if a ``Clear history data'' button is placed in the settings page, so he can reset his statistics or problems easily. This will be a useful feature and very easy to implement.

\begin{minted}{xml}
<StackPanel 
    Margin="0 10 0 0"
    Orientation="Vertical">
    <Button
    x:Name="ClearAllSubmissionsButton"
    Margin="0 4 0 0"
    Content="Clear Submission History">
    <Button.Flyout>
        <Flyout x:Name="ClearAllSubmissionsFlyout">
        <StackPanel>
            <TextBlock 
            Style="{ThemeResource BaseTextBlockStyle}" 
            Text="All submission history will be deleted. Do you want to continue?" 
            Margin="0,0,0,12"/>
            <Button 
            HorizontalAlignment="Right" 
            Content="Yes"
            Click="DeleteAllSubmissions"/>
        </StackPanel>
        </Flyout>
    </Button.Flyout>
    </Button>
    <Button
    x:Name="ClearAllProblemsButton"
    Margin="0 4 0 0"
    Content="Clear All Problems">
    <Button.Flyout>
        <Flyout x:Name="ClearAllProblemsFlyout">
        <StackPanel>
            <TextBlock 
            Style="{ThemeResource BaseTextBlockStyle}" 
            Text="All problems will be deleted. Do you want to continue?" 
            Margin="0,0,0,12"/>
            <Button 
            HorizontalAlignment="Right" 
            Content="Yes"
            Click="DeleteAllProblems"/>
        </StackPanel>
        </Flyout>
    </Button.Flyout>
    </Button>
    <Button
    x:Name="ClearAllDataButton"
    Margin="0 4 0 0"
    Content="Clear All Data">
    <Button.Flyout>
        <Flyout x:Name="ClearAllDataFlyout">
        <StackPanel>
            <TextBlock 
            Style="{ThemeResource BaseTextBlockStyle}" 
            Text="All data will be deleted. Do you want to continue?" 
            Margin="0,0,0,12"/>
            <TextBlock 
            Text="Restart is required."/>
            <Button 
            HorizontalAlignment="Right" 
            Content="Yes"
            Click="ClearAllData"/>
        </StackPanel>
        </Flyout>
    </Button.Flyout>
    </Button>
</StackPanel>
\end{minted}

I add three buttons to the settings page, one to clear all submissions, one to clear all problems, and one to clear all data. They will be connected to the database functions in the later milestone.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{SettingsPage-ClearData}

\subsection{Stakeholder feedback}

My stakeholders are generally very happy about the user interface of the software. They think the prototype looks modern and easy to use. They cannot wait to see the full functionality of the software.

\section{Milestone 2: Implement the data structures and database}

\subsubsection{Implementation and testing}

I decide to create a second project called Algorithm Dynamics.Core to separate the UI code and the core code. This allows me to organize the code base in a cleaner way, and allows me to run unit tests on the core code.

When developing the core code, I decide not to integrate it with the UI right away, since it is very inefficient in testing and debugging. Instead, I will write unit tests for each functions, test everything in isolation, and then integrate the core code with the UI when it is ready.

I decided to create the model and the database structure at the same time, so that I can make sure any change to the data model will be saved correctly into the database, preventing any data inconsistency between the runtime and the database.

I decide to use SQLite\cite{sqlite} as the database since it is a small, fast and light weight database suitable for local data storage. In order to access the database, I use the Microsoft.Data.Sqlite\cite{microsoft:docs:sqlite} database to send my query commands to the local database.

First, I create a test table to test the workflow. Under Algorithm Dynamics.Core.Helpers namespace, I create a class DataAccess. I decide to make it public since it needs to be accessed in order to set the physical location of the database. I decide to make it static since it is essentially a collection of helper functions that depend on each other, but no instance needs to be created in order to call them. I decide to set it to a partial class, since I intend to split functions which handle different data models into different files, so each file only contains a partial of the class.

\begin{minted}{csharp}
using Microsoft.Data.Sqlite;
using System.IO;

namespace Algorithm_Dynamics.Core.Helpers
{
    public static partial class DataAccess
    {
    }
}
\end{minted}

I set up a private attribute \code{DbPath}, which stores the physical location of the database. And a function \code{InitDatabase}, which takes in a string, and init the database at that location.

\begin{minted}{csharp}
/// <summary>
/// Store the physical loaction of the database.
/// Use <see cref="InitializeDatabase(string)"/> to initialize the value.
/// </summary>
private static string DbPath;

/// <summary>
/// Initialize the database at the <see cref="dbPath"/> given.
/// Execute CREATE TABLE commands.
/// </summary>
/// <param name="dbPath"></param>
public static void InitializeDatabase(string dbPath)
{
}
\end{minted}

\begin{minted}{csharp}
public static void InitializeDatabase(string dbPath)
{
    // Save the DbPath
    DbPath = dbPath;

    // Create a new database if not exist
    if (!File.Exists(dbPath))
    {
        File.CreateText(dbPath).Dispose();
    }

    // Create tables
    using (SqliteConnection db = new(ConnectionString))
    {
        db.Open();

        string tableCommand =
            @"CREATE TABLE IF NOT EXISTS MyTable 
            (
                Primary_Key INTEGER PRIMARY KEY,
                Text_Entry TEXT
            );";
        SqliteCommand createTable = new(tableCommand, db);

        createTable.ExecuteNonQuery();
    }
}
\end{minted}

TODO: Implementation

\subsubsection{Integration}

I then needs to integrate the core code with the UI.

On the HomePage, I need to implement the random problem button and the recommendations.

\begin{minted}{csharp}
private void InitializeQAItems()
{
    // ...    
    QAItems.Add(new QuickAccessItem("Random Problem", Symbol.Shuffle, () =>
        {
            // Get all problems from the database
            List<Problem> problems = Problem.All;

            // Generate a random index
            var random = new Random();
            int randomIndex = random.Next(problems.Count);

            // Get the corresponding problem
            Problem problem = problems[randomIndex];

            // Navigate to coding page with the problems as parameters
            App.NavigateTo(typeof(CodingPage), Tuple.Create(problem, problems));
        }));
    // ...
}

/// <summary>
/// Generate Recommendation from database.
/// </summary>
private void InitializeRecItems()
{
    RecItems.Clear();
    // Generate recommend problems
    var problems = Problem.All;
    for (int i = 0; i < problems.Count && i < 4; i++)
    {
        var problem = problems[i];
        RecItems.Add(new RecommendItem(problem.Name, $"{problem.DifficultyAsString} | {problem.TagAsString}", () => { App.NavigateTo(typeof(CodingPage), Tuple.Create(problem, Problem.All)); }));
    }
    // If no item, hide the title
    if (RecItems.Count == 0)
    {
        RecommendTextBlock.Visibility = Visibility.Collapsed;
    }
    else
    {
        RecommendTextBlock.Visibility = Visibility.Visible;
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-Final}

Now, when I click the random problem button, or the recommendations button, I am navigated to the correct problem correctly.

TODO: ProblemsPage

TODO: CreateNewProblemPage

TODO: CreateNewProblemListPage

TODO: CodingPage

TODO: AccountPage

\section{Milestone 3: Implement the Judger}

\subsection{Implementation and testing}

The Judger needs to be initialized with a working directory path for it to store all the temporary files. A folder path and the file name of the source code is taken as arguments.

\begin{minted}{csharp}
/// <summary>
/// Set the SourceCode File with its folder path and its name.
/// </summary>
/// <param name="FolderPath"></param>
/// <param name="FileName"></param>
public static void SetSourceCodeFilePath(string FolderPath, string FileName = "main")
{
    _SourceCodeFolderPath = FolderPath;
    _SourceCodeFilePath = Path.Combine(FolderPath, FileName) + "{SourceCodeFileExtension}";
    _ExecutableFilePath = Path.Combine(FolderPath, FileName) + ".exe";
}
\end{minted}

Next, I started implementing the \code{Compile} function. It is a static function, so it can be called without creating an instance of the class. It is also an async function, so when it is executing, it will not block the main UI thread. This is particularly important as the user interface should stay responsive when the judger is working. It returns a \code{Task<int>} value, which containts the exit code of the compiler.

To allow the user customize the behavior of different compiler, the compile command supports magic variables SourceCodeFileExtension, SourceCodeFilePath and ExecutableFilePath. These variables need to be replaced with the real value before executing.

\begin{minted}{csharp}
/// <summary>
/// Compile the source code in <see cref="_SourceCodeFilePath"/>.
/// </summary>
/// <param name="language">
/// The <see cref="Language.CompileCommand"/> and 
/// <see cref="Language.CompileArguments"/> are used for compilation.
/// Note that the <see cref="Language.NeedCompile"/> is not checked.
/// </param>
/// <returns>The exit code of the compiler is returned.</returns>
private async static Task<int> Compile(Language language)
{
    // Clear old output
    _CompilationOutput = "";
    _CompilationError = "";

    // Set file extension
    string sourceFilePath = _SourceCodeFilePath.Replace("{SourceCodeFileExtension}", language.FileExtension);

    // Create compile process
    Process CompileProcess = new()
    {
        StartInfo = new ProcessStartInfo
        {
            FileName = language.CompileCommand
                .Replace("{SourceCodeFilePath}", sourceFilePath)
                .Replace("{ExecutableFilePath}", _ExecutableFilePath),
            Arguments = language.CompileArguments
                .Replace("{SourceCodeFilePath}", sourceFilePath)
                .Replace("{ExecutableFilePath}", _ExecutableFilePath),
            UseShellExecute = false,
            CreateNoWindow = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            WorkingDirectory = _SourceCodeFolderPath
        },
        EnableRaisingEvents = true
    };

    // Bind event handler
    CompileProcess.OutputDataReceived +=
        new DataReceivedEventHandler(CompileProcess_OutputDataReceived);
    CompileProcess.ErrorDataReceived +=
        new DataReceivedEventHandler(CompileProcess_ErrorDataReceived);

    // Start the process
    CompileProcess.Start();
    CompileProcess.BeginOutputReadLine();
    CompileProcess.BeginErrorReadLine();

    // Wait for exit
    await CompileProcess.WaitForExitAsync();
    return CompileProcess.ExitCode;
}
\end{minted}

Two event handlers are bind to the \code{CompileProcess}. They are simply used to receive the output from the compiler. They are bost set to private to encapsulate from the main program.

\begin{minted}{csharp}
private static void CompileProcess_ErrorDataReceived(object sender, DataReceivedEventArgs e)
{
    if (!string.IsNullOrEmpty(e.Data))
    {
        _CompilationError += e.Data + '\n';
    }
}

private static void CompileProcess_OutputDataReceived(object sender, DataReceivedEventArgs e)
{
    if (!string.IsNullOrEmpty(e.Data))
    {
        _CompilationOutput += e.Data + '\n';
    }
}
\end{minted}

The \code{Execute} procedure follows the same pattern.

\begin{minted}{csharp}
/// <summary>
/// Execute the executable in <see cref="_ExecutableFilePath"/>.
/// </summary>
/// <param name="stdin">The standard input gets feeded to the program.</param>
/// <param name="language">The language config contains the running config.</param>
/// <param name="timeLimit">The time limit for the process.</param>
/// <param name="memoryLimit">The memory limit for the process.</param>
/// <returns></returns>
private async static Task<int> Execute(string stdin, Language language, int timeLimit, long memoryLimit)
{
    // Clear the old data
    _StandardOutput = "";
    _StandardError = "";
    _StatusCode = StatusCode.PENDING;
    _WorkingSet64 = 0;

    // Set file extension
    string sourceFilePath = _SourceCodeFilePath.Replace("{SourceCodeFileExtension}", language.FileExtension);

    // Create the execute process
    Process ExecuteProcess = new()
    {
        StartInfo = new ProcessStartInfo
        {
            FileName = language.RunCommand
                .Replace("{SourceCodeFilePath}", sourceFilePath)
                .Replace("{ExecutableFilePath}", _ExecutableFilePath),
            Arguments = language.RunArguments
                .Replace("{SourceCodeFilePath}", sourceFilePath)
                .Replace("{ExecutableFilePath}", _ExecutableFilePath),
            UseShellExecute = false,
            RedirectStandardInput = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            CreateNoWindow = true,
            WorkingDirectory = _SourceCodeFolderPath
        },
        EnableRaisingEvents = true
    };

    // Bind the event handler
    ExecuteProcess.OutputDataReceived +=
        new DataReceivedEventHandler(ExecuteProcess_OutputDataReceived);
    ExecuteProcess.ErrorDataReceived +=
        new DataReceivedEventHandler(ExecuteProcess_ErrorDataReceived);
    ExecuteProcess.Exited +=
        new EventHandler(ExecuteProcess_Exited);

    // Start running
    ExecuteProcess.Start();
    ExecuteProcess.BeginOutputReadLine();
    ExecuteProcess.BeginErrorReadLine();
    ExecuteProcess.StandardInput.WriteLine(stdin);
    _StatusCode = StatusCode.RUNNING;

    // Wait for exit
    await ExecuteProcess.WaitForExitAsync();
    return ExecuteProcess.ExitCode;
}
\end{minted}

On top of the running procedure, I also need to monitor the memory and time usage, and kill the process when the limit is exceeded.

\begin{minted}{csharp}
// Start the time monitor
Timer timer = new((e) =>
{
    if (_StatusCode == StatusCode.RUNNING && ExecuteProcess.HasExited == false)
    {
        ExecuteProcess.Kill();
        _StatusCode = StatusCode.TIME_LIMIT_EXCEEDED;
    }
}, null, timeLimit, Timeout.Infinite);
\end{minted}

This is a count down timer, it runs on a separate thread, once the time limit is reached, it executes the kill command and record the time limit exceed error.

\begin{minted}{csharp}
// Create the memory monitor
Thread MemoryMonitor = new(() =>
{
    while (ExecuteProcess.HasExited == false)
    {
        ExecuteProcess.Refresh();
        _WorkingSet64 = ExecuteProcess.PeakWorkingSet64;
        if (_WorkingSet64 > memoryLimit)
        {
            ExecuteProcess.Kill();
            _StatusCode = StatusCode.MEMORY_LIMIT_EXCEEDED;
        }
    }
});
\end{minted}

This is a memory monitor, it runs on a separate thread too. It keeps refreshing the process information, and check the memory usage. If the memory usage exceeds the limit, it kills the process and record the memory limit exceed error.

I use a \code{RunCode} function to combime these two steps together, and returns a \code{RunCodeResult} containing all data.

\begin{minted}{csharp}
/// <summary>
/// Run the UserCode with the given data.
/// Use the Progress for reporting progress.
/// </summary>
/// <param name="UserCode"></param>
/// <param name="Input"></param>
/// <param name="language"></param>
/// <param name="TimeLimit"></param>
/// <param name="MemoryLimit"></param>
/// <param name="Progress"></param>
/// <returns></returns>
public async static Task<RunCodeResult> RunCode(string UserCode, string Input, Language language, int TimeLimit, long MemoryLimit, IProgress<int> Progress)
{
    Progress.Report(0);

    // Set file extension
    string sourceFilePath = _SourceCodeFilePath.Replace("{SourceCodeFileExtension}", language.FileExtension);

    // Save the code to the disk
    RunCodeResult result = new();
    Directory.CreateDirectory(_SourceCodeFolderPath);
    await File.WriteAllTextAsync(sourceFilePath, UserCode);

    // Compile if needed
    if (language.NeedCompile)
    {
        // Compile and report any error
        if (await Compile(language) != 0)
        {
            Progress.Report(100);
            result.StandardOutput = _CompilationOutput;
            result.StandardError = FilterErrorMessage(_CompilationError);
            result.ResultCode = ResultCode.COMPILE_ERROR;
            return result;
        }
    }
    // Finish compilation
    Progress.Report(10);

    // Setup watch
    var watch = new Stopwatch();
    watch.Start();

    // Execute the code
    result.ExitCode = await Execute(Input, language, TimeLimit, MemoryLimit);
    
    // Save the results
    watch.Stop();
    result.StandardOutput = _StandardOutput;
    result.StandardError = FilterErrorMessage(_StandardError);
    result.CPUTime = watch.ElapsedMilliseconds;
    result.MemoryUsage = _WorkingSet64;

    // Report complete
    Progress.Report(100);

    return result;
}
\end{minted}

Before the result is returned, its status needs to be determined. I use a series of branching to convert the internal state to a final status code.

\begin{minted}{csharp}
// Handle TLE
if (_StatusCode == StatusCode.TIME_LIMIT_EXCEEDED)
{
    result.ResultCode = ResultCode.TIME_LIMIT_EXCEEDED;
    return result;
}

// Handle MLE
if (_StatusCode == StatusCode.MEMORY_LIMIT_EXCEEDED)
{
    result.ResultCode = ResultCode.MEMORY_LIMIT_EXCEEDED;
    return result;
}

// Handle RE
if (!string.IsNullOrEmpty(result.StandardError) || result.ExitCode != 0)
{
    result.ResultCode = ResultCode.RUNTIME_ERROR;
    return result;
}

// Success
result.ResultCode = ResultCode.SUCCESS;
\end{minted}

To test the basic functionality, I set up two test cases. The code simply outputs hello world and the Judger asserts whether the output is correct. I choose to test on two different programming languages, Python and C++, since Python is an interpreting language and C++ is a compiled language, which tests the Judger's full functionality.

\begin{minted}{csharp}
[TestClass]
public class TestJudger
{
    const int MB = 1024 * 1024;
    const int S = 1000;
    const string helloWorldPy = "print('hello world')";
    const string helloWorldCpp = "#include <iostream>\nusing namespace std;\nint main(){cout << \"hello world\" << endl;}";
    
    [TestInitialize]
    public void SetCodeFilePath()
    {
        Judger.SetSourceCodeFilePath(".", "main");
    }

    /// <summary>
    /// Test running a simple hello world Python program
    /// </summary>
    /// <returns></returns>
    [TestMethod, TestCategory("TestRunCode")]
    public async Task TestRunCodePython()
    {
        RunCodeResult result = await Judger.RunCode(helloWorldPy, "", LanguageConfig.Python, 1 * S, 64 * MB);
        Assert.AreEqual("hello world\n", result.StandardOutput);
        Assert.AreEqual("", result.StandardError);
        Assert.AreEqual(0, result.ExitCode);
        Assert.IsTrue(result.CPUTime < 2 * ms && result.CPUTime > 0);
        Assert.IsTrue(result.MemoryUsage < 128 * MB && result.MemoryUsage > 0);
        Assert.AreEqual(ResultCode.SUCCESS, result.ResultCode);
    }

    /// <summary>
    /// Test running a simple hello world C++ program
    /// </summary>
    /// <returns></returns>
    [TestMethod, TestCategory("TestRunCode")]
    public async Task TestRunCodeCpp()
    {
        RunCodeResult result = await Judger.RunCode(helloWorldCpp, "", LanguageConfig.Cpp, 1 * S, 64 * MB);
        Assert.AreEqual("hello world\n", result.StandardOutput);
        Assert.AreEqual("", result.StandardError);
        Assert.AreEqual(0, result.ExitCode);
        Assert.IsTrue(result.CPUTime < 2 * ms && result.CPUTime > 0);
        Assert.IsTrue(result.MemoryUsage < 128 * MB && result.MemoryUsage > 0);
        Assert.AreEqual(ResultCode.SUCCESS, result.ResultCode);
    }
}
\end{minted}

These tests passed without an issue.

\begin{minted}{text}
> dotnet test --filter TestCategory=TestRunCode
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: 651 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

Next I tested input. I use the simple A + B problem, two integers will be feed to the test code by the judger, and a correct sum should be output.

\begin{minted}{csharp}
const string APlusBPy = "a=int(input())\nb=int(input())\nprint(a+b)";
const string APlusBCpp = "#include <iostream>\nusing namespace std;\nint main(){int a,b;cin>>a>>b;cout<<a+b;}";

/// <summary>
/// Test input processing
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestRunCodeInput")]
public async Task TestRunCodeInputPy()
{
    RunCodeResult result = await Judger.RunCode(APlusBPy, "3\n4", LanguageConfig.Python, 1 * S, 64 * MB);
    Assert.AreEqual("7\n", result.StandardOutput);
    Assert.AreEqual("", result.StandardError);
    Assert.AreEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime < 2 * ms && result.CPUTime > 0);
    Assert.IsTrue(result.MemoryUsage < 128 * MB && result.MemoryUsage > 0);
    Assert.AreEqual(ResultCode.SUCCESS, result.ResultCode);
}

/// <summary>
/// Test input processing
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestRunCodeInput")]
public async Task TestRunCodeInputCpp()
{
    RunCodeResult result = await Judger.RunCode(APlusBCpp, "3\n4", LanguageConfig.Cpp, 1 * S, 64 * MB);
    Assert.AreEqual("7\n", result.StandardOutput);
    Assert.AreEqual("", result.StandardError);
    Assert.AreEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime < 2 * ms && result.CPUTime > 0);
    Assert.IsTrue(result.MemoryUsage < 128 * MB && result.MemoryUsage > 0);
    Assert.AreEqual(ResultCode.SUCCESS, result.ResultCode);
}
\end{minted}

Both tests passed successfully.

\begin{minted}{text}
> dotnet test --filter TestCategory=TestRunCodeInput
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: 796 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

Next, I test the time limit. I input a piece of code that will run an infinite loop. The Judger is expected to kill the process after 1 second and report the correct error.

\begin{minted}{csharp}
const string TLEPy = "while True:\n    pass";
const string TLECpp = "int main(){while(1){}}";

/// <summary>
/// Test time limit exceed
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestTLE")]
public async Task TestTLEPy()
{
    RunCodeResult result = await Judger.RunCode(TLEPy, "", LanguageConfig.Python, 1 * S, 64 * MB);
    Assert.AreEqual("", result.StandardOutput);
    Assert.AreEqual("", result.StandardError);
    Assert.AreNotEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime >= 1 * S);
    Assert.IsTrue(result.MemoryUsage < 128 * MB && result.MemoryUsage > 0);
    Assert.AreEqual(ResultCode.TIME_LIMIT_EXCEEDED, result.ResultCode);
}

/// <summary>
/// Test time limit exceed
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestTLE")]
public async Task TestTLECpp()
{
    RunCodeResult result = await Judger.RunCode(TLECpp, "", LanguageConfig.Cpp, 1 * S, 64 * MB);
    Assert.AreEqual("", result.StandardOutput);
    Assert.AreEqual("", result.StandardError);
    Assert.AreNotEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime >= 1 * S);
    Assert.IsTrue(result.MemoryUsage < 128 * MB && result.MemoryUsage > 0);
    Assert.AreEqual(ResultCode.TIME_LIMIT_EXCEEDED, result.ResultCode);
}
\end{minted}

Both tests passed successfully.

\begin{minted}{text}
> dotnet test --filter TestCategory=TestTLE
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: 2 s - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

Next, I test the memory limit. I input a piece of code that will use a large amount of memory. The Judger is expected to kill the process when the actual memory usage is more than 64 MB.

\begin{minted}{csharp}
const string MLEPy = "a=[1]\nwhile True:\n    a+=a";
const string MLECpp = "const int N = 100000000;int a[N];int main(){for(int i = 0;i<N;i++)a[i]= i;}";

/// <summary>
/// Test memory limit exceed
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestMLE")]
public async Task TestMLEPy()
{
    RunCodeResult result = await Judger.RunCode(MLEPy, "", LanguageConfig.Python, 1 * S, 64 * MB);
    Assert.AreEqual("", result.StandardOutput);
    Assert.AreEqual("", result.StandardError);
    Assert.AreNotEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime < 2 * ms && result.CPUTime > 0);
    Assert.IsTrue(result.MemoryUsage > 64 * MB);
    Assert.AreEqual(ResultCode.MEMORY_LIMIT_EXCEEDED, result.ResultCode);
}

/// <summary>
/// Test memory limit exceed
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestMLE")]
public async Task TestMLECpp()
{
    RunCodeResult result = await Judger.RunCode(MLECpp, "", LanguageConfig.Cpp, 1 * S, 64 * MB, null, true);
    Assert.AreEqual("", result.StandardOutput);
    Assert.AreEqual("", result.StandardError);
    Assert.AreNotEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime < 2 * ms && result.CPUTime > 0);
    Assert.IsTrue(result.MemoryUsage > 64 * MB);
    Assert.AreEqual(ResultCode.MEMORY_LIMIT_EXCEEDED, result.ResultCode);
}
\end{minted}

Next, I test the compile error. I input a piece of code that will not compile. The Judger is expected to collect the error message from the compiler and report it in the result.

\begin{minted}{csharp}
const string CECpp = "ce";

/// <summary>
/// Test compile error
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestCE")]
public async Task TestCE()
{
    RunCodeResult result = await Judger.RunCode(CECpp, "", LanguageConfig.Cpp, 1 * S, 64 * MB);
    Assert.AreEqual("", result.StandardOutput);
    Assert.AreNotEqual("", result.StandardError);
    Assert.AreEqual(0, result.ExitCode);
    Assert.AreEqual(0, result.CPUTime);
    Assert.AreEqual(0, result.MemoryUsage);
    Assert.AreEqual(ResultCode.COMPILE_ERROR, result.ResultCode);
}
\end{minted}

The test passes successfully.

\begin{minted}{text}
> dotnet test --filter TestCategory=TestCE
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: 104 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

Next, I test the runtime error. For interpreting language like Python, the syntax is checked during runtime. The Judger is expected to collect the error message from the intrepreter and report it in the result.

\begin{minted}{csharp}
const string REPy = "re";

/// <summary>
/// Test runtime error
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestRE")]
public async Task TestRE()
{
    RunCodeResult result = await Judger.RunCode(REPy, "", LanguageConfig.Python, 1 * S, 64 * MB);
    Assert.AreEqual("", result.StandardOutput);
    Assert.AreNotEqual("", result.StandardError);
    Assert.AreNotEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime > 0 && result.CPUTime < 2 * S);
    Assert.IsTrue(result.MemoryUsage > 0 && result.MemoryUsage < 64 * MB);
    Assert.AreEqual(ResultCode.RUNTIME_ERROR, result.ResultCode);
}
\end{minted}

The test passed successfully.

\begin{minted}{text}
> dotnet test --filter TestCategory=TestRE
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: 100 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

I then implement the judge test case and judge problem function. This is a pretty straightforward task because I can reuse the entire \code{RunCode} function. On top of the result given by the \code{RunCode} function, I add branch to determine whether the result is correct, and report a wrong answer when the output does not match.

\begin{minted}{csharp}
/// <summary>
/// Judge a TestCase
/// </summary>
/// <param name="UserCode"></param>
/// <param name="TestCase"></param>
/// <param name="Language"></param>
/// <param name="TimeLimit"></param>
/// <param name="MemoryLimit"></param>
/// <returns></returns>
public async static Task<TestCaseResult> JudgeTestCase(string UserCode, TestCase TestCase, Language Language, int TimeLimit, long MemoryLimit)
{
    RunCodeResult runCodeResult = await RunCode(UserCode, TestCase.Input, Language, TimeLimit, MemoryLimit, new Progress<int>());
    
    // Handle WA
    if (runCodeResult.ResultCode == ResultCode.SUCCESS)
    {
        if (runCodeResult.StandardOutput.Trim() != TestCase.Output.Trim())
        {
            runCodeResult.ResultCode = ResultCode.WRONG_ANSWER;
        }
    }

    // Not implemented edit result so must create it at the end
    TestCaseResult result = TestCaseResult.Create(runCodeResult);
    return result;
}
\end{minted}

I set up 2 sets of tests to test the \code{JudgeTestCase} function. The first one test it with a simple hello world code to make sure it is working as intended. The second test it with a wrong answer code, to see whether it reports the correct error.

\begin{minted}{csharp}
/// <summary>
/// Test judge <see cref="TestCase"/>
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestTestCase")]
public async Task TestTestCaseCpp()
{
    DataAccess.InitializeDatabase($"{Guid.NewGuid()}.db");
    TestCase testCase = TestCase.Create("", "hello world\n", false);
    TestCaseResult result = await Judger.JudgeTestCase(helloWorldCpp, testCase, LanguageConfig.Cpp, 1 * S, 64 * MB);
    Assert.AreEqual("hello world\n", result.StandardOutput);
    Assert.AreEqual("", result.StandardError);
    Assert.AreEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime < 2 * S && result.CPUTime > 0);
    Assert.IsTrue(result.MemoryUsage < 128 * MB && result.MemoryUsage > 0);
    Assert.AreEqual(ResultCode.SUCCESS, result.ResultCode);
}

/// <summary>
/// Test Wrong Answer
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestWrongAnswer")]
public async Task TestWrongAnswerPy()
{
    DataAccess.InitializeDatabase($"{Guid.NewGuid()}.db");
    TestCase testCase = TestCase.Create("3\n4\n", "7", false);
    TestCaseResult result = await Judger.JudgeTestCase(WAPy, testCase, LanguageConfig.Python, 1 * S, 64 * MB);
    Assert.AreEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime > 0 && result.CPUTime < 2 * S);
    Assert.IsTrue(result.MemoryUsage > 0 && result.MemoryUsage < 128 * MB);
    Assert.AreEqual(ResultCode.WRONG_ANSWER, result.ResultCode);
    Assert.AreNotEqual("7", result.StandardOutput);
    Assert.AreEqual("", result.StandardError);
}

/// <summary>
/// Test Wrong Answer
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestWrongAnswer")]
public async Task TestWrongAnswerCpp()
{
    DataAccess.InitializeDatabase($"{Guid.NewGuid()}.db");
    TestCase testCase = TestCase.Create("3\n4\n", "7", false);
    TestCaseResult result = await Judger.JudgeTestCase(WACpp, testCase, LanguageConfig.Cpp, 1 * S, 64 * MB);
    Assert.AreEqual(0, result.ExitCode);
    Assert.IsTrue(result.CPUTime > 0 && result.CPUTime < 2 * S);
    Assert.IsTrue(result.MemoryUsage > 0 && result.MemoryUsage < 128 * MB);
    Assert.AreEqual(ResultCode.WRONG_ANSWER, result.ResultCode);
    Assert.AreNotEqual("7", result.StandardOutput);
    Assert.AreEqual("", result.StandardError);
}
\end{minted}

All tests passed successfully.

\begin{minted}{text}
> dotnet test --filter TestCategory="TestWrongAnswer|TestTestCase"
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     4, Skipped:     0, Total:     4, Duration: 2 s - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

To judge a problem, I set up a queue of test cases, judge them one by one, and compose the result at the end.

\begin{minted}{csharp}
/// <summary>
/// Judge a problem submission
/// </summary>
/// <param name="Submission"></param>
/// <param name="Progress"></param>
/// <returns></returns>
public async static Task<SubmissionResult> JudgeProblem(Submission Submission, IProgress<int> Progress)
{
    // Create SubmissionResult
    SubmissionResult Result = SubmissionResult.Create(Submission, new());

    // Set up Judge Queue
    Queue<TestCase> JudgeQueue = new(Submission.Problem.TestCases);

    // Ready to judge, report progress
    Progress.Report(0);

    int testCasesCount = Submission.Problem.TestCases.Count;
    while (JudgeQueue.Count > 0)
    {
        TestCaseResult result = await JudgeTestCase(
            Submission.Code,
            JudgeQueue.Dequeue(),
            Submission.Language,
            Submission.Problem.TimeLimit,
            Submission.Problem.MemoryLimit);

        // Add result
        Result.AddTestCaseResult(result);

        // Report progress
        Progress.Report(100 * (testCasesCount - JudgeQueue.Count) / testCasesCount);
    }

    //Finish Judging
    Progress.Report(100);

    // Update problem status
    if (Result.ResultCode == ResultCode.SUCCESS)
    {
        Submission.Problem.Status = ProblemStatus.Solved;
    }
    else
    {
        if (Submission.Problem.Status == ProblemStatus.Todo)
        {
            Submission.Problem.Status = ProblemStatus.Attempted;
        }
    }

    return Result;
}
\end{minted}

I add a set of simple tests just to see \code{JudgeProblem} is working correctly. I generate 100 test cases for the A + B problem and test it on both Python and C++.

\begin{minted}{csharp}
/// <summary>
/// Test Judge Problem
/// </summary>
/// <returns></returns>
[TestMethod, TestCategory("TestJudgeProblem")]
public async Task TestJudgeProblemPy()
{
    DataAccess.InitializeDatabase($"{Guid.NewGuid()}.db");

    // Generate 1000 A + B test cases
    Random rnd = new();
    List<TestCase> testCases = new();
    for (int i = 0; i < 100; i ++)
    {
        int a = rnd.Next(1000);
        int b = rnd.Next(1000);
        testCases.Add(TestCase.Create($"{a}\n{b}\n", $"{a + b}\n", false));
    }
    
    // Generate problem
    Problem problem = Problem.Create(Guid.NewGuid(), "", "", 1 * S, 64 * MB, Difficulty.Easy, testCases);

    // Generate submission
    User user = DatabaseHelper.CreateNewUser();
    Language language = DatabaseHelper.CreateLanguage("python");
    Submission submission = Submission.Create(APlusBPy, language, user, problem);
    SubmissionResult result = await Judger.JudgeProblem(submission, new Progress<int>());

    // Run tests
    Assert.AreEqual("Success", result.Result);
    Assert.AreEqual(ResultCode.SUCCESS, result.ResultCode);
    Assert.IsTrue(0 < result.CPUTime && result.CPUTime < 1 * S);
    Assert.IsTrue(0 < result.MemoryUsage && result.MemoryUsage < 128 * MB);
}
\end{minted}

Both tests passed successfully.

\begin{minted}{text}
> dotnet test --filter TestCategory="TestJudgeProblem"
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: 11 s - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

After all the testing, I am confident that the Judger module is bug free and ready to be integrated into the main program.

\subsection{Integration}

There are two pages that will use the Judger module, the playground page and the coding page.

For the PlaygroundPage, I only need to handle the run code button. \code{RunCode} is called to run the user's code and the result is returned and displayed in the UI.

\begin{minted}{csharp}
/// <summary>
/// RunCode using <see cref="Judger.RunCode"/>
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private async void RunCodeButton_Click(object sender, RoutedEventArgs e)
{
    // Set the progress bar and button
    var progress = new Progress<int>(percent 
        => { RunCodeProgressBar.Value = percent; });
    RunCodeButton.IsEnabled = false;

    // Run Code
    RunCodeResult result = await Judger.RunCode(
        CodeEditor.Code,
        Input,
        Languages[LanguageComboBox.SelectedIndex],
        _timeLimit,
        _memoryLimit,
        progress);

    // Restore the button and display result
    RunCodeButton.IsEnabled = true;
    StatusTextBlock.Text 
        = $"{result.Result} Time: {result.CPUTime} ms Memory: {result.MemoryUsage / MB} MB";
    OutputBox.Text = result.StandardOutput + result.StandardError;
}
\end{minted}

The PlaygroundPage is workding correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-RunCode}

The RunCode function in the CodingPage is similar. Please reference to the source code for the detailed implementation.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-RunCode}

The submission button creates a formal submission and commit the result to the database.

\begin{minted}{csharp}
/// <summary>
/// Submit the user's code for formal judging
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private async void SubmitCodeButton_Click(object sender, RoutedEventArgs e)
{
    // Create submission
    Submission submission = Submission.Create(CodeEditor.Code, (Language)LanguageComboBox.SelectedItem, App.CurrentUser, _currentProblem);
    
    // Prepare progerss bar and button
    var progress = new Progress<int>(percent => { RunCodeProgressBar.Value = percent; });
    RunCodeButton.IsEnabled = false;
    SubmitCodeButton.IsEnabled = false;

    // Judge problem
    SubmissionResult result = await Judger.JudgeProblem(submission, progress);

    // Restore button
    RunCodeButton.IsEnabled = true;
    SubmitCodeButton.IsEnabled = true;

    // Display the result
    StatusTextBlock.Text = $"{result.Result} Time: {result.CPUTime} ms Memory: {result.MemoryUsage / 1024 / 1024} MB";
    ErrorTextBox.Text = result.StandardError;
    
    // Navigate to stderr
    if (!string.IsNullOrWhiteSpace(result.StandardError))
    {
        IOPivot.SelectedIndex = 2;
    }
    OnPropertyChanged(nameof(Submissions));
    OnPropertyChanged(nameof(ReverseSubmissions));
}
\end{minted}

The submission is graded correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-Submit}

The Judger is implemented and fully tested, I will hand this to the stakeholders for their feedback.

\subsection{Stakeholder feedback}

PCloud reported that the Judger will panic when the language config is not correct. This is a very serious issue, the Judger should not crash in any circumstances. I am able to reproduce it in my environment.

\begin{minted}{text}
Message:
Test method Algorithm_Dynamics.Test.TestJudger.TestRunCodeCpp threw exception:
System.ComponentModel.Win32Exception: An error occurred trying to start process 'g--' with working directory '.'. The system cannot find the file specified.

Stack Trace:
Process.StartWithCreateProcess(ProcessStartInfo startInfo)
Process.Start()
Judger.Compile(Language language) line 66
Judger.RunCode(String UserCode, String Input, Language language, Int32 TimeLimit, Int64 MemoryLimit, IProgress`1 Progress) line 218
TestJudger.TestRunCodeCpp() line 34
ThreadOperations.ExecuteWithAbortSafety(Action action)
\end{minted}

If the compiler does not exist on the path, the Judger will panic directly. This should be handled more gracefully and a proper error should be reported. I can add a check for the compiler existence before running.

I set up a function \code{GetFullPath} to search the local folder and environment variable path for a given file. It returns null if the file is not found.

\begin{minted}{csharp}
/// <summary>
/// Search local and environment variable to get the full path of a file.
/// Return <see cref="null"/> if the file does not exist.
/// </summary>
/// <param name="fileName"></param>
/// <returns></returns>
private static string GetFullPath(string fileName)
{
    // Check whether the file exists in the local folder
    if (File.Exists(fileName))
        return Path.GetFullPath(fileName);

    // Check the environment variable
    var values = Environment.GetEnvironmentVariable("PATH");
    foreach (var path in values.Split(Path.PathSeparator))
    {
        var fullPath = Path.Combine(path, fileName);
        if (File.Exists(fullPath))
            return fullPath;
    }
    return null;
}
\end{minted}

Then I set up another function \code{ExistsOnPath} which returns a boolean value to check whether the compiler exists.

\begin{minted}{csharp}
/// <summary>
/// Check whether a file exist in the local folder or in the environment variable path.
/// </summary>
/// <param name="fileName"></param>
/// <returns></returns>
private static bool ExistsOnPath(string fileName)
{
    return GetFullPath(fileName) != null;
}
\end{minted}

Both method are set to private as they are only intended to be used inside the \code{Judger} class.

Now, I can check whether the compile exists before compiling. A system error will be reported if it encounters error.

\begin{minted}{csharp}
// Compile if needed
if (language.NeedCompile)
{
    // Check if the compiler exists before compiling
    if (!ExistsOnPath(language.CompileCommand.Replace("{SourceCodeFilePath}", sourceFilePath).Replace("{ExecutableFilePath}", _ExecutableFilePath)))
    {
        Progress.Report(100);
        result.StandardError = $"The CompileCommand {language.CompileCommand} cannot be found.\nPlease check the programming language configuration.";
        result.ResultCode = ResultCode.SYSTEM_ERROR;
        return result;
    }

    // Compile and report any error
    if (await Compile(language) != 0)
    {
        Progress.Report(100);
        result.StandardOutput = _CompilationOutput;
        result.StandardError = FilterErrorMessage(_CompilationError);
        result.ResultCode = ResultCode.COMPILE_ERROR;
        return result;
    }
}
\end{minted}

I also add a unit test to verify this error is fixed. It sets up an invalid compiler command and checks whether the Judger will report the correct error message.

\begin{minted}{csharp}
[TestMethod, TestCategory("TestSystemError")]
public async Task TestCompileSystemError()
{
    // Set up a non-exsiting compiler g--
    RunCodeResult result = await Judger.RunCode(
        helloWorldCpp,
        "",
        new("C++", "cpp", ".cpp", true, "g--", "-x c++ {SourceCodeFilePath} -o {ExecutableFilePath}", "{ExecutableFilePath}", ""),
        1 * S,
        64 * MB,
        new Progress<int>()
    );
    // Check the result code and error message
    Assert.AreEqual(result.ResultCode, ResultCode.SYSTEM_ERROR);
    Assert.AreEqual(result.StandardError, $"The CompileCommand g-- cannot be found.\nPlease check the programming language configuration.");
}
\end{minted}

I noticed another issue, the Judger can encounter the same issue when executing as well. For interpreting language like Python, the interpreter is called during execution, so its path must be check before executing as well. Since I have written the function for \code{ExistsOnPath} it is easy to set up another check before executing.

\begin{minted}{csharp}
// Check run command before running
if (!ExistsOnPath(language.RunCommand.Replace("{SourceCodeFilePath}", sourceFilePath).Replace("{ExecutableFilePath}", _ExecutableFilePath)))
{
    Progress.Report(100);
    result.StandardError = $"The RunCommand {language.RunCommand} cannot be found.\nPlease check the programming language configuration.";
    result.ResultCode = ResultCode.SYSTEM_ERROR;
    return result;
}
\end{minted}

I also add the unit test for the execution case.

\begin{minted}{csharp}
[TestMethod, TestCategory("TestSystemError")]
public async Task TestExecuteSystemError()
{
    // Set up a non-exsiting interpreter p
    RunCodeResult result = await Judger.RunCode(
        helloWorldCpp,
        "",
        new("Python", "python", ".py", "p", "{SourceCodeFilePath}"),
        1 * S,
        64 * MB,
        new Progress<int>()
    );
    // Check the result code and error message
    Assert.AreEqual(result.ResultCode, ResultCode.SYSTEM_ERROR);
    Assert.AreEqual(result.StandardError, $"The RunCommand p cannot be found.\nPlease check the programming language configuration.");
}
\end{minted}

Both tests passed successfully.

\begin{minted}{text}
> dotnet test --filter TestCategory=TestSystemError
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: 49 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

I then test it in the integration environment, the error message is displayed correctly and so is the error code.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{SystemErrorReport}

I show this result back to the stakeholder, and he is happy with how I handle this error.

Timofei reports that the judging speed is very slow with multiple test cases on compiling language. After some investigate, I found that the reason is that the same source code gets compiled every time when a teset case is evaludated. I can optimize the \code{RunCode} function to skip compile after the first test case.

\begin{minted}{csharp}
public async static Task<RunCodeResult> RunCode(string UserCode, string Input, Language language, int TimeLimit, long MemoryLimit, IProgress<int> Progress = null, bool skipCompile = false)
{
    // ...

    // Compile if needed
    if (language.NeedCompile && (!skipCompile))
    {
        // ...
    }

    // ...
}
\end{minted}


\begin{minted}{csharp}
public async static Task<SubmissionResult> JudgeProblem(Submission Submission, IProgress<int> Progress)
{
    // ...

    bool skipCompile = false;
    while (JudgeQueue.Count > 0)
    {
        TestCaseResult result = await JudgeTestCase(
            Submission.Code,
            JudgeQueue.Dequeue(),
            Submission.Language,
            Submission.Problem.TimeLimit,
            Submission.Problem.MemoryLimit,
            skipCompile);

        // ...

        // Skip compile
        skipCompile = true;
    }

    // ...
}
\end{minted}

Now each code submission will only get compiled once, and therefore the total judging time is shortened significantly. Timofei is satisfied with this result.

\section{Milestone 4: Handle data import/export}

\subsection{Implementation and testing}

I created public static class in the Algorithm Dynamics.Core project, so it is separated from the main UI logic and can be tested by the unit test framework. I set it as a static class since it is a collection of methods and no need of creating instance.

I first created an ExportObject to wrap any data I am exporting, so the exported data can be validated before importing.

\begin{minted}{csharp}
/// <summary>
/// The base Object container that holds all the other data objects
/// It adds <see cref="FileType"/> and <see cref="DataType"/> info to the data.
/// </summary>
private class ExportObject
{
    public ExportObject(string dataType, object data)
    {
        DataType = dataType;
        Data = data;
    }

    public string FileType { get; set; } = "Algorithm Dynamics Exported Data";
    public string DataType { get; set; }
    public object Data { get; set; }
}
\end{minted}

The \code{ExportObject} adds \code{FileType} and \code{DataType} to the object, and store the actual instance in \code{Data}.

To export a problem, it is converted into an \code{ExportObject}, and gets converted into a JSON string.

\begin{minted}{csharp}
/// <summary>
/// Convert a problem instance into a JSON string ready to be exported.
/// </summary>
/// <param name="problem"></param>
/// <returns></returns>
public static string SerializeProblem(Problem problem)
{
    return JsonSerializer.Serialize(new ExportObject("Problem", problem));
}
\end{minted}

Now I can add tests to Algorithm Dynamics.Test. The data serialization requires the database for the data model, so a new database is initialized for each test case at the beginning.

\begin{minted}{csharp}
using Algorithm_Dynamics.Core.Helpers;
using Algorithm_Dynamics.Core.Models;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.IO;

namespace Algorithm_Dynamics.Test
{
    [TestClass]
    public class TestDataSerialization
    {
        [TestInitialize]
        public void InitDb()
        {
            string path = $"{Guid.NewGuid()}.db";
            File.Delete(path);
            DataAccess.InitializeDatabase(path);
        }

        [TestMethod]
        public void TestSerializeProblem()
        {
            Problem problem = DatabaseHelper.CreateFullProblem();
            
            // Serialize problem
            string str = DataSerialization.SerializeProblem(problem);

            Debug.WriteLine(str);
        }
    }
}
\end{minted}

When executing the test case, the following data is generated.

\begin{minted}{json}
{
    "FileType": "Algorithm Dynamics Exported Data",
    "DataType": "Problem",
    "Data": {
        "Id": 1,
        "Uid": "82a1ac35-f5bb-478f-8a36-50ffc03eab16",
        "Name": "Test Problem 1",
        "Description": "Description 1",
        "TimeLimit": 1000,
        "MemoryLimit": 16777216,
        "Status": 0,
        "StatusAsString": "Todo",
        "Difficulty": 0,
        "DifficultyAsString": "Easy",
        "TestCases": [
            {
                "Id": 1,
                "Input": "Input 3",
                "Output": "Output 3",
                "IsExample": true
            },
            {
                "Id": 2,
                "Input": "Input 5",
                "Output": "Output 5",
                "IsExample": true
            },
            {
                "Id": 3,
                "Input": "Input 7",
                "Output": "Output 7",
                "IsExample": true
            },
            {
                "Id": 4,
                "Input": "Input 9",
                "Output": "Output 9",
                "IsExample": true
            },
            {
                "Id": 5,
                "Input": "Input 11",
                "Output": "Output 11",
                "IsExample": true
            }
        ],
        "Tags": [
            {
                "Id": 1,
                "Name": "Tag 2"
            },
            {
                "Id": 2,
                "Name": "Tag 4"
            },
            {
                "Id": 3,
                "Name": "Tag 6"
            },
            {
                "Id": 4,
                "Name": "Tag 8"
            },
            {
                "Id": 5,
                "Name": "Tag 10"
            }
        ],
        "TagsAsString": "Tag 2, Tag 4, Tag 6, Tag 8, Tag 10",
        "TagAsString": "Tag 2"
    }
}
\end{minted}

The problem with all its metadata and all test cases and tags are exported correctly. However, there are some fields that should not get exported. Such as \code{Id} and \code{Status}. Because when importing the data, all these fields will be regenerated any way, exporting them is just a waste of space.

I can add the \code{[JsonIgnore]} attribute to the fields that should not be exported.

Now when I test it again, only the necessary fields are exported.

\begin{minted}{json}
{
    "FileType": "Algorithm Dynamics Exported Data",
    "DataType": "Problem",
    "Data": {
        "Uid": "425f417f-0a9b-44e5-9e78-6c15d76ee4f2",
        "Name": "Test Problem 1",
        "Description": "Description 1",
        "TimeLimit": 1000,
        "MemoryLimit": 16777216,
        "Difficulty": 0,
        "TestCases": [
            {
                "Input": "Input 3",
                "Output": "Output 3",
                "IsExample": true
            },
            {
                "Input": "Input 5",
                "Output": "Output 5",
                "IsExample": true
            },
            {
                "Input": "Input 7",
                "Output": "Output 7",
                "IsExample": true
            },
            {
                "Input": "Input 9",
                "Output": "Output 9",
                "IsExample": true
            },
            {
                "Input": "Input 11",
                "Output": "Output 11",
                "IsExample": true
            }
        ],
        "Tags": [
            {
                "Name": "Tag 2"
            },
            {
                "Name": "Tag 4"
            },
            {
                "Name": "Tag 6"
            },
            {
                "Name": "Tag 8"
            },
            {
                "Name": "Tag 10"
            }
        ]
    }
}
\end{minted}

I implemented a similar export function for exporting a problem list.

\begin{minted}{csharp}
/// <summary>
/// Convert a problem list instance into a JSON string ready to be exported.
/// </summary>
/// <param name="problemList"></param>
/// <returns></returns>
public static string SerializeProblemList(ProblemList problemList)
{
    return JsonSerializer.Serialize(new ExportObject("ProblemList", problemList));
}
\end{minted}

And similarly, I add a test case for the problem list.

\begin{minted}{csharp}
[TestMethod]
public void TestSerializeProblemList()
{
    ProblemList problemList = DatabaseHelper.CreateFullProblemList();
    
    // Serialize problem list
    string str = DataSerialization.SerializeProblemList(problemList);

    Debug.WriteLine(str);
}
\end{minted}

When running the test, the problem list is exported correctly, with only necessary fields.

\begin{minted}{json}
{
    "FileType": "Algorithm Dynamics Exported Data",
    "DataType": "ProblemList",
    "Data": {
        "Name": "Problem List 1",
        "Description": "Description 1",
        "Problems": [
            {
                "Uid": "cd6edee3-479c-4833-b8b3-7aa955514cba",
                "Name": "Test Problem 2",
                "Description": "Description 2",
                "TimeLimit": 2000,
                "MemoryLimit": 33554432,
                "Difficulty": 0,
                "TestCases": [
                    {
                        "Input": "Input 4",
                        "Output": "Output 4",
                        "IsExample": true
                    },
                    {
                        "Input": "Input 6",
                        "Output": "Output 6",
                        "IsExample": true
                    }
                ],
                "Tags": [
                    {
                        "Name": "Tag 3"
                    },
                    {
                        "Name": "Tag 5"
                    }
                ]
            },
            {
                "Uid": "e207230d-a10d-4f76-bf5c-08273687dacc",
                "Name": "Test Problem 13",
                "Description": "Description 13",
                "TimeLimit": 13000,
                "MemoryLimit": 218103808,
                "Difficulty": 0,
                "TestCases": [
                    {
                        "Input": "Input 15",
                        "Output": "Output 15",
                        "IsExample": true
                    },
                    {
                        "Input": "Input 17",
                        "Output": "Output 17",
                        "IsExample": true
                    }
                ],
                "Tags": [
                    {
                        "Name": "Tag 14"
                    },
                    {
                        "Name": "Tag 16"
                    }
                ]
            }
        ]
    }
}
\end{minted}

Now, the export function is implemented and tested. To import the data, is data type is first checked and validated, then it is passed to the corresponding function to deserialize into an instance of the object.

I create a \code{GetDataType} function to retrieve the data type and validate the file format.

\begin{minted}{csharp}
/// <summary>
/// Get data type (problem/problem list) of an import data file.
/// </summary>
/// <param name="str"></param>
/// <returns></returns>
/// <exception cref="FormatException">The data format is invalid</exception>
public static string GetDataType(string str)
{
    var @base = JsonSerializer.Deserialize<ExportObject>(str);
    if (@base.FileType != "Algorithm Dynamics Exported Data")
        throw new FormatException($"The FileType {@base.FileType} is invalid.");

    if (@base.DataType != "Problem" && @base.DataType != "ProblemList")
        throw new FormatException($"The DataType {@base.DataType} is invalid.");
    return @base.DataType;
}
\end{minted}

\code{GetDataType} should throw \code{FormatException} whenever the file format is invalid. I added two tests to test the exceptions.

\begin{minted}{csharp}
[TestMethod, TestCategory("TestFormatException")]
[ExpectedException(typeof(FormatException))]
public void TestInvalidFileType()
{
    DataSerialization.GetDataType("{\"FileType\":\"Wrong Data\",\"DataType\":\"Problem\",\"Data\":{}}");
}

[TestMethod, TestCategory("TestFormatException")]
[ExpectedException(typeof(FormatException))]
public void TestInvalidDataType()
{
    DataSerialization.GetDataType("{\"FileType\":\"Algorithm Dynamics Exported Data\",\"DataType\":\"Wrong Data Type\",\"Data\":{}}");
}
\end{minted}

They each has incorrect data type or file type, and a \code{FormatException} is thrown.

\begin{minted}{text}
> dotnet test --filter TestCategory=TestFormatException
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: 204 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

Both tests are passed successfully.

To deserialize the data, I need to first retrieve the data from the \code{ExportObject} instance, and return it to the caller.

\begin{minted}{csharp}
/// <summary>
/// Convert a valid JSON string into a problem
/// </summary>
/// <param name="str"></param>
/// <returns></returns>
public static Problem DeserializeProblem(string str)
{
    // Convert the string into the base model
    var @base = JsonSerializer.Deserialize<ExportObject>(str);

    // Read the problem data from the base data
    var problem = JsonSerializer.Deserialize<Problem>(@base.Data.ToString());

    return problem;
}
\end{minted}

Next, I add a full test case for serializing and deserializing a problem.

\begin{minted}{csharp}
[TestMethod]
public void TestSerializeProblem()
{
    Problem problem = DatabaseHelper.CreateFullProblem();
    
    // Serialize problem
    string str = DataSerialization.SerializeProblem(problem);

    // Check data type
    Assert.AreEqual("Problem", DataSerialization.GetDataType(str));

    // Deserialize problem
    Problem result = DataSerialization.DeserializeProblem(str);
    
    // Check properties
    Assert.AreNotEqual(result.Id, problem.Id);
    Assert.AreEqual(result.Uid, problem.Uid);
    Assert.AreEqual(problem.Name, result.Name);
    Assert.AreEqual(problem.Description, result.Description);
    Assert.AreEqual(problem.TimeLimit, result.TimeLimit);
    Assert.AreEqual(problem.MemoryLimit, result.MemoryLimit);
    Assert.AreEqual(problem.Difficulty, result.Difficulty);
    
    // Check tags
    Assert.AreEqual(problem.Tags.Count, result.Tags.Count);
    for (int i = 0; i < problem.Tags.Count; i++)
    {
        Assert.AreEqual(problem.Tags[i].Name, result.Tags[i].Name);
    }
    
    // Check test cases
    Assert.AreEqual(problem.TestCases.Count, result.TestCases.Count);
    for (int i = 0; i < problem.TestCases.Count; i++)
    {
        Assert.AreEqual(problem.TestCases[i].Input, result.TestCases[i].Input);
        Assert.AreEqual(problem.TestCases[i].Output, result.TestCases[i].Output);
    }
}
\end{minted}

It generates a new problem, serialize it into a JSON string, deserialize from the JSON string into an instance, and compare the new instance and the original instance. The test passes when they are the same.

However, when I run the test, it fails with the following error.

\begin{minted}{text}
Message: 
Test method Algorithm_Dynamics.Test.TestDataSerialization.TestSerializeProblem threw exception: 
System.NotSupportedException: Deserialization of types without a parameterless constructor, a singular parameterized constructor, or a parameterized constructor annotated with 'JsonConstructorAttribute' is not supported. Type 'Algorithm_Dynamics.Core.Models.Problem'. Path: $ | LineNumber: 0 | BytePositionInLine: 1. ---> System.NotSupportedException: Deserialization of types without a parameterless constructor, a singular parameterized constructor, or a parameterized constructor annotated with 'JsonConstructorAttribute' is not supported. Type 'Algorithm_Dynamics.Core.Models.Problem'.

Stack Trace: 
ThrowHelper.ThrowNotSupportedException(ReadStack& state, Utf8JsonReader& reader, NotSupportedException ex)
ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(Type type, Utf8JsonReader& reader, ReadStack& state)
ObjectDefaultConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)
JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)
JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state)
JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 utf8Json, JsonTypeInfo jsonTypeInfo, Nullable`1 actualByteCount)
JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 json, JsonTypeInfo jsonTypeInfo)
JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)
DataSerialization.DeserializeProblem(String str) line 117
TestDataSerialization.TestSerializeProblem() line 32
\end{minted}

The deserializer requires a custom constructor to create an object. Instead of changing the existing design of the Problem model. I decide to create a base problem model to retrieve the data, and then convert the base mode into a full problem model.

\begin{minted}{csharp}
/// <summary>
/// The base test case model to hold the import data.
/// </summary>
private class BaseTestCase
{
    public string Input { get; set; }
    public string Output { get; set; }
    public bool IsExample { get; set; }
}

/// <summary>
/// The base tag model to hold the import data.
/// </summary>
private class BaseTag
{
    public string Name { get; set; }
}

/// <summary>
/// The base problem model to hold the import data
/// </summary>
private class BaseProblem
{
    public string Uid { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public int TimeLimit { get; set; }
    public int MemoryLimit { get; set; }
    public int Difficulty { get; set; }
    public List<BaseTestCase> TestCases { get; set; }
    public List<BaseTag> Tags { get; set; }
}
\end{minted}

These base models only have the fields that gets exported. I decide to set them as private classes since it is only used for the deserializer internally, other classes do not need to access it .The deserializer first saves the data into the base problem model.

\begin{minted}{csharp}
public static Problem DeserializeProblem(string str)
{
    // Convert the string into the base model
    var @base = JsonSerializer.Deserialize<ExportObject>(str);

    // Read the problem data from the base data
    var baseProblem = JsonSerializer.Deserialize<BaseProblem>(@base.Data.ToString());
}
\end{minted}

Next, the data in the base model is used to create actual problem model.

\begin{minted}{csharp}
// Create test cases and tags first
List<TestCase> testCases = new();
List<Tag> tags = new();
foreach (BaseTestCase t in baseProblem.TestCases)
{
    testCases.Add(TestCase.Create(t.Input, t.Output, t.IsExample));
}
foreach (BaseTag t in baseProblem.Tags)
{
    tags.Add(Tag.Create(t.Name));
}

// Create the problem next and return it
return Problem.Create(
    Guid.Parse(baseProblem.Uid),
    baseProblem.Name,
    baseProblem.Description,
    baseProblem.TimeLimit,
    baseProblem.MemoryLimit,
    (Difficulty)baseProblem.Difficulty,
    testCases,
    tags);
\end{minted}

Now I run the tests again, the test passed successfully.

\begin{minted}{text}
> dotnet test --filter TestCategory=TestSerialize
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: 569 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

I used a similar approach to handle the problem list. First create the base problem list model.

\begin{minted}{csharp}
/// <summary>
/// The base problem list 
/// </summary>
private class BaseProblemList
{
    public string Name { get; set; }
    public string Description { get; set; }
    public List<BaseProblem> Problems { get; set; }
}
\end{minted}

Next deserialize to the base model and then create the actual model from the base model.

\begin{minted}{csharp}
/// <summary>
/// Convert a valid JSON string into a problem list
/// </summary>
/// <param name="str"></param>
/// <returns></returns>
public static ProblemList DeserializeProblemList(string str)
{
    // Convert the string into the base model
    var @base = JsonSerializer.Deserialize<ExportObject>(str);

    // Read the problem list data from the base data
    var baseProblemList = JsonSerializer.Deserialize<BaseProblemList>(@base.Data.ToString());
    List<Problem> problems = new();
    foreach (BaseProblem p in baseProblemList.Problems)
    {
        // Create problem from the problem list data
        List<TestCase> testCases = new();
        List<Tag> tags = new();
        foreach (BaseTestCase t in p.TestCases)
        {
            testCases.Add(TestCase.Create(t.Input, t.Output, t.IsExample));
        }
        foreach (BaseTag t in p.Tags)
        {
            tags.Add(Tag.Create(t.Name));
        }

        // Add to the problem list
        problems.Add(
            Problem.Create(
                Guid.Parse(p.Uid),
                p.Name,
                p.Description,
                p.TimeLimit,
                p.MemoryLimit,
                (Difficulty)p.Difficulty,
                testCases,
                tags
            )
        );
    }
    return ProblemList.Create(baseProblemList.Name, baseProblemList.Description, problems);
}
\end{minted}

Finally add tests for the problem list.

\begin{minted}{csharp}
[TestMethod, TestCategory("TestSerialize")]
public void TestSerializeProblemList()
{
    ProblemList problemList = DatabaseHelper.CreateFullProblemList();
    
    // Serialize problem list
    string str = DataSerialization.SerializeProblemList(problemList);
    
    // Check data type
    Assert.AreEqual("ProblemList", DataSerialization.GetDataType(str));

    // Deserialize problem list
    ProblemList result = DataSerialization.DeserializeProblemList(str);
    
    // Check problem list metadata
    Assert.AreNotEqual(result.Id, problemList.Id);
    Assert.AreEqual(problemList.Name, result.Name);
    Assert.AreEqual(problemList.Description, result.Description);
    Assert.AreEqual(problemList.Problems.Count, result.Problems.Count);
    
    // Check problem data
    for (int i = 0; i < problemList.Problems.Count; i++)
    {
        var expected = problemList.Problems[i];
        var actual = result.Problems[i];
        Assert.AreNotEqual(expected.Id, actual.Id);
        Assert.AreEqual(expected.Uid, actual.Uid);
        Assert.AreEqual(expected.Name, actual.Name);
        Assert.AreEqual(expected.Description, actual.Description);
        Assert.AreEqual(expected.TimeLimit, actual.TimeLimit);
        Assert.AreEqual(expected.MemoryLimit, actual.MemoryLimit);
        Assert.AreEqual(expected.Difficulty, actual.Difficulty);
        
        // Check tag data
        Assert.AreEqual(expected.Tags.Count, actual.Tags.Count);
        for (int j = 0; j < expected.Tags.Count; j++)
        {
            Assert.AreEqual(expected.Tags[j].Name, actual.Tags[j].Name);
        }

        // Check test case data
        Assert.AreEqual(expected.TestCases.Count, actual.TestCases.Count);
        for (int j = 0; j < expected.TestCases.Count; j++)
        {
            Assert.AreEqual(expected.TestCases[j].Input, actual.TestCases[j].Input);
            Assert.AreEqual(expected.TestCases[j].Output, actual.TestCases[j].Output);
        }
    }
}
\end{minted}

Now when I run the tests, both of them passed successfully.

\begin{minted}{text}
> dotnet test --filter TestCategory=TestSerialize
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.0.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: 1 s - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

\subsection{Integration}

Since the data serialization helper passes all the unit tests successfully, I am confident that it contains no issue and I can integrate them directly into the main project.

The user can import data from either the homepage or the problems page.

On the homepage, I add an action for the quick access item, which will be invoked when the user click the grid item.

\begin{minted}{csharp}
QAItems.Add(new QuickAccessItem("Import", Symbol.Import, async () =>
{
    IReadOnlyList<StorageFile> files = await FileHelper.FileOpenPicker(".json");
    if (files.Count > 0)
    {
        foreach (StorageFile file in files)
        {
            // Read data
            string data = await FileIO.ReadTextAsync(file);

            // Get data type
            string dataType = DataSerialization.GetDataType(data);

            // Deserialize the data and save to the database
            if (dataType == "Problem")
            {
                DataSerialization.DeserializeProblem(data);
            }
            else if (dataType == "ProblemList")
            {
                DataSerialization.DeserializeProblemList(data);
            }
        }
    }
\end{minted}

The \code{FileOpenPicker} is a helper function to open a Windows dialog allowing the user to pick multiple JSON files.

\begin{minted}{csharp}
internal async static Task<IReadOnlyList<StorageFile>> FileOpenPicker(string fileTypeFilter = "*")
{
    // https://github.com/microsoft/WindowsAppSDK/issues/1188
    // https://docs.microsoft.com/en-us/windows/uwp/files/quickstart-using-file-and-folder-pickers
    var filePicker = new FileOpenPicker();

    // Get the current window's HWND by passing in the Window object
    var hwnd = WindowNative.GetWindowHandle(App.m_window);

    // Associate the HWND with the file picker
    InitializeWithWindow.Initialize(filePicker, hwnd);

    // Use file picker like normal!
    filePicker.FileTypeFilter.Add(fileTypeFilter);
    IReadOnlyList<StorageFile> files = await filePicker.PickMultipleFilesAsync();
    return files;
}
\end{minted}

Now when I click the import button on the HomePage, a dialog shows up correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-Import}

When I click open, the three problems are imported correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-Import}

However, when I try to import an invalid problem, the app crashes. This is an expected behavior since I have not handled the exception properly yet. I use a try catch block to handle the exception. If any exception happens, a dialog will show up and display the reason why the import is unsuccessful.

\begin{minted}{csharp}
try
{
    // Read data
    string data = await FileIO.ReadTextAsync(file);
    
    // Get data type
    string dataType = DataSerialization.GetDataType(data);

    // Deserialize the data and save to the database
    if (dataType == "Problem")
    {
        DataSerialization.DeserializeProblem(data);
    }
    else if (dataType == "ProblemList")
    {
        DataSerialization.DeserializeProblemList(data);
    }
}
catch (Exception e)
{
    // Show an dialog with the error message
    ContentDialog dialog = new()
    {
        Title = $"An error was encountered while importing {file.DisplayName}",
        PrimaryButtonText = "Ok",
        Content = $"The following error is encountered:\n\n{e.Message}",
        DefaultButton = ContentDialogButton.Primary,
        XamlRoot = Content.XamlRoot
    };
    await dialog.ShowAsync();
}
\end{minted}

Now, if I attempted to import something invalid, this dialog will show up and abort the import.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-Import-Error}

I connect the same function to the import button on the ProblemsPage. The actual code is very similar so check out the \hyperref[subsubsec:problemspage]{source code} for details.

The user can export a problem or a problem list from the ProblemsPage.

\begin{minted}{csharp}
/// <summary>
/// Export problem to a JSON file
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private async void ExportProblem(object sender, RoutedEventArgs e)
{
    // Get selected problem
    Problem problem = ProblemsListView.SelectedItem as Problem;
    
    // Set file name
    string fileName = $"{problem.Name} Export";
    
    // Serialize problem
    string serializedProblem = DataSerialization.SerializeProblem(problem);
    
    // Save problem
    await FileHelper.FileSavePicker("Algorithm Dynamics Export File", new() { ".json" }, fileName, serializedProblem);
}

/// <summary>
/// Export problem list to a JSON file
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private async void ExportProblemList(object sender, RoutedEventArgs e)
{
    // Get selected problem list
    ProblemList problemList = ListComboBox.SelectedItem as ProblemList;
    
    // Set file name
    string fileName = $"{problemList.Name} Export";
    
    // Serialize problem
    string serializedProblem = DataSerialization.SerializeProblemList(problemList);
    
    // Save problem list
    await FileHelper.FileSavePicker("Algorithm Dynamics Export File", new() { ".json" }, fileName, serializedProblem);
}
\end{minted}

It is very easy to serialize the data, since the data serialization helper I wrote before has done most of the work. I only need to read the selected problem, seralize it and save it to the disk.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-Export}

The data is saved to the disk correctly after I clicking the save button.

The user can export problem list directly from the CreateNewProblemListPage as well. The implementation is very similar, check out the source code for details.

\subsection{Stakeholder feedback}

I asked my stakeholders to test the data import/export function. They are pretty happy about its implementation. PCloud says that he is particularly satisfied because the speed of the import/export is very fast. He can import a large amount of data instantly. Timofei says he is happy about how the import is abort and a useful error message is dispalyed when the data is invalid. Mr Grimwood gives a suggestion that the app should navigate to the ProblemsPage once the import on the homepage is completed, so he can check out the data he imports right away. I think this is a very sensible feature, and it is easy to implement.

\begin{minted}{csharp}
// Deserialize the data and save to the database
if (dataType == "Problem")
{
    DataSerialization.DeserializeProblem(data);
}
else if (dataType == "ProblemList")
{
    DataSerialization.DeserializeProblemList(data);
}

// Navigate to ProblemsPage on success
App.NavigateTo(typeof(ProblemsPage));
\end{minted}

Now the app will navigate the problem page when the import is completed. Mr Grimwood is satisfied about this feature.

\section{Milestone 5: Handle settings}

I designed a JSON schema to store the settings in a file in the design section, but after looking through some documentation, I found a better way of storing settings on Windows. I can use local app data store\cite{microsoft:docs:store-and-retrieve-app-data} to store the settings. Comparing to store the settings in JSON, this brings several advantages: the lifecycle of the settings files are managed by Windows, so when the app gets uninstalled, there will not be garbage settings file flying around the user's disk; the user also can't mess around the settings file directly, which reduces the risk of invalid settings; the data is stored in binary instead of plain text file, which saves disk space. Consider all these benefits, I decide to use \code{LocalSettings} container to store the settings.

\subsection{Theme settings}

The color theme of the app needs to be loaded when the app starts. So in App.xaml.cs, I added logic to handle this in \code{OnLaunched}.

\begin{minted}{csharp}
protected override async void OnLaunched(LaunchActivatedEventArgs args)
{
    // ...
    InitializeTheme();
}

private static void InitializeTheme()
{
    // Load theme
    ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
    var CurrentThemeValue = localSettings.Values["Theme"];

    // if there exists a theme setting, use the theme setting
    // otherwise set the default theme and save it to the setting
    ElementTheme theme;
    if (CurrentThemeValue != null)
    {
        theme = (ElementTheme)CurrentThemeValue;
    }
    else
    {
        theme = ElementTheme.Default;
        localSettings.Values["Theme"] = (int)theme;
    }

    // Apply theme to rootElement
    if (m_window.Content is FrameworkElement rootElement)
    {
        rootElement.RequestedTheme = theme;
    }
}
\end{minted}

In SettingsPage, I need to initialize the current theme on load, and save the selected theme to the setting when the check boxes are checked.

\begin{minted}{csharp}
public SettingsPage()
{
    InitializeComponent();
    // Init theme settings on load
    GetCurrentTheme();
    // ...
}

/// <summary>
/// Get the current theme and set the check box
/// </summary>
private void GetCurrentTheme()
{
    if (App.m_window.Content is FrameworkElement rootElement)
    {
        string currentTheme = rootElement.RequestedTheme.ToString();
        ThemePanel
            .Children
            .Cast<RadioButton>()
            .FirstOrDefault(c => c?.Tag?.ToString() == currentTheme)
            .IsChecked = true;
    }
}

/// <summary>
/// Change the application request theme to the selected theme when the radio button is clicked
/// Save the theme into settings
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ThemeRadioButton_Checked(object sender, RoutedEventArgs e)
{
    var selectedTheme = ((RadioButton)sender)?.Tag?.ToString();

    if (selectedTheme != null && App.m_window.Content is FrameworkElement rootElement)
    {
        rootElement.RequestedTheme = GetEnum<ElementTheme>(selectedTheme);
        ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
        localSettings.Values["Theme"] = (int)rootElement.RequestedTheme;
    }
}
\end{minted}

When I navigate to the settings page, the check box is checked on the current theme correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{SettingsPage-InitTheme}

After I change the setting and relaunch the app, the setting is saved correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{SettingsPage-SaveTheme}

\subsection{TimeLimit settings}

In the SettingsPage, I add a public attribute \code{TimeLimit}, its setter and getter reads and saves its value directly to the local setting container. After the user input the number, it is first validated by the number box control, then it gets saved directly to the setting, which makes the user experience seemless.

\begin{minted}{csharp}
/// <summary>
/// The RunCode TimeLimit value
/// </summary>
public int TimeLimit
{
    get
    {
        // Read time limit from settings
        // If does not exist, store the default time limit
        ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
        var CurrentValue = localSettings.Values[TIMELIMIT_KEY];
        if (CurrentValue != null)
        {
            return (int)CurrentValue;
        }
        else
        {
            localSettings.Values[TIMELIMIT_KEY] = DEFAULT_RUN_CODE_TIMELIMIT;
            return DEFAULT_RUN_CODE_TIMELIMIT;
        }
    }
    set
    {
        // Update the setting
        ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
        localSettings.Values[TIMELIMIT_KEY] = value;
    }
}
\end{minted}

If an invalid input is receive, it is automatically rejected and the value is unchanged.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{SettingsPage-TimeLimit-InvalidInput}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{SettingsPage-TimeLimit-Save}

In the PlaygroundPage, the value for the TimeLimit setting is read and applied.

\begin{minted}{csharp}
/// <summary>
/// RunCode using <see cref="Judger.RunCode"/>
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private async void RunCodeButton_Click(object sender, RoutedEventArgs e)
{
    ApplicationDataContainer localSettings 
        = ApplicationData.Current.LocalSettings;
    // Read RunCode TimeLimit from settings
    var CurrentTimeLimit = localSettings.Values[TIMELIMIT_KEY];
    if (CurrentTimeLimit != null)
    {
        _timeLimit = (int)CurrentTimeLimit;
    }
    else
    {
        localSettings.Values[TIMELIMIT_KEY] 
            = DEFAULT_RUN_CODE_TIMELIMIT;
    }

    // ... RunCode logic
}
\end{minted}

The process is killed after 2000ms in the PlaygroundPage.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-RunCodeTimeLimit}

\subsection{MemoryLimit settings}

Similar to the TimeLimit setting, I first add \code{MemoryLimit} to the SettingsPage.

\begin{minted}{csharp}
/// <summary>
/// The RunCode MemoryLimit value
/// </summary>
public int MemoryLimit
{
    get
    {
        // Read memory limit from settings
        // If does not exist, store the default memory limit
        ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
        var CurrentValue = localSettings.Values[MEMORYLIMIT_KEY];
        if (CurrentValue != null)
        {
            return (int)CurrentValue / MB;
        }
        else
        {
            localSettings.Values[MEMORYLIMIT_KEY] = DEFAULT_RUN_CODE_MEMORYLIMIT;
            return DEFAULT_RUN_CODE_MEMORYLIMIT / MB;
        }
    }
    set
    {
        // Update the setting
        ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
        localSettings.Values[MEMORYLIMIT_KEY] = value * MB;
    }
}
\end{minted}

Then load it from the PlaygroundPage.

\begin{minted}{csharp}
// Read RunCode MemoryLimit from settings
var CurrentMemoryLimit = localSettings.Values[MEMORYLIMIT_KEY];
if (CurrentMemoryLimit != null)
{
    _memoryLimit = (int)CurrentMemoryLimit;
}
else
{
    localSettings.Values[MEMORYLIMIT_KEY] 
        = DEFAULT_RUN_CODE_MEMORYLIMIT;
}

// Run Code
RunCodeResult result = await Judger.RunCode(
    CodeEditor.Code,
    Input,
    Languages[LanguageComboBox.SelectedIndex],
    _timeLimit,
    _memoryLimit,
    progress);
\end{minted}

The process is killed after exceeding 32 MB memory usage, which means the memory limit setting is working correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{PlaygroundPage-RunCodeMemoryLimit}

\subsection{Current User settings}

The settings also store an item that cannot be edited directly, the current user id. All user data is stored in the database, the current user id in the settings determines what gets recorded to the code submissions record and the greeting meesage on HomePage.

In App.xaml.cs, I created a global method to get the current id, so it can be used easily anywhere in the app.

\begin{minted}{csharp}
/// <summary>
/// Get the current user.
/// </summary>
public static User CurrentUser
{
    get
    {
        ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
        Guid uid = (Guid)localSettings.Values["CurrentUser"];
        return User.Get(uid);
    }
}
\end{minted}

In HomePage.xaml.cs, I get the current user name and display it on the screen.

\begin{minted}{csharp}
private void SetWelcomeMessage()
{
    // Get current user name
    string userName = "User";
    if (App.CurrentUser != null)
    {
        userName = App.CurrentUser.Name;
    }

    // Set WelcomeMessage
}
\end{minted}

The currect user value is only set on the first startup. When creating the user in the welcome page, the user id should also be stored into the settings.

\begin{minted}{csharp}
/// <summary>
/// Create a new user and store <see cref="User.Uid"/> into settings
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void CreateUserButton_Click(object sender, RoutedEventArgs e)
{
    // Create user
    User user = User.Create(UserName, Email, Role);

    // Set current user
    ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
    localSettings.Values["CurrentUser"] = user.Uid;

    // Navigate to HomePage
    WelcomeGrid.Visibility = Visibility.Collapsed;
    MainNavView.SelectedItem = MainNavView.MenuItems[0];
}
\end{minted}

Hence, all functions related to the local settings are implemented and tested.

\subsection{Stakeholder feedback}

The stakeholders are very satisfied about all the settings options and how they can be changed and loaded seemlessly.

\section{Milestone 6: Handle API calls}

By following the instructions of the Microsoft Graph API documentation\cite{microsoft:docs:education-overview}, I login the Graph Explorer\cite{microsoft:graph-explorer} and run a \code{GET} query over the \code{/education/schools} endpoint. However, I received a 400 bad request.

\begin{minted}{json}
{
    "error": {
        "code": "Request_UnsupportedQuery",
        "message": "Property 'extension_fe2174665583431c953114ff7268b7b3_Education_ObjectType' does not exist as a declared property or extension property.",
        "innerError": {
            "date": "2022-03-16T23:57:05",
            "request-id": "1bc8bdfa-ee27-48fd-9e89-7d2a3c5352f6",
            "client-request-id": "76d647a4-e41c-7da1-02e6-77bd39398e72"
        }
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{GraphExplorerBadRequest}

After some investigation, I must have an admin account of an education organization in order to call these education APIs.

I then tried my school account, which belongs to an education organization.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{EducationAPINeedApproval}

But unfortunately, my student account is not an admin, and therefore has no permission to call these APIs as well.

Consider that it is impossible for me to register as an education organization, and it is impossible for me to ask for an admin account from my school, the integration with Microsoft Teams for Education is not possible to implement.

Even if I can use these API, the Judging security issue which I mentioned before still applies. Therefore I decide not implement this part of the project. All of my stakeholders express that they understand this limitation and they agree with my decision.

\end{document}