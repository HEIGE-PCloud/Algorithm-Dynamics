\documentclass[report.tex]{subfiles}
\graphicspath{ \subfix{./images/} \subfix{./graphs/} }
\begin{document}
\section{Milestone 2: Implement the data structures and database}

\subsection{Implementation and testing}

I decided to create a second project called Algorithm Dynamics.Core to separate the UI code and the core code. This allows me to organize the codebase more cleanly and allows me to run unit tests on the core code.

When developing the core code, I decide not to integrate it with the UI right away, since it is very inefficient in testing and debugging. Instead, I will write unit tests for each function, test everything in isolation, and then integrate the core code with the UI when it is ready.

I decided to create the model and the database structure at the same time, so that I can make sure any change to the data model will be saved correctly into the database, preventing any data inconsistency between the runtime and the database.

I decide to use SQLite\cite{sqlite} as the database since it is a small, fast and lightweight database suitable for local data storage. To access the database, I use Microsoft.Data.Sqlite\cite{microsoft:docs:sqlite} database bindings to send my query commands to the local database.

First, I create a test table to test the workflow. Under Algorithm Dynamics.Core.Helpers namespace, I create a class DataAccess. I decide to make it public since it needs to be accessed to set the physical location of the database. I decide to make it static since it is essentially a collection of helper functions that depend on each other, but no instance needs to be created to call them. I decide to set it to a partial class since I intend to split functions that handle different data models into different files, so each file only contains a part of the class.

\begin{minted}{csharp}
using Microsoft.Data.Sqlite;
using System.IO;

namespace Algorithm_Dynamics.Core.Helpers
{
    public static partial class DataAccess
    {
    }
}
\end{minted}

I set up a private attribute \code{DbPath}, which stores the physical location of the database. And a function \code{InitDatabase}, which takes in a string, and init the database at that location. A test table is created to verify that the database is working.

\begin{minted}{csharp}
/// <summary>
/// Store the physical loaction of the database.
/// Use <see cref="InitializeDatabase(string)"/> to initialize the value.
/// </summary>
private static string ConnectionString;

/// <summary>
/// Initialize the database at the <see cref="dbPath"/> given.
/// Execute CREATE TABLE commands.
/// </summary>
/// <param name="dbPath"></param>
public static void InitializeDatabase(string dbPath)
{
    ConnectionString = $"Data Source={dbPath}";

    // Create a new database if not exist
    if (!File.Exists(dbPath))
    {
        File.CreateText(dbPath).Dispose();
    }

    // Create tables
    using (SqliteConnection db = new(ConnectionString))
    {
        db.Open();

        string tableCommand =
            @"CREATE TABLE IF NOT EXISTS MyTable 
            (
                Primary_Key INTEGER PRIMARY KEY,
                Text_Entry TEXT
            );";
        SqliteCommand createTable = new(tableCommand, db);

        createTable.ExecuteNonQuery();
    }
}
\end{minted}

I set up two methods for the test data, to insert and query data.

\begin{minted}{csharp}
/// <summary>
/// Add a text data into the test table in the database.
/// This procedure is used for testing the function of the database.
/// </summary>
/// <param name="inputText"></param>
internal static void AddData(string inputText)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand insertCommand = new();
        insertCommand.Connection = conn;

        insertCommand.CommandText = "INSERT INTO MyTable VALUES (NULL, @Entry);";
        insertCommand.Parameters.AddWithValue("@Entry", inputText);

        insertCommand.ExecuteReader();

    }
}

/// <summary>
/// Get all data in the test table in the database.
/// This function is used for testing the function of the database.
/// </summary>
/// <returns></returns>
internal static List<string> GetData()
{
    List<string> entries = new();

    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand selectCommand = new("SELECT Text_Entry from MyTable", conn);

        using (var reader = selectCommand.ExecuteReader())
        {
            while (reader.Read())
            {
                entries.Add(reader.GetString(0));
            }
        }
    }

    return entries;
}
\end{minted}

Finally, I write a test class to test the database and the test table.

\begin{minted}{csharp}
using Algorithm_Dynamics.Core.Helpers;
using Algorithm_Dynamics.Core.Models;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.IO;

namespace Algorithm_Dynamics.Test
{
    [TestClass]
    public class TestDataAccess
    {
        const int MB = 1024 * 1024;

        /// <summary>
        /// Create a temp database with unique name for testing
        /// </summary>
        [TestInitialize]
        public void InitDb()
        {
            string path = $"{Guid.NewGuid()}.db";
            File.Delete(path);
            DataAccess.InitializeDatabase(path);
        }

        /// <summary>
        /// Clean up all temp databases after testing
        /// </summary>
        [AssemblyCleanup]
        public static void AssemblyCleanup()
        {
            foreach (string path in Directory.GetFiles(".", "*.db"))
            {
                File.Delete(path);
            }
        }

        /// <summary>
        /// Insert a single data into the test table
        /// </summary>
        [TestMethod]
        public void TestSingleData()
        {
            DataAccess.AddData("Text1");
            Assert.AreEqual(DataAccess.GetData().Count, 1);
            Assert.AreEqual(DataAccess.GetData()[0], "Text1");
        }
    }
}
\end{minted}

In the TestSingleData method, I insert a single piece of data into the test table using the AddData method. I then verify that the data is inserted correctly by using the GetData method.

The test passed successfully.

\begin{minted}{text}
> dotnet test --filter TestSingleData
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.1.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: 110 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

Now I have verified that the database and database bindings are working correctly, I can create real data models in a similar parttern: create table, add methods, add unit tests. I will use the Problem, Tag, and TestCase data models as an example. They represent a many-to-one relationship and a many-to-many relationship. Other data models are created similarly and please reference the source code for details.

I will start with the TestCase. I use the factory pattern to create a TestCase object. Instead of using the constructor to create a TestCase object, I expose a static method \code{Create} to initialize a TestCase object and also create it in the database. An internal constructor is used to initialize the object internally.

\begin{minted}{csharp}
public class TestCase
{
    internal TestCase(int id, string input, string output, bool isExample)
    {
        _id = id;
        _input = input;
        _output = output;
        _isExample = isExample;
    }

    /// <summary>
    /// Create a new <see cref="TestCase"/> and save it into the databse.
    /// </summary>
    /// <param name="input"></param>
    /// <param name="output"></param>
    /// <param name="isExample"></param>
    /// <returns></returns>
    public static TestCase Create(string input, string output, bool isExample)
    {
        return DataAccess.AddTestCase(input, output, isExample);
    }
}
\end{minted}

I create getters and setters for each properties of the TestCase class. A private _prop is used to store the actual value and a public Prop is used to expose the value.

\begin{minted}{csharp}
private void UpdateDatabase()
{
    DataAccess.EditTestCase(_id, _input, _output, _isExample);
}
private int _id;
public int Id { get => _id; private set => _id = value; }

private string _input;
public string Input
{
    get => _input;
    set
    {
        if (value == _input)
        {
            _input = value;
            UpdateDatabase();
        }
    }
}

private string _output;
public string Output
{
    get => _output;
    set
    {
        if (value != _output)
        {
            _output = value;
            UpdateDatabase();
        }
    }
}

private bool _isExample;
public bool IsExample
{
    get => _isExample;
    set
    {
        if (value != _isExample)
        {
            _isExample = value;
            UpdateDatabase();
        }
    }
}
\end{minted}

The UpdateDatabase method saves the changes to the database. This Id has a private setter since the Id property can only be changed when it is created.

I can simply add SQL commands in the DataAccess class to create the tables for TestCase.

\begin{minted}{csharp}
// Create TestCase table
tableCommand +=
    @"CREATE TABLE IF NOT EXISTS TestCase
    (
        Id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
        Input TEXT NOT NULL,
        Output TEXT NOT NULL,
        IsExample INTEGER NOT NULL,
        ProblemId INTEGER,
        FOREIGN KEY (ProblemId) REFERENCES Problem (Id)
    );";
\end{minted}


After completing the TestCase model, I can implement the underlying database methods. There 4 methods I need to implement, AddTestCase creates a new test case and saves it to the database, GetAllTestCases returns all test cases in the database, EditTestCase edits an existing test case and saves it to the database, and DeleteTestCase deletes a test case from the database.

\begin{minted}{csharp}
/// <summary>
/// Pass in a <see cref="TestCase"/> without <see cref="TestCase.Id"/>.
/// Save the <see cref="TestCase"/> into database and return a <see cref="TestCase"/> with Id.
/// </summary>
/// <param name="testCase"></param>
/// <param name="problemId"></param>
/// <returns></returns>
internal static TestCase AddTestCase(string input, string output, bool isExample, int? problemId = null)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand insertCommand = new();
        insertCommand.Connection = conn;

        insertCommand.CommandText = "INSERT INTO TestCase (Input, Output, IsExample, ProblemId) VALUES (@Input, @Output, @IsExample, @ProblemId);";
        insertCommand.Parameters.AddWithValue("@Input", input);
        insertCommand.Parameters.AddWithValue("@Output", output);
        insertCommand.Parameters.AddWithValue("@IsExample", isExample);
        insertCommand.Parameters.AddWithValue("@ProblemId", problemId == null ? DBNull.Value : problemId);

        insertCommand.ExecuteNonQuery();

        SqliteCommand selectIdCommand = new("SELECT last_insert_rowid();", conn);
        var query = selectIdCommand.ExecuteReader();
        query.Read();
        return new TestCase(query.GetInt32(0), input, output, isExample);
    }
}

/// <summary>
/// Return all test cases in the database as a list
/// </summary>
/// <returns></returns>
internal static List<TestCase> GetAllTestCases()
{
    List<TestCase> testCases = new();

    using (SqliteConnection connection = new(ConnectionString))
    {
        connection.Open();

        SqliteCommand selectCommand = new("SELECT * from TestCase", connection);

        SqliteDataReader query = selectCommand.ExecuteReader();

        while (query.Read())
        {
            testCases.Add(new(query.GetInt32(0), query.GetString(1), query.GetString(2), query.GetBoolean(3)));
        }
    }
    return testCases;
}

/// <summary>
/// Edit an existing test case with the given id
/// </summary>
/// <param name="id"></param>
/// <param name="newInput"></param>
/// <param name="newOutput"></param>
/// <param name="newIsExample"></param>
/// <param name="newProblemId"></param>
internal static void EditTestCase(int id, string newInput, string newOutput, bool newIsExample, int? newProblemId = null)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand updateCommand = new();
        updateCommand.Connection = conn;

        updateCommand.CommandText = "UPDATE TestCase SET Input = @newInput, Output = @newOutput, IsExample = @newIsExample, ProblemId = @newProblemId WHERE Id = @Id;";
        updateCommand.Parameters.AddWithValue("@newInput", newInput);
        updateCommand.Parameters.AddWithValue("@newOutput", newOutput);
        updateCommand.Parameters.AddWithValue("@newIsExample", newIsExample);
        updateCommand.Parameters.AddWithValue("@newProblemId", newProblemId == null ? DBNull.Value : newProblemId);
        updateCommand.Parameters.AddWithValue("@Id", id);

        updateCommand.ExecuteNonQuery();
    }
}

/// <summary>
/// Delete a test case with the given id
/// </summary>
/// <param name="id"></param>
internal static void DeleteTestCase(int id)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand deleteCommand = new();
        deleteCommand.Connection = conn;
        deleteCommand.CommandText = "DELETE FROM TestCase WHERE Id = @Id";
        deleteCommand.Parameters.AddWithValue("@Id", id);
        deleteCommand.ExecuteNonQuery();
    }
}
\end{minted}

Finally, I add the following three tests to check whether the methods are working.

\begin{minted}{csharp}
[TestMethod]
public void TestAddTestCase()
{
    TestCase testCase1 = TestCase.Create("input", "output", true);
    Assert.AreEqual(testCase1, DataAccess.GetAllTestCases()[0]);
}

[TestMethod]
public void TestEditTestCase()
{
    TestCase testCase = TestCase.Create("input", "output", true);
    testCase.Input = "newInput";
    testCase.Output = "newOutput";
    testCase.IsExample = false;
    Assert.AreEqual(testCase, DataAccess.GetAllTestCases()[0]);
}

[TestMethod]
public void TestDeleteTestCase()
{
    TestCase testCase = TestCase.Create("input", "output", true);
    testCase.Delete();
    Assert.AreEqual(0, DataAccess.GetAllTestCases().Count);
}
\end{minted}

However, when I run the tests, I encountered the following errors:

\begin{minted}{text}
> dotnet test --filter "Name~TestCase"
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.1.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.
  Failed TestAddTestCase [123 ms]
  Error Message:
   Assert.AreEqual failed. Expected:<Algorithm_Dynamics.Core.Models.TestCase>. Actual:<Algorithm_Dynamics.Core.Models.TestCase>.
  Stack Trace:
     at Algorithm_Dynamics.Test.TestDataAccess.TestAddTestCase() in C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\TestDataAccess.cs:line 141

  Failed TestEditTestCase [44 ms]
  Error Message:
   Assert.AreEqual failed. Expected:<Algorithm_Dynamics.Core.Models.TestCase>. Actual:<Algorithm_Dynamics.Core.Models.TestCase>.
  Stack Trace:
     at Algorithm_Dynamics.Test.TestDataAccess.TestEditTestCase() in C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\TestDataAccess.cs:line 151

Failed!  - Failed:     2, Passed:     1, Skipped:     0, Total:     7, Duration: 2 s - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

The EditTestCase and AddTestCase tests are failed. After setting a few breakpoints and watches the actual value. I find that the actual value in the instance is actually correct. But when dotnet is comparing these two intances, they are considered to be different. One possible solution is to override the Equals method of the TestCase class, so dotnet can determine whether two instances are equal correctly.

\begin{minted}{csharp}
/// <summary>
/// Determine whether two testcases are the same
/// </summary>
/// <param name="obj"></param>
/// <returns></returns>
public override bool Equals(object obj)
{
    if (obj is not TestCase testCase)
        return false;
    return Id == testCase.Id && Input == testCase.Input && Output == testCase.Output && IsExample == testCase.IsExample;
}

public override int GetHashCode()
{
    return HashCode.Combine(Id, Input, Output, IsExample);
}
\end{minted}

Now when I run the tests again, it passes without any problem.

\begin{minted}{text}
> dotnet test --filter "Name~TestCase"
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.1.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3, Duration: 863 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

To implement the Tag and the Problem models, I follow the same steps.

Create tables:

\begin{minted}{csharp}
// Create Problem table
tableCommand +=
    @"CREATE TABLE IF NOT EXISTS Problem
    (
        Id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
        Uid TEXT NOT NULL,
        Name TEXT NOT NULL,
        Description TEXT NOT NULL,
        TimeLimit INTEGER NOT NULL,
        MemoryLimit INTEGER NOT NULL,
        Status INTEGER NOT NULL,
        Difficulty INTEGER NOT NULL
    );";

// CREATE Tag table
tableCommand +=
    @"CREATE TABLE IF NOT EXISTS Tag
    (
        Id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
        Name TEXT NOT NULL UNIQUE
    );";
\end{minted}

Create models:

\begin{minted}{csharp}
public class Problem
{
    internal Problem(
        int id,
        Guid uid,
        string name,
        string description,
        int timeLimit,
        long memoryLimit,
        ProblemStatus status,
        Difficulty difficulty,
        List<TestCase> testCases,
        List<Tag> tags)
    {
        _id = id;
        _uid = uid;
        _name = name;
        _description = description;
        _timeLimit = timeLimit;
        _memoryLimit = memoryLimit;
        _status = status;
        _difficulty = difficulty;
        _testCases = testCases;
        _tags = tags;
    }

    private int _id;
    public int Id
    {
        get => _id;
        private set => _id = value;
    }

    private Guid _uid;
    public Guid Uid
    {
        get => _uid;
        private set => _uid = value;
    }

    private string _name;
    public string Name
    {
        get => _name;
        set
        {
            if (_name != value)
            {
                _name = value;
                UpdateDatabase();
            }
        }
    }

    private string _description;
    public string Description
    {
        get => _description;
        set
        {
            if (_description != value)
            {
                _description = value;
                UpdateDatabase();
            }
        }
    }

    private int _timeLimit;
    public int TimeLimit
    {
        get => _timeLimit;
        set
        {
            if (_timeLimit != value)
            {
                _timeLimit = value;
                UpdateDatabase();
            }
        }
    }

    private long _memoryLimit;
    public long MemoryLimit
    {
        get => _memoryLimit;
        set
        {
            if (_memoryLimit != value)
            {
                _memoryLimit = value;
                UpdateDatabase();
            }
        }
    }

    private ProblemStatus _status;
    public ProblemStatus Status
    {
        get => _status;
        set
        {
            if (_status != value)
            {
                _status = value;
                UpdateDatabase();
            }
        }
    }

    private Difficulty _difficulty;
    public Difficulty Difficulty
    {
        get => _difficulty;
        set
        {
            if (_difficulty != value)
            {
                _difficulty = value;
                UpdateDatabase();
            }
        }
    }

    /// <summary>
    /// Update database, save all the data in attributes into the database.
    /// </summary>
    private void UpdateDatabase()
    {
        DataAccess.EditProblem(
        _id,
        _name,
        _description,
        _timeLimit,
        _memoryLimit,
        _status,
        _difficulty);
    }
}
\end{minted}

\begin{minted}{csharp}
public class Tag
{
    internal Tag(int id, string name)
    {
        Id = id;
        Name = name;
    }

    public int Id { get; }
    public string Name { get; set; }

    /// <summary>
    /// Create a new <see cref="Tag"/> with a name, and an auto-generated <see cref="Id"/> and save to the Database.
    /// The <see cref="Name"/> is unique, so if a tag exists in the database, it will be returned directly.
    /// </summary>
    /// <param name="name"></param>
    /// <returns></returns>
    public static Tag Create(string name)
    {
        if (DataAccess.TagExists(name))
        {
            return DataAccess.GetTag(name);
        }
        else
        {
            return DataAccess.AddTag(name);
        }
    }
}
\end{minted}

Add database queries:

\begin{minted}{csharp}
/// <summary>
/// Create a new problem in the database
/// and return that instance
/// </summary>
/// <param name="uid"></param>
/// <param name="name"></param>
/// <param name="description"></param>
/// <param name="timeLimit"></param>
/// <param name="memoryLimit"></param>
/// <param name="status"></param>
/// <param name="difficulty"></param>
/// <param name="testCases"></param>
/// <param name="tags"></param>
/// <returns></returns>
internal static Problem AddProblem(Guid uid, string name, string description, int timeLimit, long memoryLimit, ProblemStatus status, Difficulty difficulty, List<TestCase> testCases, List<Tag> tags)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand insertCommand = new();
        insertCommand.Connection = conn;

        insertCommand.CommandText = "INSERT INTO Problem (Uid, Name, Description, TimeLimit, MemoryLimit, Status, Difficulty) VALUES (@Uid, @Name, @Description, @TimeLimit, @MemoryLimit, @Status, @Difficulty);";
        insertCommand.Parameters.AddWithValue("@Uid", uid);
        insertCommand.Parameters.AddWithValue("@Name", name);
        insertCommand.Parameters.AddWithValue("@Description", description);
        insertCommand.Parameters.AddWithValue("@TimeLimit", timeLimit);
        insertCommand.Parameters.AddWithValue("@MemoryLimit", memoryLimit);
        insertCommand.Parameters.AddWithValue("@Status", status);
        insertCommand.Parameters.AddWithValue("@Difficulty", difficulty);

        insertCommand.ExecuteNonQuery();

        SqliteCommand selectIdCommand = new("SELECT last_insert_rowid();", conn);
        var query = selectIdCommand.ExecuteReader();
        query.Read();
        return new Problem(query.GetInt32(0), uid, name, description, timeLimit, memoryLimit, status, difficulty, testCases, tags);
    }
}

/// <summary>
/// Get the problem with the given id
/// </summary>
/// <param name="Id"></param>
/// <returns></returns>
/// <exception cref="KeyNotFoundException"></exception>
internal static Problem GetProblem(int Id)
{
    Problem problem;
    using (var connection = new SqliteConnection(ConnectionString))
    {
        connection.Open();
        SqliteCommand selectCommand = new();
        selectCommand.Connection = connection;
        selectCommand.CommandText = "SELECT * FROM Problem WHERE Id = @Id";
        selectCommand.Parameters.AddWithValue("@Id", Id);
        SqliteDataReader query = selectCommand.ExecuteReader();

        if (query.Read())
        {
            int id = query.GetInt32(0);
            Guid uid = query.GetGuid(1);
            string name = query.GetString(2);
            string description = query.GetString(3);
            int timeLimit = query.GetInt32(4);
            int memoryLimit = query.GetInt32(5);
            ProblemStatus status = (ProblemStatus)query.GetInt32(6);
            Difficulty difficulty = (Difficulty)query.GetInt32(7);
            problem = new(id, uid, name, description, timeLimit, memoryLimit, status, difficulty, GetTestCases(id), GetTags(id));
        }
        else
        {
            throw new KeyNotFoundException($"The Problem with Id = {Id} is not found in the database.");
        }
    }
    return problem;
}

/// <summary>
/// Get all Problems under a ProblemList
/// </summary>
/// <returns></returns>
internal static List<Problem> GetProblems(int problemListId)
{
    List<Problem> problems = new();
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand selectCommand = new();
        selectCommand.Connection = conn;
        selectCommand.CommandText = "SELECT ProblemListRecord.ProblemId, Problem.Uid, Problem.Name, Problem.Description, Problem.TimeLimit, Problem.MemoryLimit, Problem.Status, Problem.Difficulty FROM ProblemListRecord INNER JOIN Problem ON ProblemListRecord.ProblemId = Problem.Id WHERE ProblemListId = @ProblemListId";
        selectCommand.Parameters.AddWithValue("@ProblemListId", problemListId);
        SqliteDataReader query = selectCommand.ExecuteReader();

        while (query.Read())
        {
            int id = query.GetInt32(0);
            Guid uid = query.GetGuid(1);
            string name = query.GetString(2);
            string description = query.GetString(3);
            int timeLimit = query.GetInt32(4);
            int memoryLimit = query.GetInt32(5);
            ProblemStatus status = (ProblemStatus)query.GetInt32(6);
            Difficulty difficulty = (Difficulty)query.GetInt32(7);
            problems.Add(new Problem(id, uid, name, description, timeLimit, memoryLimit, status, difficulty, GetTestCases(id), GetTags(id)));
        }
    }
    return problems;
}

/// <summary>
/// Edit a given problem data
/// </summary>
/// <param name="id"></param>
/// <param name="name"></param>
/// <param name="description"></param>
/// <param name="timeLimit"></param>
/// <param name="memoryLimit"></param>
/// <param name="status"></param>
/// <param name="difficulty"></param>
internal static void EditProblem(int id, string name, string description, int timeLimit, long memoryLimit, ProblemStatus status, Difficulty difficulty)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand updateCommand = new();
        updateCommand.Connection = conn;
        updateCommand.CommandText = "UPDATE Problem SET Name = @Name, Description = @Description, TimeLimit = @TimeLimit, MemoryLimit = @MemoryLimit, Status = @Status, Difficulty = @Difficulty WHERE Id = @Id;";
        updateCommand.Parameters.AddWithValue("@Name", name);
        updateCommand.Parameters.AddWithValue("@Description", description);
        updateCommand.Parameters.AddWithValue("@TimeLimit", timeLimit);
        updateCommand.Parameters.AddWithValue("@MemoryLimit", memoryLimit);
        updateCommand.Parameters.AddWithValue("@Status", status);
        updateCommand.Parameters.AddWithValue("@Difficulty", difficulty);
        updateCommand.Parameters.AddWithValue("@Id", id);

        updateCommand.ExecuteNonQuery();
    }
}

/// <summary>
/// Return all problems in the database
/// </summary>
/// <returns></returns>
internal static List<Problem> GetAllProblems()
{
    List<Problem> problems = new();

    using (SqliteConnection connection = new(ConnectionString))
    {
        connection.Open();

        SqliteCommand selectCommand = new("SELECT * from Problem", connection);

        SqliteDataReader query = selectCommand.ExecuteReader();

        while (query.Read())
        {
            int id = query.GetInt32(0);
            Guid uid = query.GetGuid(1);
            string name = query.GetString(2);
            string description = query.GetString(3);
            int timeLimit = query.GetInt32(4);
            int memoryLimit = query.GetInt32(5);
            ProblemStatus status = (ProblemStatus)query.GetInt32(6);
            Difficulty difficulty = (Difficulty)query.GetInt32(7);
            problems.Add(new(id, uid, name, description, timeLimit, memoryLimit, status, difficulty, GetTestCases(id), GetTags(id)));
        }

    }
    return problems;
}

/// <summary>
/// Delete the given problem
/// </summary>
/// <param name="id"></param>
internal static void DeleteProblem(int id)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand deleteCommand = new();
        deleteCommand.Connection = conn;
        deleteCommand.CommandText = "DELETE FROM Problem WHERE Id = @Id";
        deleteCommand.Parameters.AddWithValue("@Id", id);
        deleteCommand.ExecuteNonQuery();
    }
}
\end{minted}

\begin{minted}{csharp}
/// <summary>
/// Pass in a <see cref="Tag"/> without <see cref="Tag.Id"/>.
/// Save the <see cref="Tag"/> into database and return a <see cref="Tag"/> with Id.
/// </summary>
/// <param name="testCase"></param>
/// <param name="problemId"></param>
/// <returns></returns>
internal static Tag AddTag(string name)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand insertCommand = new();
        insertCommand.Connection = conn;
        insertCommand.CommandText = "INSERT INTO Tag (Name) VALUES (@Name);";
        insertCommand.Parameters.AddWithValue("@Name", name);
        insertCommand.ExecuteNonQuery();

        SqliteCommand selectIdCommand = new("SELECT last_insert_rowid();", conn);
        var query = selectIdCommand.ExecuteReader();
        query.Read();
        return new Tag(query.GetInt32(0), name);
    }
}

/// <summary>
/// Return all tags in the database
/// </summary>
/// <returns></returns>
internal static List<Tag> GetAllTags()
{
    List<Tag> tags = new();

    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand selectCommand = new("SELECT * from Tag", conn);

        SqliteDataReader query = selectCommand.ExecuteReader();

        while (query.Read())
        {
            tags.Add(new(query.GetInt32(0), query.GetString(1)));
        }
    }
    return tags;
}

/// <summary>
/// Determine whether a tag is exist
/// </summary>
/// <param name="name"></param>
/// <returns></returns>
internal static bool TagExists(string name)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand selectCommand = new();
        selectCommand.Connection = conn;
        selectCommand.CommandText = "SELECT EXISTS (SELECT 1 FROM Tag WHERE Name = @Name)";
        selectCommand.Parameters.AddWithValue("@Name", name);

        SqliteDataReader query = selectCommand.ExecuteReader();
        query.Read();
        return query.GetBoolean(0);
    }
}

/// <summary>
/// Get the tag with given id
/// </summary>
/// <param name="id"></param>
/// <returns></returns>
internal static Tag? GetTag(int id)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand selectCommand = new();
        selectCommand.Connection = conn;
        selectCommand.CommandText = "SELECT * FROM Tag WHERE Id = @Id";
        selectCommand.Parameters.AddWithValue("@Id", id);

        SqliteDataReader query = selectCommand.ExecuteReader();
        if (query.Read())
        {
            return new Tag(query.GetInt32(0), query.GetString(1));
        }
        else
        {
            return null;
        }
    }
}

/// <summary>
/// Get the tag with the given name
/// </summary>
/// <param name="name"></param>
/// <returns></returns>
internal static Tag GetTag(string name)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand selectCommand = new();
        selectCommand.Connection = conn;
        selectCommand.CommandText = "SELECT * FROM Tag WHERE Name = @Name";
        selectCommand.Parameters.AddWithValue("@Name", name);

        SqliteDataReader query = selectCommand.ExecuteReader();
        if (query.Read())
        {
            return new Tag(query.GetInt32(0), query.GetString(1));
        }
        else
        {
            return null;
        }
    }
}

/// <summary>
/// Delete a Tag from the Tag table. You need to check whether there exists a tag record first.
/// </summary>
/// <param name="id"></param>
internal static void DeleteTag(int id)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand deleteCommand = new();
        deleteCommand.Connection = conn;
        deleteCommand.CommandText = "DELETE FROM Tag WHERE Id = @Id";
        deleteCommand.Parameters.AddWithValue("@Id", id);
        deleteCommand.ExecuteNonQuery();
    }
}
\end{minted}

Finally add test cases to these models.

\begin{minted}{csharp}
[TestMethod]
public void TestAddTag()
{
    Tag tag = Tag.Create("tag");
    Assert.AreEqual(tag, DataAccess.GetAllTags()[0]);
}

[TestMethod]
public void TestTagExists()
{
    Assert.AreEqual(false, DataAccess.TagExists("tag"));
    Tag.Create("tag");
    Assert.AreEqual(true, DataAccess.TagExists("tag"));
}

[TestMethod]
public void TestGetTag()
{
    Tag tag = Tag.Create("tag");
    Assert.AreEqual(tag, DataAccess.GetTag(tag.Id));
    Assert.AreEqual(tag, DataAccess.GetTag(tag.Name));
    Assert.AreEqual(null, DataAccess.GetTag("Non-exist Tag"));
    Assert.AreEqual(null, DataAccess.GetTag(100));
}
\end{minted}


\begin{minted}{csharp}
[TestMethod]
public void TestCreateProblem()
{
    TestCase testCase1 = TestCase.Create("input1", "output1", true);
    TestCase testCase2 = TestCase.Create("input2", "output2", false);

    Tag tag1 = Tag.Create("tag1");
    Tag tag2 = Tag.Create("tag2");
    var testCases = new List<TestCase>() { testCase1, testCase2 };
    var tags = new List<Tag>() { tag1, tag2 };
    Problem problem = Problem.Create(Guid.NewGuid(), "Test Problem", "Description", 1000, 64 * MB, Difficulty.Easy, testCases, tags);
    Assert.AreEqual(problem, DataAccess.GetProblem(problem.Id));
}

[TestMethod]
public void TestEditProblem()
{
    Problem problem = Problem.Create(Guid.NewGuid(), "Test Problem", "Description", 1000, 64 * MB, Difficulty.Easy);
    problem.Name = "New name";
    problem.Description = "New description";
    problem.TimeLimit = 2000;
    problem.MemoryLimit = 128 * MB;
    problem.Difficulty = Difficulty.Easy;
    problem.Status = ProblemStatus.Solved;
    Assert.AreEqual(problem, DataAccess.GetProblem(problem.Id));
}

[TestMethod]
public void TestGetAllProblems()
{
    TestCase testCase1 = TestCase.Create("input1", "output1", true);
    TestCase testCase2 = TestCase.Create("input2", "output2", false);

    Tag tag1 = Tag.Create("tag1");
    Tag tag2 = Tag.Create("tag2");
    var testCases1 = new List<TestCase>() { testCase1 };
    var testCases2 = new List<TestCase>() { testCase2 };
    var tags = new List<Tag>() { tag1, tag2 };
    Problem problem = Problem.Create(Guid.NewGuid(), "Test Problem", "Description", 1000, 64 * MB, Difficulty.Easy, testCases1, tags);
    Problem problem2 = Problem.Create(Guid.NewGuid(), "Test Problem2", "Description2", 2000, 6 * MB, Difficulty.Hard, testCases2, tags);
    CollectionAssert.AreEqual(new List<Problem>() { problem, problem2 }, DataAccess.GetAllProblems());
}
\end{minted}

All tests passed without any issue.

\begin{minted}{csharp}
> dotnet test
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.1.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.
Assembly Cleanup method TestDataAccess.AssemblyCleanup failed. Error Message: System.IO.IOException: The process cannot access the file 'C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\15b684ed-a205-4f26-8981-d76a5e4fd8ec.db' because it is being used by another process.. StackTrace:     at System.IO.FileSystem.DeleteFile(String fullPath)
   at System.IO.File.Delete(String path)
   at Algorithm_Dynamics.Test.TestDataAccess.AssemblyCleanup() in C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\TestDataAccess.cs:line 34


Passed!  - Failed:     0, Passed:     6, Skipped:     0, Total:     6, Duration: 946 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

Finally, I need to connect these data models together. The test case and the problem has a many-to-one relationship. One test case can only belong to one problem while one problem can have multiple test cases. So I add a field problemId in the test case table to represent this relationship. In the DataAccess class, I also add a GetTestCases function to get all test cases belong to a problem.

\begin{minted}{csharp}
/// <summary>
/// Get all TestCases under a <see cref="Problem"/> by <see cref="Problem.Id"/>.
/// </summary>
/// <returns></returns>
internal static List<TestCase> GetTestCases(int problemId)
{
    List<TestCase> testCases = new();
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand selectCommand = new();
        selectCommand.Connection = conn;
        selectCommand.CommandText = "SELECT * FROM TestCase WHERE ProblemId = @ProblemId";
        selectCommand.Parameters.AddWithValue("@ProblemId", problemId);
        SqliteDataReader query = selectCommand.ExecuteReader();

        while (query.Read())
        {
            testCases.Add(new TestCase(query.GetInt32(0), query.GetString(1), query.GetString(2), query.GetBoolean(3)));
        }
    }
    return testCases;
}
\end{minted}

Finally, to bind a test case to a problem, I only need to set the problemId when needed.

\begin{minted}{csharp}
/// <summary>
/// Set the problem id of the testcase
/// </summary>
internal int ProblemId 
{ 
    set => DataAccess.EditTestCase(_id, _input, _output, _isExample, value); 
}
\end{minted}

The tag has a many-to-many relationship with a problem. One problem can have multiple tags while one tag can belong to multiple problems. A TagRecord table is needed to normalize the relationship.

\begin{minted}{csharp}
// Create TagRecord table
tableCommand +=
    @"CREATE TABLE IF NOT EXISTS TagRecord
    (
        Id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
        ProblemId INTEGER,
        TagId INTEGER,
        FOREIGN KEY (ProblemId) REFERENCES Problem (Id),
        FOREIGN KEY (TagId) REFERENCES Tag (Id)
    );";
\end{minted}

I also added several methods in DataAccess to modify and update the TagRecord table.

\begin{minted}{csharp}
/// <summary>
/// Add a new tag record to the database
/// </summary>
/// <param name="problemId"></param>
/// <param name="tagId"></param>
internal static void AddTagRecord(int problemId, int tagId)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand insertCommand = new();
        insertCommand.Connection = conn;

        insertCommand.CommandText = "INSERT INTO TagRecord (ProblemId, TagId) VALUES (@ProblemId, @TagId);";
        insertCommand.Parameters.AddWithValue("@ProblemId", problemId);
        insertCommand.Parameters.AddWithValue("@TagId", tagId);

        insertCommand.ExecuteNonQuery();
    }
}

/// <summary>
/// Delete an existing tag record from the database
/// </summary>
/// <param name="problemId"></param>
/// <param name="tagId"></param>
internal static void DeleteTagRecord(int problemId, int tagId)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand deleteCommand = new();
        deleteCommand.Connection = conn;
        deleteCommand.CommandText = "DELETE FROM TagRecord WHERE ProblemId = @ProblemId AND TagId = @TagId";
        deleteCommand.Parameters.AddWithValue("@ProblemId", problemId);
        deleteCommand.Parameters.AddWithValue("@TagId", tagId);
        deleteCommand.ExecuteNonQuery();
    }
}

/// <summary>
/// Check whether there is a tag record for a given tagId
/// </summary>
/// <param name="tagId"></param>
/// <returns></returns>
internal static bool TagRecordExists(int tagId)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand selectCommand = new();
        selectCommand.Connection = conn;
        selectCommand.CommandText = "SELECT EXISTS (SELECT 1 FROM TagRecord WHERE TagId = @TagId)";
        selectCommand.Parameters.AddWithValue("@TagId", tagId);

        SqliteDataReader query = selectCommand.ExecuteReader();
        query.Read();
        return query.GetBoolean(0);
    }
}
\end{minted}

In the Tag class, I create the attach and delete methods to add or remove a tag from a problem.

\begin{minted}{csharp}
/// <summary>
/// Attach the Tag to a problem.
/// </summary>
/// <param name="id"></param>
internal void AttachTo(int problemId)
{
    DataAccess.AddTagRecord(problemId, Id);
}

/// <summary>
/// Delete the tag record from the database.
/// </summary>
/// <param name="problemId"></param>
internal void DeleteRecord(int problemId)
{
    DataAccess.DeleteTagRecord(problemId, Id);
}
\end{minted}

Now, in the Problem class, to create a new problem, I first create a problem instance, then attach the tags and test cases to the problem.

\begin{minted}{csharp}
/// <summary>
/// Create a new <see cref="Problem"/> and save it to the database.
/// </summary>
/// <param name="uid"></param>
/// <param name="name"></param>
/// <param name="description"></param>
/// <param name="timeLimit"></param>
/// <param name="memoryLimit"></param>
/// <param name="difficulty"></param>
/// <param name="testCases"></param>
/// <param name="tags"></param>
/// <returns>An instance of the Problem you just created</returns>
public static Problem Create(
    Guid uid,
    string name,
    string description,
    int timeLimit,
    long memoryLimit,
    Difficulty difficulty,
    List<TestCase> testCases = null,
    List<Tag> tags = null)
{
    // Create record for Problem
    var problem = DataAccess.AddProblem(uid,
        name,
        description,
        timeLimit,
        memoryLimit,
        ProblemStatus.Todo,
        difficulty,
        testCases,
        tags);

    // Add testcases to problem
    if (testCases != null)
    {
        foreach (var testCase in testCases)
        {
            testCase.ProblemId = problem.Id;
        }
    }
    else
    {
        problem._testCases = new() { };
    }

    // Add tags to problem
    if (tags != null)
    {
        foreach (var tag in tags)
        {
            tag.AttachTo(problem.Id);
        }
    }
    else
    {
        problem._tags = new() { };
    }

    return problem;
}
\end{minted}

I also add several methods to add or remove tags and test cases from a problem through all the method I created before.

\begin{minted}{csharp}
/// <summary>
/// Add an existing <see cref="TestCase"/> to the problem
/// </summary>
/// <param name="testCase"></param>
public void AddTestCase(TestCase testCase)
{
    testCase.ProblemId = Id;
    _testCases.Add(testCase);
}

/// <summary>
/// Remove an existing <see cref="TestCase"/> from the <see cref="Problem"/>
/// and delete it from the database.
/// </summary>
/// <param name="testCase"></param>
public void RemoveTestCase(TestCase testCase)
{
    testCase.Delete();
    _testCases.Remove(testCase);
}

/// <summary>
/// Add an existing <see cref="Tag"/> to the <see cref="Problem"/>
/// </summary>
/// <param name="tag"></param>
public void AddTag(Tag tag)
{
    DataAccess.AddTagRecord(Id, tag.Id);
    _tags.Add(tag);
}

/// <summary>
/// Delete an existing <see cref="Tag"/> from the <see cref="Problem.Tags"/>.
/// Delete the <see cref="Tag"/> from the database if it does not attach to any
/// other problems.
/// </summary>
/// <param name="tag"></param>
public void RemoveTag(Tag tag)
{
    // Delete the current record
    tag.DeleteRecord(Id);
    // If not belong to other problem
    // delete the tag completely

    if (DataAccess.TagRecordExists(tag.Id) == false)
        tag.Delete();
    
    // Delete from _tags
    _tags.Remove(tag);
}
\end{minted}

At the very end, I add test cases for all these complex cases.

\begin{minted}{csharp}
    [TestMethod]
    public void TestCreateProblem()
    {
        TestCase testCase1 = TestCase.Create("input1", "output1", true);
        TestCase testCase2 = TestCase.Create("input2", "output2", false);

        Tag tag1 = Tag.Create("tag1");
        Tag tag2 = Tag.Create("tag2");
        var testCases = new List<TestCase>() { testCase1, testCase2 };
        var tags = new List<Tag>() { tag1, tag2 };
        Problem problem = Problem.Create(Guid.NewGuid(), "Test Problem", "Description", 1000, 64 * MB, Difficulty.Easy, testCases, tags);
        Assert.AreEqual(problem, DataAccess.GetProblem(problem.Id));
    }

    [TestMethod]
    public void TestEditProblem()
    {
        Problem problem = Problem.Create(Guid.NewGuid(), "Test Problem", "Description", 1000, 64 * MB, Difficulty.Easy);
        problem.Name = "New name";
        problem.Description = "New description";
        problem.TimeLimit = 2000;
        problem.MemoryLimit = 128 * MB;
        problem.Difficulty = Difficulty.Easy;
        problem.Status = ProblemStatus.Solved;
        Assert.AreEqual(problem, DataAccess.GetProblem(problem.Id));
    }

    [TestMethod]
    public void TestGetAllProblems()
    {
        TestCase testCase1 = TestCase.Create("input1", "output1", true);
        TestCase testCase2 = TestCase.Create("input2", "output2", false);

        Tag tag1 = Tag.Create("tag1");
        Tag tag2 = Tag.Create("tag2");
        var testCases1 = new List<TestCase>() { testCase1 };
        var testCases2 = new List<TestCase>() { testCase2 };
        var tags = new List<Tag>() { tag1, tag2 };
        Problem problem = Problem.Create(Guid.NewGuid(), "Test Problem", "Description", 1000, 64 * MB, Difficulty.Easy, testCases1, tags);
        Problem problem2 = Problem.Create(Guid.NewGuid(), "Test Problem2", "Description2", 2000, 6 * MB, Difficulty.Hard, testCases2, tags);
        CollectionAssert.AreEqual(new List<Problem>() { problem, problem2 }, DataAccess.GetAllProblems());
    }

    [TestMethod]
    public void TestAddTestCase()
    {
        TestCase testCase1 = TestCase.Create("input", "output", true);
        Assert.AreEqual(testCase1, DataAccess.GetAllTestCases()[0]);
    }

    [TestMethod]
    public void TestEditTestCase()
    {
        TestCase testCase = TestCase.Create("input", "output", true);
        testCase.Input = "newInput";
        testCase.Output = "newOutput";
        testCase.IsExample = false;
        Assert.AreEqual(testCase, DataAccess.GetAllTestCases()[0]);
    }

    [TestMethod]
    public void TestDeleteTestCase()
    {
        TestCase testCase = TestCase.Create("input", "output", true);
        testCase.Delete();
        Assert.AreEqual(0, DataAccess.GetAllTestCases().Count);
    }

    [TestMethod]
    public void TestAddTag()
    {
        Tag tag = Tag.Create("tag");
        Assert.AreEqual(tag, DataAccess.GetAllTags()[0]);
    }

    [TestMethod]
    public void TestTagExists()
    {
        Assert.AreEqual(false, DataAccess.TagExists("tag"));
        Tag.Create("tag");
        Assert.AreEqual(true, DataAccess.TagExists("tag"));
    }

    [TestMethod]
    public void TestGetTag()
    {
        Tag tag = Tag.Create("tag");
        Assert.AreEqual(tag, DataAccess.GetTag(tag.Id));
        Assert.AreEqual(tag, DataAccess.GetTag(tag.Name));
        Assert.AreEqual(null, DataAccess.GetTag("Non-exist Tag"));
        Assert.AreEqual(null, DataAccess.GetTag(100));
    }

    [TestMethod]
    public void TestAddDeleteTagRecord()
    {
        Tag tag1 = Tag.Create("tag1");
        Tag tag2 = Tag.Create("tag2");
        Problem problem = Problem.Create(Guid.NewGuid(), "Test Problem", "Description", 1000, 64 * MB, Difficulty.Easy);
        problem.AddTag(tag1);
        problem.AddTag(tag2);
        problem.RemoveTag(tag1);
        Assert.AreEqual(problem, DataAccess.GetAllProblems()[0]);
    }
    [TestMethod]
    public void TestTagRecordExists()
    {
        Tag tag1 = Tag.Create("tag1");
        Tag tag2 = Tag.Create("tag2");
        Problem problem = DatabaseHelper.CreateNewProblem();
        problem.AddTag(tag1);
        Assert.AreEqual(true, DataAccess.TagRecordExists(tag1.Id));
        Assert.AreEqual(false, DataAccess.TagRecordExists(tag2.Id));
        problem.RemoveTag(tag1);
        Assert.AreEqual(false, DataAccess.TagRecordExists(tag1.Id));
        Assert.AreEqual(false, DataAccess.TagExists(tag1.Name));
    }
    [TestMethod]
    public void TestDeleteProblem()
    {
        Tag tag1 = Tag.Create("tag1");
        Tag tag2 = Tag.Create("tag2");
        TestCase testCase1 = TestCase.Create("input1", "output1", true);
        TestCase testCase2 = TestCase.Create("input2", "output2", false);
        Problem problem = DatabaseHelper.CreateNewProblem();
        problem.AddTestCase(testCase1);
        problem.AddTestCase(testCase2);
        problem.AddTag(tag1);
        problem.AddTag(tag2);
        problem.Delete();

        Assert.AreEqual(false, DataAccess.TagExists(tag1.Name));
        Assert.AreEqual(false, DataAccess.TagExists(tag2.Name));
        Assert.AreEqual(false, DataAccess.TagRecordExists(tag1.Id));
        Assert.AreEqual(false, DataAccess.TagRecordExists(tag2.Id));
        Assert.AreEqual(0, DataAccess.GetAllTestCases().Count);
        Assert.AreEqual(0, DataAccess.GetAllProblems().Count);
    }
\end{minted}

The tests all passed without any issues.

\begin{minted}{text}
> dotnet test --filter "Name~TestCase"
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.1.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.
Assembly Cleanup method TestDataAccess.AssemblyCleanup failed. Error Message: System.IO.IOException: The process cannot access the file 'C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\15b684ed-a205-4f26-8981-d76a5e4fd8ec.db' because it is being used by another process.. StackTrace:     at System.IO.FileSystem.DeleteFile(String fullPath)
   at System.IO.File.Delete(String path)
   at Algorithm_Dynamics.Test.TestDataAccess.AssemblyCleanup() in C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\TestDataAccess.cs:line 34


Passed!  - Failed:     0, Passed:     11, Skipped:     0, Total:     11, Duration: 5 s - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}


\subsection{Integration}

I then need to integrate the core code with the UI.

On the HomePage, I need to implement the random problem button and the recommendations.

\begin{minted}{csharp}
private void InitializeQAItems()
{
    // ...    
    QAItems.Add(new QuickAccessItem("Random Problem", Symbol.Shuffle, () =>
        {
            // Get all problems from the database
            List<Problem> problems = Problem.All;

            // Generate a random index
            var random = new Random();
            int randomIndex = random.Next(problems.Count);

            // Get the corresponding problem
            Problem problem = problems[randomIndex];

            // Navigate to coding page with the problems as parameters
            App.NavigateTo(typeof(CodingPage), Tuple.Create(problem, problems));
        }));
    // ...
}

/// <summary>
/// Generate Recommendation from database.
/// </summary>
private void InitializeRecItems()
{
    RecItems.Clear();
    // Generate recommend problems
    var problems = Problem.All;
    for (int i = 0; i < problems.Count && i < 4; i++)
    {
        var problem = problems[i];
        RecItems.Add(new RecommendItem(problem.Name, $"{problem.DifficultyAsString} | {problem.TagAsString}", () => { App.NavigateTo(typeof(CodingPage), Tuple.Create(problem, Problem.All)); }));
    }
    // If no item, hide the title
    if (RecItems.Count == 0)
    {
        RecommendTextBlock.Visibility = Visibility.Collapsed;
    }
    else
    {
        RecommendTextBlock.Visibility = Visibility.Visible;
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-Final}

Now, when I click the random problem button or the recommendations button, I am navigated to the correct problem correctly.

On the ProblemsPage, I first set up the RefreshDatabase method. It loads all data from the database for further queries.

\begin{minted}{csharp}
/// <summary>
/// Reload all data from the database
/// </summary>
private void RefreshDatabase()
{
    // Clear the existing lists
    ProblemLists.Clear();
    Tags.Clear();
    Problems.Clear();

    // Load all data from the database
    Problem.All.ForEach(problem => Problems.Add(problem));
    Core.Models.Tag.All.ForEach(tag => Tags.Add(tag));
    ProblemList.All.ForEach(problemList => ProblemLists.Add(problemList));
}
\end{minted}

I implement the DeleteProblem method, it shows up a dialogue and deletes the selected problem.

\begin{minted}{csharp}
/// <summary>
/// Show a content dialog to confirm the deletion of Problems
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
/// <exception cref="NotImplementedException"></exception>
private async void DeleteProblems(object sender, RoutedEventArgs e)
{
    ContentDialog dialog = new()
    {
        Title = "Delete Problem",
        PrimaryButtonText = "Delete",
        CloseButtonText = "Cancel",
        Content = $"Are you sure that you want to permanently delete these {ProblemsListView.SelectedItems.Count} Problems?",
        DefaultButton = ContentDialogButton.Close,
        XamlRoot = Content.XamlRoot
    };
    var result = await dialog.ShowAsync();
    if (result == ContentDialogResult.Primary)
    {
        var problems = ProblemsListView.SelectedItems;
        foreach (Problem problem in problems) problem.Delete();
        RefreshDatabase();
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-Delete}

Next, I need to implement the search function. When the search box is submitted or the combo box is selected, a Query function is executed and return the search result.

\begin{minted}{csharp}
/// <summary>
/// Trigger when the search box is submitted
/// </summary>
private void Search(AutoSuggestBox sender, AutoSuggestBoxQuerySubmittedEventArgs args)
    => Query();

/// <summary>
/// Trigger when the combo box is changed
/// </summary>
private void Search(object sender, SelectionChangedEventArgs e)
    => Query();

private void Query()
{
    // Clear existing results
    Problems.Clear();
    NoResultTextBlock.Visibility = Visibility.Collapsed;
    
    // Get all problems
    var problems = Problem.All;

    // Query difficulty
    if (DifficultyComboBox.SelectedIndex != -1)
    {
        var difficulty = (Difficulty)DifficultyComboBox.SelectedIndex;
        problems.RemoveAll(p => p.Difficulty != difficulty);
    }

    // Query status
    if (StatusComboBox.SelectedIndex != -1)
    {
        var status = (ProblemStatus)StatusComboBox.SelectedIndex;
        problems.RemoveAll(p => p.Status != status);
    }

    // Query tag
    if (TagComboBox.SelectedIndex != -1)
    {
        var tag = (Tag)TagComboBox.SelectedItem;
        problems.RemoveAll(p => p.Tags.Contains(tag) == false);
    }

    // Query list
    if (ListComboBox.SelectedIndex != -1)
    {
        var list = (ProblemList)ListComboBox.SelectedItem;
        problems.RemoveAll(p => list.Problems.Contains(p) == false);
    }

    // Query name
    if (string.IsNullOrEmpty(ProblemsSearchBox.Text) == false)
    {
        var name = ProblemsSearchBox.Text;
        problems.RemoveAll(p => p.Name != name);
    }

    // Handle no result
    if (problems.Count == 0)
        NoResultTextBlock.Visibility = Visibility.Visible;

    // Return results
    foreach (var problem in problems)
    {
        Problems.Add(problem);
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-Testing-Search}

When the user is inputting in the search box, the fuzzy search provides suggestions in the drop-down menu. The exact algorithm is explained in the design chapter.

\begin{minted}{csharp}
/// <summary>
/// Give fuzzy search suggestions when the user is inputing search query
/// </summary>
/// <param name="sender"></param>
/// <param name="args"></param>
private void ProblemsSearchBox_TextChanged(AutoSuggestBox sender, AutoSuggestBoxTextChangedEventArgs args)
{
    // Query if empty
    if (string.IsNullOrEmpty(ProblemsSearchBox.Text))
    {
        Query();
    }
    else
    {
        // Give fuzzy search suggestions
        string keyword = ProblemsSearchBox.Text.Trim();
        var resultList = new List<Problem>();
        var sourceList = Problem.All;
        var splitKeyword = keyword.ToLower().Split(' ');
        for (int i = 0; i < sourceList.Count; i++)
        {
            for (int j = 0; j < splitKeyword.Length; j++)
            {
                var sourceKey = sourceList[i].Name.ToLower();
                if (sourceKey.Contains(splitKeyword[j]))
                {
                    resultList.Add(sourceList[i]);
                    break;
                }
            }
        }
        // Return result
        sender.ItemsSource = resultList.Select(p => p.Name).ToList();
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-FuzzySearch}

Next, I integrate the CreateNew pages. I will show the CreateNewProblemListPage as an example since both of them share a similar process, please refer to the source code for details.

The key to the integration is to create a new problem list and save any changes to the database.

\begin{minted}{csharp}
/// <summary>
/// When the save button is clicked, save the problem list and change the description test.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void SaveButton_Click(object sender, RoutedEventArgs e)
{
    if (_pageMode == Mode.CreateProblemList)
    {
        _problemList = ProblemList.Create(_name, _description, Problems.ToList());
    }
    else if (_pageMode == Mode.EditProblemList)
    {
        // Save name
        _problemList.Name = _name;
        // Save description
        _problemList.Description = _description;
        // Save problems
        Problems.ToList().ForEach(problem =>
        {
            if (_problemList.Problems.Contains(problem) == false)
            {
                _problemList.AddProblem(problem);
            }
        });
        _problemList.Problems.ToList().ForEach(problem =>
        {
            if (Problems.Contains(problem) == false)
            {
                _problemList.RemoveProblem(problem);
            }
        });
    }

    // Done
    TestTextBlock.Text = "The Problem List is saved.";
}
\end{minted}

I also need to add validation to all the fields to ensure none of them is empty.

\begin{minted}{csharp}
public bool IsValidInput
{
    get
    {
        ErrorMessage = "";
        bool isValid = true;
        if (string.IsNullOrEmpty(_name))
        {
            isValid = false;
            ErrorMessage += "A name is required.\n";
        }
        if (Problems.Count < 1)
        {
            isValid = false;
            ErrorMessage += "At least one problem is required.\n";
        }
        return isValid;
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CreateNewProblemListPage-Testing-Empty}

In the CodingPage Integration, I need to render the given problem into a markdown file, so it can be displayed with all formats supported.

\begin{minted}{csharp}
/// <summary>
/// The renderec markdown text of the current problem
/// </summary>
public string ProblemMarkdown
{
    get
    {
        if (_currentProblem != null)
        {
            const int MB = 1024 * 1024;
            
            // Set title
            string title = $"# {_currentProblem.Name}\n";
            
            // Set time limit
            string timeLimit = $"\n## Time Limit\n{_currentProblem.TimeLimit} ms";
            
            // Set memory limit
            string memoryLimit = $"\n## Memory Limit\n{_currentProblem.MemoryLimit / MB} MB";
            
            // Set example test case
            string example = "\n## Example";
            int testCaseCnt = 1;
            _currentProblem.TestCases.Where(testCase => testCase.IsExample == true).ToList().ForEach(testCase =>
            {
                example += $"\n### Example Input {testCaseCnt}\n";
                example += "```\n" + testCase.Input.Replace("\n", "\n") + "\n```\n";
                example += $"\n### Example Output {testCaseCnt}\n";
                example += "```\n" + testCase.Output.Replace("\n", "\n") + "\n```\n";
                testCaseCnt++;
            });

            return title + _currentProblem.Description + timeLimit + memoryLimit + example;
        }
        return "";
    }
}
\end{minted}

I use the test data in the design section to test the markdown renderer. However, the data is not rendered as expected. There is no line break, and all text is rendered as the title.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-MarkdownTest-Failed}

After some debugging and reading the documentation of the markdown control, I found that I should use `\textbackslash r' instead of `\textbackslash n' for newlines.

\begin{minted}{csharp}
/// <summary>
/// The renderec markdown text of the current problem
/// </summary>
public string ProblemMarkdown
{
    get
    {
        if (_currentProblem != null)
        {
            const int MB = 1024 * 1024;
            
            // Set title
            string title = $"# {_currentProblem.Name}\r";
            
            // Set time limit
            string timeLimit = $"\r## Time Limit\r{_currentProblem.TimeLimit} ms";
            
            // Set memory limit
            string memoryLimit = $"\r## Memory Limit\r{_currentProblem.MemoryLimit / MB} MB";
            
            // Set example test case
            string example = "\r## Example";
            int testCaseCnt = 1;
            _currentProblem.TestCases.Where(testCase => testCase.IsExample == true).ToList().ForEach(testCase =>
            {
                example += $"\r### Example Input {testCaseCnt}\r";
                example += "```\r" + testCase.Input.Replace("\r", "\r") + "\r```\r";
                example += $"\r### Example Output {testCaseCnt}\r";
                example += "```\r" + testCase.Output.Replace("\r", "\r") + "\r```\r";
                testCaseCnt++;
            });

            return title + _currentProblem.Description + timeLimit + memoryLimit + example;
        }
        return "";
    }
}
\end{minted}

The markdown renderer works correctly now.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-MarkdownTest}

For the submission grid, I can directly bind it to the list of submissions and it will get updated automatically when a new submission is created.

\begin{minted}{xml}
<controls:DataGrid
    x:Name="SubmissionsDataGrid"
    AutoGenerateColumns="False"
    IsReadOnly="True"
    SelectionMode="Single"
    CanUserReorderColumns="False"
    MinColumnWidth="100"
    SelectionChanged="SubmissionsDataGrid_SelectionChanged"
    ItemsSource="{x:Bind ReverseSubmissions, Mode=OneWay}">
    <controls:DataGrid.Columns>
    <controls:DataGridTextColumn
        Header="Submit Time"
        Width="SizeToCells"
        Binding="{Binding Submission.SubmittedTime}"/>
    <controls:DataGridComboBoxColumn
        Header="Status"
        Width="SizeToCells"
        Binding="{Binding Result}"/>
    <controls:DataGridComboBoxColumn
        Header="Runtime"
        Width="SizeToCells"
        Binding="{Binding CPUTimeAsString}"/>
    <controls:DataGridComboBoxColumn
        Header="Memory"
        Width="SizeToCells"
        Binding="{Binding MemoryUsageAsString}"/>
    <controls:DataGridComboBoxColumn
        Header="Language"
        Width="SizeToCells"
        Binding="{Binding Submission.Language.DisplayName}"/>
    </controls:DataGrid.Columns>
</controls:DataGrid>
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-SubmissionGrid}

Finally, I need to integrate the AccountPage. The main job is to generate all statistics for the current user. The InitializeStatsItems procedure is called when the constructor of the Page is executed, so the statistics are generated when the page is loaded. It reads from the database and performs the calculations and save the results.

\begin{minted}{csharp}
public AccountPage()
{
    InitializeComponent();
    InitializeStatsItems();
}
/// <summary>
/// Initialize the statistics items
/// </summary>
private void InitializeStatsItems()
{
    // Count all problems solved
    StatsItems.Add(new("Problem Solved", Problem.All.Count(problem => problem.Status == ProblemStatus.Solved).ToString()));
    
    // Count all problems attempted
    StatsItems.Add(new("Problem Attempted", Problem.All.Count(problem => problem.Status == ProblemStatus.Attempted).ToString()));
    
    // Count all problems todo
    StatsItems.Add(new("Problem Todo", Problem.All.Count(problem => problem.Status == ProblemStatus.Todo).ToString()));

    // Count correct rate
    StatsItems.Add(new("Correct Rate", $"{(SubmissionResult.All.Count(result => result.ResultCode == ResultCode.SUCCESS) * 100 / Submission.All.Count)}%"));

    // Count the favourite tag
    string favTag = "";
    int maxTag = 0;
    foreach (var tag in Core.Models.Tag.All)
    {
        int tagCnt = Submission.All.Count(submission => submission.Problem.Tags.Contains(tag));
        if (tagCnt > maxTag)
        {
            maxTag = tagCnt;
            favTag = tag.Name;
        }
    }
    StatsItems.Add(new("Favourite Topic", favTag));

    // Count the favourite language
    string favLang = "";
    int maxLang = 0;
    foreach (var lang in Core.Models.Language.All)
    {
        int langCnt = Submission.All.Count(submission => Equals(submission.Language, lang));
        if (langCnt > maxLang)
        {
            maxLang = langCnt;
            favLang = lang.DisplayName;
        }
    }
    StatsItems.Add(new("Favourite Language", favLang));
}
\end{minted}

When I first run the app, it crashes when I navigated to the AccountPage. The following error message is thrown.

\begin{minted}{text}
System.DivideByZeroException
  HResult=0x80020012
  Message=Attempted to divide by zero.
  Source=Algorithm Dynamics
  StackTrace:
   at Algorithm_Dynamics.Pages.AccountPage.InitializeStatsItems() in C:\Algorithm-Dynamics\src\Algorithm Dynamics\Pages\AccountPage.xaml.cs:line 134
   at Algorithm_Dynamics.Pages.AccountPage..ctor() in C:\Algorithm-Dynamics\src\Algorithm Dynamics\Pages\AccountPage.xaml.cs:line 20
   at Algorithm_Dynamics.Algorithm_Dynamics_XamlTypeInfo.XamlTypeInfoProvider.Activate_59_AccountPage() in C:\Algorithm-Dynamics\src\Algorithm Dynamics\obj\x64\Debug\net6.0-windows10.0.19041.0\XamlTypeInfo.g.cs:line 567
   at Algorithm_Dynamics.Algorithm_Dynamics_XamlTypeInfo.XamlUserType.ActivateInstance() in C:\Algorithm-Dynamics\src\Algorithm Dynamics\obj\x64\Debug\net6.0-windows10.0.19041.0\XamlTypeInfo.g.cs:line 7704
   at ABI.Microsoft.UI.Xaml.Markup.IXamlType.Do_Abi_ActivateInstance_13(IntPtr thisPtr, IntPtr* result)

  This exception was originally thrown at this call stack:
    Algorithm_Dynamics.Pages.AccountPage.InitializeStatsItems() in AccountPage.xaml.cs
    Algorithm_Dynamics.Pages.AccountPage.AccountPage() in AccountPage.xaml.cs
    Algorithm_Dynamics.Algorithm_Dynamics_XamlTypeInfo.XamlTypeInfoProvider.Activate_59_AccountPage() in XamlTypeInfo.g.cs
    Algorithm_Dynamics.Algorithm_Dynamics_XamlTypeInfo.XamlUserType.ActivateInstance() in XamlTypeInfo.g.cs
    ABI.Microsoft.UI.Xaml.Markup.IXamlType.Do_Abi_ActivateInstance_13(System.IntPtr, System.IntPtr*)
\end{minted}

It is a divide by zero error because the number of submissions is 0. I can fix this by adding branching to handle the 0 cases.

\begin{minted}{csharp}
// Count correct rate
if (Submission.All.Count > 0)
{
    StatsItems.Add(new("Correct Rate", $"{(SubmissionResult.All.Count(result => result.ResultCode == ResultCode.SUCCESS) * 100 / Submission.All.Count)}%"));
}
else
{
    StatsItems.Add(new("Correct Rate", "0%"));
}
\end{minted}

Now the AccountPage works correctly with all statistics showing up correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AccountPage-Final.png}

\subsection{Stakeholder feedback}

Mr Grimwood asked me what will happen to the account page when the software is installed for the first time. Where does the user create an account? In my current design, there is no such sign-up page. I think when the app launches if it finds there is no user in the database, it should promote the user to a registration page. The user can only log in after registration.

I place the welcome page in the main window.

\begin{minted}{xml}
<!--WelcomePage for creating new user on first startup-->
<Grid
    Grid.Row="1"
    x:Name="WelcomeGrid"
    Visibility="Collapsed"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
    <StackPanel
    VerticalAlignment="Center"
    HorizontalAlignment="Center">
    <TextBlock 
        Margin="32"
        Style="{ThemeResource TitleTextBlockStyle}"
        Text="Welcome to Algorithm Dynamics"/>
    <TextBox
        Header="Your Name"
        Margin="8"
        MaxWidth="200"
        PlaceholderText="Name"
        IsSpellCheckEnabled="False"
        Text="{x:Bind UserName, Mode=TwoWay}"/>
    <TextBox
        Header="Your Email"
        Margin="8"
        MaxWidth="200"
        PlaceholderText="Email"
        IsSpellCheckEnabled="False"
        Text="{x:Bind Email, Mode=TwoWay}"/>
    <ComboBox
        Header="Role"
        Margin="8"
        MaxWidth="200"
        HorizontalAlignment="Stretch"
        SelectedIndex="{x:Bind RoleIndex, Mode=TwoWay}">
        <x:String>Student</x:String>
        <x:String>Teacher</x:String>
    </ComboBox>
    <Button 
        x:Name="CreateUserButton"
        Margin="16"
        Content="Go"
        MaxWidth="200"
        HorizontalAlignment="Stretch"
        IsEnabled="{x:Bind IsValidInput, Mode=OneWay}"
        Click="CreateUserButton_Click"/>
    <TextBlock
        Margin="4"
        Text="{x:Bind ErrorMessage, Mode=OneWay}"
        RelativePanel.Below="InputPanel"
        MaxWidth="200"
        RelativePanel.AlignLeftWith="InputPanel"
        Foreground="Red"/>
    </StackPanel>
</Grid>
\end{minted}

In the constructor of the main window, the welcome grid is shown if there is no user in the database.

\begin{minted}{csharp}
public MainWindow()
{
    // ...
    // If no user, show welcome grid
    if (DataAccess.GetAllUsers().Count == 0)
    {
        WelcomeGrid.Visibility = Visibility.Visible;
        UserName = "";
        Email = "";
        Role = 0;
    }
    else
    {
        MainNavView.SelectedItem = MainNavView.MenuItems[0];
    }
}
\end{minted}

When the user clicks the create button, the user is created in the database and the user is navigated to the HomePage.

\begin{minted}{csharp}
/// <summary>
/// Create a new user and store <see cref="User.Uid"/> into settings
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void CreateUserButton_Click(object sender, RoutedEventArgs e)
{
    // Create user
    User user = User.Create(UserName, Email, Role);

    // Set current user
    ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
    localSettings.Values["CurrentUser"] = user.Uid;

    // Navigate to HomePage
    WelcomeGrid.Visibility = Visibility.Collapsed;
    MainNavView.SelectedItem = MainNavView.MenuItems[0];
}
\end{minted}

I also set a validation function IsValid. If the user input is not valid, the create button is disabled and a user-friendly error message is displayed.

\begin{minted}{csharp}
/// <summary>
/// Validate the name and the email
/// </summary>
public bool IsValidInput
{
    get
    {
        ErrorMessage = "";
        if (string.IsNullOrEmpty(UserName) || string.IsNullOrEmpty(Email)) 
            return false;
        bool isValid = true;
        if (string.IsNullOrEmpty(UserName))
        {
            isValid = false;
            ErrorMessage += "A user name is required.\n";
        }
        if (IsValidEmail(Email) == false)
        {
            isValid = false;
            ErrorMessage += "The email address is not valid.\n";
        }
        return isValid;
    }
}
\end{minted}

Now, when the user runs the app for the first time, he will be promoted to this registration page.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{WelcomeScreen}

Both name and email are validated before the user can continue.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{WelcomeScreen-Validation}

Mr Grimwood is satisfied with the design and the solution.

\end{document}