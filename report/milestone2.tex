\documentclass[report.tex]{subfiles}
\graphicspath{ \subfix{./images/} \subfix{./graphs/} }
\begin{document}
\section{Milestone 2: Implement the data structures and database}

\subsection{Implementation and testing}

I decided to create a second project called Algorithm Dynamics.Core to separate the UI code and the core code. This allows me to organize the codebase more cleanly and allows me to run unit tests on the core code.

When developing the core code, I decide not to integrate it with the UI right away, since it is very inefficient in testing and debugging. Instead, I will write unit tests for each function, test everything in isolation, and then integrate the core code with the UI when it is ready.

I decided to create the model and the database structure at the same time, so that I can make sure any change to the data model will be saved correctly into the database, preventing any data inconsistency between the runtime and the database.

I decide to use SQLite\cite{sqlite} as the database since it is a small, fast and lightweight database suitable for local data storage. To access the database, I use Microsoft.Data.Sqlite\cite{microsoft:docs:sqlite} database bindings to send my query commands to the local database.

First, I create a test table to test the workflow. Under Algorithm Dynamics.Core.Helpers namespace, I create a class DataAccess. I decide to make it public since it needs to be accessed to set the physical location of the database. I decide to make it static since it is essentially a collection of helper functions that depend on each other, but no instance needs to be created to call them. I decide to set it to a partial class since I intend to split functions that handle different data models into different files, so each file only contains a part of the class.

\begin{minted}{csharp}
using Microsoft.Data.Sqlite;
using System.IO;

namespace Algorithm_Dynamics.Core.Helpers
{
    public static partial class DataAccess
    {
    }
}
\end{minted}

I set up a private attribute \code{DbPath}, which stores the physical location of the database. And a function \code{InitDatabase}, which takes in a string, and init the database at that location. A test table is created to verify that the database is working.

\begin{minted}{csharp}
/// <summary>
/// Store the physical loaction of the database.
/// Use <see cref="InitializeDatabase(string)"/> to initialize the value.
/// </summary>
private static string ConnectionString;

/// <summary>
/// Initialize the database at the <see cref="dbPath"/> given.
/// Execute CREATE TABLE commands.
/// </summary>
/// <param name="dbPath"></param>
public static void InitializeDatabase(string dbPath)
{
    ConnectionString = $"Data Source={dbPath}";

    // Create a new database if not exist
    if (!File.Exists(dbPath))
    {
        File.CreateText(dbPath).Dispose();
    }

    // Create tables
    using (SqliteConnection db = new(ConnectionString))
    {
        db.Open();

        string tableCommand =
            @"CREATE TABLE IF NOT EXISTS MyTable 
            (
                Primary_Key INTEGER PRIMARY KEY,
                Text_Entry TEXT
            );";
        SqliteCommand createTable = new(tableCommand, db);

        createTable.ExecuteNonQuery();
    }
}
\end{minted}

I set up two methods for the test data, to insert and query data.

\begin{minted}{csharp}
/// <summary>
/// Add a text data into the test table in the database.
/// This procedure is used for testing the function of the database.
/// </summary>
/// <param name="inputText"></param>
internal static void AddData(string inputText)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand insertCommand = new();
        insertCommand.Connection = conn;

        insertCommand.CommandText = "INSERT INTO MyTable VALUES (NULL, @Entry);";
        insertCommand.Parameters.AddWithValue("@Entry", inputText);

        insertCommand.ExecuteReader();

    }
}

/// <summary>
/// Get all data in the test table in the database.
/// This function is used for testing the function of the database.
/// </summary>
/// <returns></returns>
internal static List<string> GetData()
{
    List<string> entries = new();

    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand selectCommand = new("SELECT Text_Entry from MyTable", conn);

        using (var reader = selectCommand.ExecuteReader())
        {
            while (reader.Read())
            {
                entries.Add(reader.GetString(0));
            }
        }
    }

    return entries;
}
\end{minted}

Finally, I write a test class to test the database and the test table.

\begin{minted}{csharp}
using Algorithm_Dynamics.Core.Helpers;
using Algorithm_Dynamics.Core.Models;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.IO;

namespace Algorithm_Dynamics.Test
{
    [TestClass]
    public class TestDataAccess
    {
        const int MB = 1024 * 1024;

        /// <summary>
        /// Create a temp database with unique name for testing
        /// </summary>
        [TestInitialize]
        public void InitDb()
        {
            string path = $"{Guid.NewGuid()}.db";
            File.Delete(path);
            DataAccess.InitializeDatabase(path);
        }

        /// <summary>
        /// Clean up all temp databases after testing
        /// </summary>
        [AssemblyCleanup]
        public static void AssemblyCleanup()
        {
            foreach (string path in Directory.GetFiles(".", "*.db"))
            {
                File.Delete(path);
            }
        }

        /// <summary>
        /// Insert a single data into the test table
        /// </summary>
        [TestMethod]
        public void TestSingleData()
        {
            DataAccess.AddData("Text1");
            Assert.AreEqual(DataAccess.GetData().Count, 1);
            Assert.AreEqual(DataAccess.GetData()[0], "Text1");
        }
    }
}
\end{minted}

In the TestSingleData method, I insert a single piece of data into the test table using the AddData method. I then verify that the data is inserted correctly by using the GetData method.

The test passed successfully.

\begin{minted}{text}
> dotnet test --filter TestSingleData
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.1.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: 110 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

Now I have verified that the database and database bindings are working correctly, I can create real data models in a similar parttern: create table, add methods, add unit tests. I will use the Problem, Tag, and TestCase data models as an example. They represent a one-to-one relationship and a many-to-many relationship. Other data models are created similarly and please reference the source code for details.

I will start with the TestCase. I use the factory pattern to create a TestCase object. Instead of using the constructor to create a TestCase object, I expose a static method \code{Create} to initialize a TestCase object and also create it in the database. An internal constructor is used to initialize the object internally.

\begin{minted}{csharp}
public class TestCase
{
    internal TestCase(int id, string input, string output, bool isExample)
    {
        _id = id;
        _input = input;
        _output = output;
        _isExample = isExample;
    }

    /// <summary>
    /// Create a new <see cref="TestCase"/> and save it into the databse.
    /// </summary>
    /// <param name="input"></param>
    /// <param name="output"></param>
    /// <param name="isExample"></param>
    /// <returns></returns>
    public static TestCase Create(string input, string output, bool isExample)
    {
        return DataAccess.AddTestCase(input, output, isExample);
    }
}
\end{minted}

I create getters and setters for each properties of the TestCase class. A private _prop is used to store the actual value and a public Prop is used to expose the value.

\begin{minted}{csharp}
private void UpdateDatabase()
{
    DataAccess.EditTestCase(_id, _input, _output, _isExample);
}
private int _id;
public int Id { get => _id; private set => _id = value; }

private string _input;
public string Input
{
    get => _input;
    set
    {
        if (value == _input)
        {
            _input = value;
            UpdateDatabase();
        }
    }
}

private string _output;
public string Output
{
    get => _output;
    set
    {
        if (value != _output)
        {
            _output = value;
            UpdateDatabase();
        }
    }
}

private bool _isExample;
public bool IsExample
{
    get => _isExample;
    set
    {
        if (value != _isExample)
        {
            _isExample = value;
            UpdateDatabase();
        }
    }
}
\end{minted}

The UpdateDatabase method saves the changes to the database. This Id has a private setter since the Id property can only be changed when it is created.

I can simply add SQL commands in the DataAccess class to create the tables for TestCase.

\begin{minted}{csharp}
// Create TestCase table
tableCommand +=
    @"CREATE TABLE IF NOT EXISTS TestCase
    (
        Id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
        Input TEXT NOT NULL,
        Output TEXT NOT NULL,
        IsExample INTEGER NOT NULL,
        ProblemId INTEGER,
        FOREIGN KEY (ProblemId) REFERENCES Problem (Id)
    );";
\end{minted}


After completing the TestCase model, I can implement the underlying database methods. There 4 methods I need to implement, AddTestCase creates a new test case and saves it to the database, GetAllTestCases returns all test cases in the database, EditTestCase edits an existing test case and saves it to the database, and DeleteTestCase deletes a test case from the database.

\begin{minted}{csharp}
/// <summary>
/// Pass in a <see cref="TestCase"/> without <see cref="TestCase.Id"/>.
/// Save the <see cref="TestCase"/> into database and return a <see cref="TestCase"/> with Id.
/// </summary>
/// <param name="testCase"></param>
/// <param name="problemId"></param>
/// <returns></returns>
internal static TestCase AddTestCase(string input, string output, bool isExample, int? problemId = null)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();
        SqliteCommand insertCommand = new();
        insertCommand.Connection = conn;

        insertCommand.CommandText = "INSERT INTO TestCase (Input, Output, IsExample, ProblemId) VALUES (@Input, @Output, @IsExample, @ProblemId);";
        insertCommand.Parameters.AddWithValue("@Input", input);
        insertCommand.Parameters.AddWithValue("@Output", output);
        insertCommand.Parameters.AddWithValue("@IsExample", isExample);
        insertCommand.Parameters.AddWithValue("@ProblemId", problemId == null ? DBNull.Value : problemId);

        insertCommand.ExecuteNonQuery();

        SqliteCommand selectIdCommand = new("SELECT last_insert_rowid();", conn);
        var query = selectIdCommand.ExecuteReader();
        query.Read();
        return new TestCase(query.GetInt32(0), input, output, isExample);
    }
}

/// <summary>
/// Return all test cases in the database as a list
/// </summary>
/// <returns></returns>
internal static List<TestCase> GetAllTestCases()
{
    List<TestCase> testCases = new();

    using (SqliteConnection connection = new(ConnectionString))
    {
        connection.Open();

        SqliteCommand selectCommand = new("SELECT * from TestCase", connection);

        SqliteDataReader query = selectCommand.ExecuteReader();

        while (query.Read())
        {
            testCases.Add(new(query.GetInt32(0), query.GetString(1), query.GetString(2), query.GetBoolean(3)));
        }
    }
    return testCases;
}

/// <summary>
/// Edit an existing test case with the given id
/// </summary>
/// <param name="id"></param>
/// <param name="newInput"></param>
/// <param name="newOutput"></param>
/// <param name="newIsExample"></param>
/// <param name="newProblemId"></param>
internal static void EditTestCase(int id, string newInput, string newOutput, bool newIsExample, int? newProblemId = null)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand updateCommand = new();
        updateCommand.Connection = conn;

        updateCommand.CommandText = "UPDATE TestCase SET Input = @newInput, Output = @newOutput, IsExample = @newIsExample, ProblemId = @newProblemId WHERE Id = @Id;";
        updateCommand.Parameters.AddWithValue("@newInput", newInput);
        updateCommand.Parameters.AddWithValue("@newOutput", newOutput);
        updateCommand.Parameters.AddWithValue("@newIsExample", newIsExample);
        updateCommand.Parameters.AddWithValue("@newProblemId", newProblemId == null ? DBNull.Value : newProblemId);
        updateCommand.Parameters.AddWithValue("@Id", id);

        updateCommand.ExecuteNonQuery();
    }
}

/// <summary>
/// Delete a test case with the given id
/// </summary>
/// <param name="id"></param>
internal static void DeleteTestCase(int id)
{
    using (SqliteConnection conn = new(ConnectionString))
    {
        conn.Open();

        SqliteCommand deleteCommand = new();
        deleteCommand.Connection = conn;
        deleteCommand.CommandText = "DELETE FROM TestCase WHERE Id = @Id";
        deleteCommand.Parameters.AddWithValue("@Id", id);
        deleteCommand.ExecuteNonQuery();
    }
}
\end{minted}

Finally, I add the following three tests to check whether the methods are working.

\begin{minted}{csharp}
[TestMethod]
public void TestAddTestCase()
{
    TestCase testCase1 = TestCase.Create("input", "output", true);
    Assert.AreEqual(testCase1, DataAccess.GetAllTestCases()[0]);
}

[TestMethod]
public void TestEditTestCase()
{
    TestCase testCase = TestCase.Create("input", "output", true);
    testCase.Input = "newInput";
    testCase.Output = "newOutput";
    testCase.IsExample = false;
    Assert.AreEqual(testCase, DataAccess.GetAllTestCases()[0]);
}

[TestMethod]
public void TestDeleteTestCase()
{
    TestCase testCase = TestCase.Create("input", "output", true);
    testCase.Delete();
    Assert.AreEqual(0, DataAccess.GetAllTestCases().Count);
}
\end{minted}

However, when I run the tests, I encountered the following errors:

\begin{minted}{text}
> dotnet test --filter "Name~TestCase"
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.1.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.
  Failed TestAddTestCase [123 ms]
  Error Message:
   Assert.AreEqual failed. Expected:<Algorithm_Dynamics.Core.Models.TestCase>. Actual:<Algorithm_Dynamics.Core.Models.TestCase>.
  Stack Trace:
     at Algorithm_Dynamics.Test.TestDataAccess.TestAddTestCase() in C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\TestDataAccess.cs:line 141

  Failed TestEditTestCase [44 ms]
  Error Message:
   Assert.AreEqual failed. Expected:<Algorithm_Dynamics.Core.Models.TestCase>. Actual:<Algorithm_Dynamics.Core.Models.TestCase>.
  Stack Trace:
     at Algorithm_Dynamics.Test.TestDataAccess.TestEditTestCase() in C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\TestDataAccess.cs:line 151

Failed!  - Failed:     2, Passed:     1, Skipped:     0, Total:     7, Duration: 2 s - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}

The EditTestCase and AddTestCase tests are failed. After setting a few breakpoints and watches the actual value. I find that the actual value in the instance is actually correct. But when dotnet is comparing these two intances, they are considered to be different. One possible solution is to override the Equals method of the TestCase class, so dotnet can determine whether two instances are equal correctly.

\begin{minted}{csharp}
/// <summary>
/// Determine whether two testcases are the same
/// </summary>
/// <param name="obj"></param>
/// <returns></returns>
public override bool Equals(object obj)
{
    if (obj is not TestCase testCase)
        return false;
    return Id == testCase.Id && Input == testCase.Input && Output == testCase.Output && IsExample == testCase.IsExample;
}

public override int GetHashCode()
{
    return HashCode.Combine(Id, Input, Output, IsExample);
}
\end{minted}

Now when I run the tests again, it passes without any problem.

\begin{minted}{text}
> dotnet test --filter "Name~TestCase"
  Determining projects to restore...
  All projects are up-to-date for restore.
  Algorithm Dynamics.Core -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Core\bin\Debug\net6.0\Algorithm Dynamics.Core.dll
  Algorithm Dynamics.Test -> C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll
Test run for C:\Algorithm-Dynamics\src\Algorithm Dynamics.Test\bin\Debug\net6.0\Algorithm Dynamics.Test.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.1.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3, Duration: 946 ms - Algorithm Dynamics.Test.dll (net6.0)
\end{minted}



\subsection{Integration}

I then need to integrate the core code with the UI.

On the HomePage, I need to implement the random problem button and the recommendations.

\begin{minted}{csharp}
private void InitializeQAItems()
{
    // ...    
    QAItems.Add(new QuickAccessItem("Random Problem", Symbol.Shuffle, () =>
        {
            // Get all problems from the database
            List<Problem> problems = Problem.All;

            // Generate a random index
            var random = new Random();
            int randomIndex = random.Next(problems.Count);

            // Get the corresponding problem
            Problem problem = problems[randomIndex];

            // Navigate to coding page with the problems as parameters
            App.NavigateTo(typeof(CodingPage), Tuple.Create(problem, problems));
        }));
    // ...
}

/// <summary>
/// Generate Recommendation from database.
/// </summary>
private void InitializeRecItems()
{
    RecItems.Clear();
    // Generate recommend problems
    var problems = Problem.All;
    for (int i = 0; i < problems.Count && i < 4; i++)
    {
        var problem = problems[i];
        RecItems.Add(new RecommendItem(problem.Name, $"{problem.DifficultyAsString} | {problem.TagAsString}", () => { App.NavigateTo(typeof(CodingPage), Tuple.Create(problem, Problem.All)); }));
    }
    // If no item, hide the title
    if (RecItems.Count == 0)
    {
        RecommendTextBlock.Visibility = Visibility.Collapsed;
    }
    else
    {
        RecommendTextBlock.Visibility = Visibility.Visible;
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{HomePage-Final}

Now, when I click the random problem button or the recommendations button, I am navigated to the correct problem correctly.

On the ProblemsPage, I first set up the RefreshDatabase method. It loads all data from the database for further queries.

\begin{minted}{csharp}
/// <summary>
/// Reload all data from the database
/// </summary>
private void RefreshDatabase()
{
    // Clear the existing lists
    ProblemLists.Clear();
    Tags.Clear();
    Problems.Clear();

    // Load all data from the database
    Problem.All.ForEach(problem => Problems.Add(problem));
    Core.Models.Tag.All.ForEach(tag => Tags.Add(tag));
    ProblemList.All.ForEach(problemList => ProblemLists.Add(problemList));
}
\end{minted}

I implement the DeleteProblem method, it shows up a dialogue and deletes the selected problem.

\begin{minted}{csharp}
/// <summary>
/// Show a content dialog to confirm the deletion of Problems
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
/// <exception cref="NotImplementedException"></exception>
private async void DeleteProblems(object sender, RoutedEventArgs e)
{
    ContentDialog dialog = new()
    {
        Title = "Delete Problem",
        PrimaryButtonText = "Delete",
        CloseButtonText = "Cancel",
        Content = $"Are you sure that you want to permanently delete these {ProblemsListView.SelectedItems.Count} Problems?",
        DefaultButton = ContentDialogButton.Close,
        XamlRoot = Content.XamlRoot
    };
    var result = await dialog.ShowAsync();
    if (result == ContentDialogResult.Primary)
    {
        var problems = ProblemsListView.SelectedItems;
        foreach (Problem problem in problems) problem.Delete();
        RefreshDatabase();
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-Delete}

Next, I need to implement the search function. When the search box is submitted or the combo box is selected, a Query function is executed and return the search result.

\begin{minted}{csharp}
/// <summary>
/// Trigger when the search box is submitted
/// </summary>
private void Search(AutoSuggestBox sender, AutoSuggestBoxQuerySubmittedEventArgs args)
    => Query();

/// <summary>
/// Trigger when the combo box is changed
/// </summary>
private void Search(object sender, SelectionChangedEventArgs e)
    => Query();

private void Query()
{
    // Clear existing results
    Problems.Clear();
    NoResultTextBlock.Visibility = Visibility.Collapsed;
    
    // Get all problems
    var problems = Problem.All;

    // Query difficulty
    if (DifficultyComboBox.SelectedIndex != -1)
    {
        var difficulty = (Difficulty)DifficultyComboBox.SelectedIndex;
        problems.RemoveAll(p => p.Difficulty != difficulty);
    }

    // Query status
    if (StatusComboBox.SelectedIndex != -1)
    {
        var status = (ProblemStatus)StatusComboBox.SelectedIndex;
        problems.RemoveAll(p => p.Status != status);
    }

    // Query tag
    if (TagComboBox.SelectedIndex != -1)
    {
        var tag = (Tag)TagComboBox.SelectedItem;
        problems.RemoveAll(p => p.Tags.Contains(tag) == false);
    }

    // Query list
    if (ListComboBox.SelectedIndex != -1)
    {
        var list = (ProblemList)ListComboBox.SelectedItem;
        problems.RemoveAll(p => list.Problems.Contains(p) == false);
    }

    // Query name
    if (string.IsNullOrEmpty(ProblemsSearchBox.Text) == false)
    {
        var name = ProblemsSearchBox.Text;
        problems.RemoveAll(p => p.Name != name);
    }

    // Handle no result
    if (problems.Count == 0)
        NoResultTextBlock.Visibility = Visibility.Visible;

    // Return results
    foreach (var problem in problems)
    {
        Problems.Add(problem);
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-Testing-Search}

When the user is inputting in the search box, the fuzzy search provides suggestions in the drop-down menu. The exact algorithm is explained in the design chapter.

\begin{minted}{csharp}
/// <summary>
/// Give fuzzy search suggestions when the user is inputing search query
/// </summary>
/// <param name="sender"></param>
/// <param name="args"></param>
private void ProblemsSearchBox_TextChanged(AutoSuggestBox sender, AutoSuggestBoxTextChangedEventArgs args)
{
    // Query if empty
    if (string.IsNullOrEmpty(ProblemsSearchBox.Text))
    {
        Query();
    }
    else
    {
        // Give fuzzy search suggestions
        string keyword = ProblemsSearchBox.Text.Trim();
        var resultList = new List<Problem>();
        var sourceList = Problem.All;
        var splitKeyword = keyword.ToLower().Split(' ');
        for (int i = 0; i < sourceList.Count; i++)
        {
            for (int j = 0; j < splitKeyword.Length; j++)
            {
                var sourceKey = sourceList[i].Name.ToLower();
                if (sourceKey.Contains(splitKeyword[j]))
                {
                    resultList.Add(sourceList[i]);
                    break;
                }
            }
        }
        // Return result
        sender.ItemsSource = resultList.Select(p => p.Name).ToList();
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{ProblemsPage-FuzzySearch}

Next, I integrate the CreateNew pages. I will show the CreateNewProblemListPage as an example since both of them share a similar process, please refer to the source code for details.

The key to the integration is to create a new problem list and save any changes to the database.

\begin{minted}{csharp}
/// <summary>
/// When the save button is clicked, save the problem list and change the description test.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void SaveButton_Click(object sender, RoutedEventArgs e)
{
    if (_pageMode == Mode.CreateProblemList)
    {
        _problemList = ProblemList.Create(_name, _description, Problems.ToList());
    }
    else if (_pageMode == Mode.EditProblemList)
    {
        // Save name
        _problemList.Name = _name;
        // Save description
        _problemList.Description = _description;
        // Save problems
        Problems.ToList().ForEach(problem =>
        {
            if (_problemList.Problems.Contains(problem) == false)
            {
                _problemList.AddProblem(problem);
            }
        });
        _problemList.Problems.ToList().ForEach(problem =>
        {
            if (Problems.Contains(problem) == false)
            {
                _problemList.RemoveProblem(problem);
            }
        });
    }

    // Done
    TestTextBlock.Text = "The Problem List is saved.";
}
\end{minted}

I also need to add validation to all the fields to ensure none of them is empty.

\begin{minted}{csharp}
public bool IsValidInput
{
    get
    {
        ErrorMessage = "";
        bool isValid = true;
        if (string.IsNullOrEmpty(_name))
        {
            isValid = false;
            ErrorMessage += "A name is required.\n";
        }
        if (Problems.Count < 1)
        {
            isValid = false;
            ErrorMessage += "At least one problem is required.\n";
        }
        return isValid;
    }
}
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CreateNewProblemListPage-Testing-Empty}

In the CodingPage Integration, I need to render the given problem into a markdown file, so it can be displayed with all formats supported.

\begin{minted}{csharp}
/// <summary>
/// The renderec markdown text of the current problem
/// </summary>
public string ProblemMarkdown
{
    get
    {
        if (_currentProblem != null)
        {
            const int MB = 1024 * 1024;
            
            // Set title
            string title = $"# {_currentProblem.Name}\n";
            
            // Set time limit
            string timeLimit = $"\n## Time Limit\n{_currentProblem.TimeLimit} ms";
            
            // Set memory limit
            string memoryLimit = $"\n## Memory Limit\n{_currentProblem.MemoryLimit / MB} MB";
            
            // Set example test case
            string example = "\n## Example";
            int testCaseCnt = 1;
            _currentProblem.TestCases.Where(testCase => testCase.IsExample == true).ToList().ForEach(testCase =>
            {
                example += $"\n### Example Input {testCaseCnt}\n";
                example += "```\n" + testCase.Input.Replace("\n", "\n") + "\n```\n";
                example += $"\n### Example Output {testCaseCnt}\n";
                example += "```\n" + testCase.Output.Replace("\n", "\n") + "\n```\n";
                testCaseCnt++;
            });

            return title + _currentProblem.Description + timeLimit + memoryLimit + example;
        }
        return "";
    }
}
\end{minted}

I use the test data in the design section to test the markdown renderer. However, the data is not rendered as expected. There is no line break, and all text is rendered as the title.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-MarkdownTest-Failed}

After some debugging and reading the documentation of the markdown control, I found that I should use `\textbackslash r' instead of `\textbackslash n' for newlines.

\begin{minted}{csharp}
/// <summary>
/// The renderec markdown text of the current problem
/// </summary>
public string ProblemMarkdown
{
    get
    {
        if (_currentProblem != null)
        {
            const int MB = 1024 * 1024;
            
            // Set title
            string title = $"# {_currentProblem.Name}\r";
            
            // Set time limit
            string timeLimit = $"\r## Time Limit\r{_currentProblem.TimeLimit} ms";
            
            // Set memory limit
            string memoryLimit = $"\r## Memory Limit\r{_currentProblem.MemoryLimit / MB} MB";
            
            // Set example test case
            string example = "\r## Example";
            int testCaseCnt = 1;
            _currentProblem.TestCases.Where(testCase => testCase.IsExample == true).ToList().ForEach(testCase =>
            {
                example += $"\r### Example Input {testCaseCnt}\r";
                example += "```\r" + testCase.Input.Replace("\r", "\r") + "\r```\r";
                example += $"\r### Example Output {testCaseCnt}\r";
                example += "```\r" + testCase.Output.Replace("\r", "\r") + "\r```\r";
                testCaseCnt++;
            });

            return title + _currentProblem.Description + timeLimit + memoryLimit + example;
        }
        return "";
    }
}
\end{minted}

The markdown renderer works correctly now.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-MarkdownTest}

For the submission grid, I can directly bind it to the list of submissions and it will get updated automatically when a new submission is created.

\begin{minted}{xml}
<controls:DataGrid
    x:Name="SubmissionsDataGrid"
    AutoGenerateColumns="False"
    IsReadOnly="True"
    SelectionMode="Single"
    CanUserReorderColumns="False"
    MinColumnWidth="100"
    SelectionChanged="SubmissionsDataGrid_SelectionChanged"
    ItemsSource="{x:Bind ReverseSubmissions, Mode=OneWay}">
    <controls:DataGrid.Columns>
    <controls:DataGridTextColumn
        Header="Submit Time"
        Width="SizeToCells"
        Binding="{Binding Submission.SubmittedTime}"/>
    <controls:DataGridComboBoxColumn
        Header="Status"
        Width="SizeToCells"
        Binding="{Binding Result}"/>
    <controls:DataGridComboBoxColumn
        Header="Runtime"
        Width="SizeToCells"
        Binding="{Binding CPUTimeAsString}"/>
    <controls:DataGridComboBoxColumn
        Header="Memory"
        Width="SizeToCells"
        Binding="{Binding MemoryUsageAsString}"/>
    <controls:DataGridComboBoxColumn
        Header="Language"
        Width="SizeToCells"
        Binding="{Binding Submission.Language.DisplayName}"/>
    </controls:DataGrid.Columns>
</controls:DataGrid>
\end{minted}

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{CodingPage-SubmissionGrid}

Finally, I need to integrate the AccountPage. The main job is to generate all statistics for the current user. The InitializeStatsItems procedure is called when the constructor of the Page is executed, so the statistics are generated when the page is loaded. It reads from the database and performs the calculations and save the results.

\begin{minted}{csharp}
public AccountPage()
{
    InitializeComponent();
    InitializeStatsItems();
}
/// <summary>
/// Initialize the statistics items
/// </summary>
private void InitializeStatsItems()
{
    // Count all problems solved
    StatsItems.Add(new("Problem Solved", Problem.All.Count(problem => problem.Status == ProblemStatus.Solved).ToString()));
    
    // Count all problems attempted
    StatsItems.Add(new("Problem Attempted", Problem.All.Count(problem => problem.Status == ProblemStatus.Attempted).ToString()));
    
    // Count all problems todo
    StatsItems.Add(new("Problem Todo", Problem.All.Count(problem => problem.Status == ProblemStatus.Todo).ToString()));

    // Count correct rate
    StatsItems.Add(new("Correct Rate", $"{(SubmissionResult.All.Count(result => result.ResultCode == ResultCode.SUCCESS) * 100 / Submission.All.Count)}%"));

    // Count the favourite tag
    string favTag = "";
    int maxTag = 0;
    foreach (var tag in Core.Models.Tag.All)
    {
        int tagCnt = Submission.All.Count(submission => submission.Problem.Tags.Contains(tag));
        if (tagCnt > maxTag)
        {
            maxTag = tagCnt;
            favTag = tag.Name;
        }
    }
    StatsItems.Add(new("Favourite Topic", favTag));

    // Count the favourite language
    string favLang = "";
    int maxLang = 0;
    foreach (var lang in Core.Models.Language.All)
    {
        int langCnt = Submission.All.Count(submission => Equals(submission.Language, lang));
        if (langCnt > maxLang)
        {
            maxLang = langCnt;
            favLang = lang.DisplayName;
        }
    }
    StatsItems.Add(new("Favourite Language", favLang));
}
\end{minted}

When I first run the app, it crashes when I navigated to the AccountPage. The following error message is thrown.

\begin{minted}{text}
System.DivideByZeroException
  HResult=0x80020012
  Message=Attempted to divide by zero.
  Source=Algorithm Dynamics
  StackTrace:
   at Algorithm_Dynamics.Pages.AccountPage.InitializeStatsItems() in C:\Algorithm-Dynamics\src\Algorithm Dynamics\Pages\AccountPage.xaml.cs:line 134
   at Algorithm_Dynamics.Pages.AccountPage..ctor() in C:\Algorithm-Dynamics\src\Algorithm Dynamics\Pages\AccountPage.xaml.cs:line 20
   at Algorithm_Dynamics.Algorithm_Dynamics_XamlTypeInfo.XamlTypeInfoProvider.Activate_59_AccountPage() in C:\Algorithm-Dynamics\src\Algorithm Dynamics\obj\x64\Debug\net6.0-windows10.0.19041.0\XamlTypeInfo.g.cs:line 567
   at Algorithm_Dynamics.Algorithm_Dynamics_XamlTypeInfo.XamlUserType.ActivateInstance() in C:\Algorithm-Dynamics\src\Algorithm Dynamics\obj\x64\Debug\net6.0-windows10.0.19041.0\XamlTypeInfo.g.cs:line 7704
   at ABI.Microsoft.UI.Xaml.Markup.IXamlType.Do_Abi_ActivateInstance_13(IntPtr thisPtr, IntPtr* result)

  This exception was originally thrown at this call stack:
    Algorithm_Dynamics.Pages.AccountPage.InitializeStatsItems() in AccountPage.xaml.cs
    Algorithm_Dynamics.Pages.AccountPage.AccountPage() in AccountPage.xaml.cs
    Algorithm_Dynamics.Algorithm_Dynamics_XamlTypeInfo.XamlTypeInfoProvider.Activate_59_AccountPage() in XamlTypeInfo.g.cs
    Algorithm_Dynamics.Algorithm_Dynamics_XamlTypeInfo.XamlUserType.ActivateInstance() in XamlTypeInfo.g.cs
    ABI.Microsoft.UI.Xaml.Markup.IXamlType.Do_Abi_ActivateInstance_13(System.IntPtr, System.IntPtr*)
\end{minted}

It is a divide by zero error because the number of submissions is 0. I can fix this by adding branching to handle the 0 cases.

\begin{minted}{csharp}
// Count correct rate
if (Submission.All.Count > 0)
{
    StatsItems.Add(new("Correct Rate", $"{(SubmissionResult.All.Count(result => result.ResultCode == ResultCode.SUCCESS) * 100 / Submission.All.Count)}%"));
}
else
{
    StatsItems.Add(new("Correct Rate", "0%"));
}
\end{minted}

Now the AccountPage works correctly with all statistics showing up correctly.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{AccountPage-Final.png}

\subsection{Stakeholder feedback}

Mr Grimwood asked me what will happen to the account page when the software is installed for the first time. Where does the user create an account? In my current design, there is no such sign-up page. I think when the app launches if it finds there is no user in the database, it should promote the user to a registration page. The user can only log in after registration.

I place the welcome page in the main window.

\begin{minted}{xml}
<!--WelcomePage for creating new user on first startup-->
<Grid
    Grid.Row="1"
    x:Name="WelcomeGrid"
    Visibility="Collapsed"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
    <StackPanel
    VerticalAlignment="Center"
    HorizontalAlignment="Center">
    <TextBlock 
        Margin="32"
        Style="{ThemeResource TitleTextBlockStyle}"
        Text="Welcome to Algorithm Dynamics"/>
    <TextBox
        Header="Your Name"
        Margin="8"
        MaxWidth="200"
        PlaceholderText="Name"
        IsSpellCheckEnabled="False"
        Text="{x:Bind UserName, Mode=TwoWay}"/>
    <TextBox
        Header="Your Email"
        Margin="8"
        MaxWidth="200"
        PlaceholderText="Email"
        IsSpellCheckEnabled="False"
        Text="{x:Bind Email, Mode=TwoWay}"/>
    <ComboBox
        Header="Role"
        Margin="8"
        MaxWidth="200"
        HorizontalAlignment="Stretch"
        SelectedIndex="{x:Bind RoleIndex, Mode=TwoWay}">
        <x:String>Student</x:String>
        <x:String>Teacher</x:String>
    </ComboBox>
    <Button 
        x:Name="CreateUserButton"
        Margin="16"
        Content="Go"
        MaxWidth="200"
        HorizontalAlignment="Stretch"
        IsEnabled="{x:Bind IsValidInput, Mode=OneWay}"
        Click="CreateUserButton_Click"/>
    <TextBlock
        Margin="4"
        Text="{x:Bind ErrorMessage, Mode=OneWay}"
        RelativePanel.Below="InputPanel"
        MaxWidth="200"
        RelativePanel.AlignLeftWith="InputPanel"
        Foreground="Red"/>
    </StackPanel>
</Grid>
\end{minted}

In the constructor of the main window, the welcome grid is shown if there is no user in the database.

\begin{minted}{csharp}
public MainWindow()
{
    // ...
    // If no user, show welcome grid
    if (DataAccess.GetAllUsers().Count == 0)
    {
        WelcomeGrid.Visibility = Visibility.Visible;
        UserName = "";
        Email = "";
        Role = 0;
    }
    else
    {
        MainNavView.SelectedItem = MainNavView.MenuItems[0];
    }
}
\end{minted}

When the user clicks the create button, the user is created in the database and the user is navigated to the HomePage.

\begin{minted}{csharp}
/// <summary>
/// Create a new user and store <see cref="User.Uid"/> into settings
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void CreateUserButton_Click(object sender, RoutedEventArgs e)
{
    // Create user
    User user = User.Create(UserName, Email, Role);

    // Set current user
    ApplicationDataContainer localSettings = ApplicationData.Current.LocalSettings;
    localSettings.Values["CurrentUser"] = user.Uid;

    // Navigate to HomePage
    WelcomeGrid.Visibility = Visibility.Collapsed;
    MainNavView.SelectedItem = MainNavView.MenuItems[0];
}
\end{minted}

I also set a validation function IsValid. If the user input is not valid, the create button is disabled and a user-friendly error message is displayed.

\begin{minted}{csharp}
/// <summary>
/// Validate the name and the email
/// </summary>
public bool IsValidInput
{
    get
    {
        ErrorMessage = "";
        if (string.IsNullOrEmpty(UserName) || string.IsNullOrEmpty(Email)) 
            return false;
        bool isValid = true;
        if (string.IsNullOrEmpty(UserName))
        {
            isValid = false;
            ErrorMessage += "A user name is required.\n";
        }
        if (IsValidEmail(Email) == false)
        {
            isValid = false;
            ErrorMessage += "The email address is not valid.\n";
        }
        return isValid;
    }
}
\end{minted}

Now, when the user runs the app for the first time, he will be promoted to this registration page.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{WelcomeScreen}

Both name and email are validated before the user can continue.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{WelcomeScreen-Validation}

Mr Grimwood is satisfied with the design and the solution.

\end{document}